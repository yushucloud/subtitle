1
00:00:00,240 --> 00:00:04,000
the central processing unit or cpu is like the engine in your car
中央处理单元或 cpu就像您汽车中的引擎

2
00:00:04,000 --> 00:00:07,200
or the brain in your skull and is like a really fancy calculator
或您头骨中的大脑，并且就像一个非常精美的计算器

3
00:00:07,200 --> 00:00:10,719
used to run the applications on your computer when you write software in a
，当您使用您实际编写的 javascript 或 python 等语言编写软件时，它用于在您的计算机上运行应用程序

4
00:00:10,719 --> 00:00:13,920
language like javascript or python you're actually writing a set of
一组

5
00:00:13,920 --> 00:00:17,600
instructions that will be executed as machine code by a cpu
指令将由cpu 作为机器代码执行，

6
00:00:17,600 --> 00:00:21,760
which itself is a carefully crafted piece of metal and silicon that contains
cpu 本身是精心制作的金属和硅片，包含

7
00:00:21,760 --> 00:00:25,760
billions of tiny transistors or on off switches that represent ones
数十亿个微型晶体管或代表 1 和 0 的开关，

8
00:00:25,760 --> 00:00:28,720
and zeros to perform mathematical calculations a
以执行数学计算

9
00:00:28,720 --> 00:00:32,800
cpu will combine multiple transistors together to form logic gates
cpu 将组合多个晶体管

10
00:00:32,800 --> 00:00:37,200
for example and will take two binary inputs and validate that both are true
例如，一起形成逻辑门，将接受两个二进制输入并验证两者都是真实的

11
00:00:37,200 --> 00:00:41,360
to produce a true output it only takes a few basic logic gates to solve highly
以产生真实的输出只需要几个基本的逻辑门来解决高度

12
00:00:41,360 --> 00:00:44,800
complex computational problems modern chips contain billions of
复杂的计算问题现代芯片包含数十亿个

13
00:00:44,800 --> 00:00:48,640
transistors and they can be flipped on and off billions of times per second
晶体管，它们可以翻转并且每秒关闭数十亿次

14
00:00:48,640 --> 00:00:52,399
the state of the cpu is synchronized by an oscillator known as the clock
cpu 的状态由称为时钟发生器的振荡器同步

15
00:00:52,399 --> 00:00:54,800
generator in general the more times the clock can
一般来说，时钟

16
00:00:54,800 --> 00:00:58,879
pulse per second the faster the cpu can compute and is normally measured in
每秒脉冲的次数越多，cpu 的计算速度就越快，通常以千兆赫为单位来衡量，

17
00:00:58,879 --> 00:01:01,440
gigahertz gamers will sometimes overclock their
游戏玩家有时会超频他们的

18
00:01:01,440 --> 00:01:05,280
cpus to gain more performance at the cost of higher temperatures and a
cpu 以获得更高的性能，但现在以更高的温度和

19
00:01:05,280 --> 00:01:09,200
lower life expectancy now in order to run applications it interacts with the
更低的预期寿命为代价来运行应用程序 它通过

20
00:01:09,200 --> 00:01:12,479
system memory or ram in a series of four steps known as the
一系列称为机器或指令周期的四个步骤与系统内存或 ram 交互

21
00:01:12,479 --> 00:01:16,479
machine or instruction cycle step one is the fetch phase think of a
第一步是获取阶段 将

22
00:01:16,479 --> 00:01:20,320
software program as a set of instructions stored in the ram the cpu
软件程序视为存储在 ram 中的一组指令 cpu

23
00:01:20,320 --> 00:01:24,159
has registers to temporarily store the address and memory that it wants to
具有用于临时存储地址的寄存器 它想要

24
00:01:24,159 --> 00:01:26,720
interact with the program counter starts at 0
与程序计数器交互的内存从 0 开始，

25
00:01:26,720 --> 00:01:30,560
and copies that address to the memory address register then the control unit
并将该地址复制到内存地址寄存器，然后控制单元

26
00:01:30,560 --> 00:01:33,439
sends out a signal to copy the data from that address
发出一个信号，将数据从该地址复制

27
00:01:33,439 --> 00:01:37,200
to the instruction register at which point it needs to figure out how to use
到指令寄存器，此时它需要弄清楚 如何

28
00:01:37,200 --> 00:01:40,000
this instruction in the decode phase the control unit
在解码阶段使用该指令 控制单元

29
00:01:40,000 --> 00:01:42,159
parses the actual bits in the instruction
解析指令中的实际位

30
00:01:42,159 --> 00:01:46,479
most importantly the opt code contains the instruction like add or subtract and
最重要的是 opt code 包含ns 指令，如加法或减法

31
00:01:46,479 --> 00:01:50,320
the operand is the address in memory to perform that operation on
，操作数是内存中的地址，以

32
00:01:50,320 --> 00:01:54,240
the final execute stage takes the decoded information and passes it as
在最终执行阶段执行该操作

33
00:01:54,240 --> 00:01:57,040
electrical signals to the relevant parts of the cpu


34
00:01:57,040 --> 00:02:01,280
the arithmetic logic unit or alu can perform math on the data and then store
在数据上，然后

35
00:02:01,280 --> 00:02:04,960
the results in ram to change the state of the program the cycle is repeated
将结果存储在 ram 中以改变程序的状态 循环每秒重复

36
00:02:04,960 --> 00:02:08,399
billions of times per second and modern chips utilize multiple cpu
数十亿次，现代芯片利用多个 cpu

37
00:02:08,399 --> 00:02:11,039
cores to run multiple computations in parallel
内核并行运行多个计算，

38
00:02:11,039 --> 00:02:14,319
that's how a cpu works under the hood but there's a lot more you should know
这就是 cpu 在引擎盖下的工作方式，但有一个 如果您是开发人员，您应该了解更多

39
00:02:14,319 --> 00:02:17,760
about processor architectures if you're a developer and that's why i've invited
关于处理器架构的知识，这就是为什么我邀请

40
00:02:17,760 --> 00:02:20,480
alex from the most underrated tech channel on youtube
来自 youtube 上最被低估的技术频道的 alex

41
00:02:20,480 --> 00:02:23,760
to break down some more advanced concepts like apple silicon and how to
来分解一些更高级的概念，例如苹果芯片以及如何

42
00:02:23,760 --> 00:02:26,000
run performance benchmarking on your own machine
在您自己的机器上运行性能基准测试

43
00:02:26,000 --> 00:02:30,080
hi everybody my name is alex and i'm here to take you beyond 100 seconds in
大家好，我的名字是亚历克斯，我来这里是为了带你超过 100 秒，

44
00:02:30,080 --> 00:02:32,720
your quest to learn about how processor
以了解处理器

45
00:02:32,720 --> 00:02:36,640
architectures differ and also how those differences affect our productivity
架构的不同之处 以及这些差异如何影响

46
00:02:36,640 --> 00:02:39,680
as developers i'll show you what the apple silicon
我们作为开发人员的生产力

47
00:02:39,680 --> 00:02:43,760
chip and a refrigerator have in common and then i'll share some of my own


48
00:02:43,760 --> 00:02:48,080
experiences with using developer tools and build execution on the first


49
00:02:48,080 --> 00:02:53,280
generation apple silicon chip called the m1 ship as compared to the
与intel芯片相比，称为m1 ship的

50
00:02:53,280 --> 00:02:55,920
intel chip first and foremost i just want to say
芯片首先我只想

51
00:02:55,920 --> 00:02:59,840
that my personal productivity as a developer depends less on processors
说，作为开发人员，我的个人生产力较少取决于

52
00:02:59,840 --> 00:03:03,440
inside my computer and more on how much coffee i had and
计算机内部的处理器，而更多取决于我喝了多少咖啡以及

53
00:03:03,440 --> 00:03:06,560
whether i'm trying to work after a big meal
我是否要努力工作一顿大餐，

54
00:03:06,560 --> 00:03:09,680
but aside from human factors let's dig deeper into
但除了人为因素，让我们更深入地了解

55
00:03:09,680 --> 00:03:13,760
why the new apple silicon machines have been really kicking up a storm and
为什么新的苹果硅机器真的掀起了一场风暴并

56
00:03:13,760 --> 00:03:17,040
changing the industry software development included and
改变了行业包括软件开发和

57
00:03:17,040 --> 00:03:21,360
spoiler alert the m1 machines have been beating the intel machines in pretty
剧透警报 m1机器在

58
00:03:21,360 --> 00:03:26,560
much every build test i've thrown at it except a couple but it's not all roses
几乎每次构建测试中都击败了英特尔机器 除了一对夫妇，我已经抛出了它，但这并不是所有的玫瑰，

59
00:03:26,560 --> 00:03:29,120
so let's talk about some downsides later too
所以让我们稍后再谈谈一些缺点

60
00:03:29,120 --> 00:03:32,480
so why is it so darn fast the first point i want to discuss
，为什么它在第一点这么快呢？ 蚂蚁要讨论的

61
00:03:32,480 --> 00:03:36,239
is the physicality differences of the new apple silicon way
是新的苹果硅方式

62
00:03:36,239 --> 00:03:41,440
versus the old intel and amd way this is what apple silicon and your refrigerator
与旧的英特尔和 AMD 方式的物理差异 这是苹果硅和你

63
00:03:41,440 --> 00:03:44,400
at home have in common all right imagine for a
家里的冰箱的共同点，想象

64
00:03:44,400 --> 00:03:47,120
minute that you want to make a turkey with cheese sandwich
一下你想用奶酪三明治

65
00:03:47,120 --> 00:03:50,319
you go over to the refrigerator and in one place
做一只火鸡 去冰箱，在一个地方

66
00:03:50,319 --> 00:03:54,319
you have the turkey breast the cheese the mayonnaise the mustard
你有火鸡胸肉奶酪蛋黄酱芥末

67
00:03:54,319 --> 00:03:57,519
all those ingredients are right there in one place and you don't have to run
所有这些成分都在一个地方你不必

68
00:03:57,519 --> 00:04:01,120
around the house to gather them you don't have to drive to lots of stores to
在房子里跑来跑去收集它们你不必开车 到许多商店

69
00:04:01,120 --> 00:04:03,840
pick them up and this saves you lots of time and
取货，这样可以节省大量时间和

70
00:04:03,840 --> 00:04:07,840
energy this kind of efficiency can be found in the new apple silicon
精力这种效率可以在新的苹果硅

71
00:04:07,840 --> 00:04:11,200
chips because they aren't just a new processor
芯片中找到，因为它们不仅仅是一个新的处理器

72
00:04:11,200 --> 00:04:14,799
apple silicon is a collection of many chips that are housed inside
苹果硅是许多芯片的集合 在

73
00:04:14,799 --> 00:04:19,759
one silicon container and this type of system is known as a system on chip
一个硅容器内，这种类型的系统被称为片上系统

74
00:04:19,759 --> 00:04:23,120
or sock and it's essentially an entire computer
或袜子，它本质

75
00:04:23,120 --> 00:04:29,199
on one chip the main cpu the gpu the i o controller the ml engine they're
上是一个芯片上的整个计算机主 cpugpu i o 控制器 ml 引擎它们

76
00:04:29,199 --> 00:04:32,800
all co-located so when the task is to make an
都是 co-lo因此，当任务是制作

77
00:04:32,800 --> 00:04:36,639
electronic sandwich so to speak or in other words to do some work that
电子三明治时，可以这么说，或者换句话说，做一些

78
00:04:36,639 --> 00:04:40,560
involves all these different components a system on chip is going to be a lot
涉及所有这些不同组件的工作时，片上系统将

79
00:04:40,560 --> 00:04:44,320
more efficient in terms of energy usage using only a
在能源使用方面更加高效，只需一

80
00:04:44,320 --> 00:04:46,960
tiny bit of power and at the same time it's going to be
点点 功率，同时它

81
00:04:46,960 --> 00:04:50,320
faster than say a typical machine that has all the components
会比一个典型的机器

82
00:04:50,320 --> 00:04:54,000
separate intel based machines have a cpu that's a single


83
00:04:54,000 --> 00:04:57,759
chip and memory is located somewhere else on the motherboard


84
00:04:57,759 --> 00:05:02,400
the i o is somewhere else the individual components might be even more powerful
更快 可能

85
00:05:02,400 --> 00:05:06,720
than the ones available at the moment on the latest apple silicon based machines
比目前最新的基于苹果硅的机器上的功能更强大，

86
00:05:06,720 --> 00:05:10,800
but that comes at a cost since these powerful components are like
但这是有代价的，因为这些强大的组件就像

87
00:05:10,800 --> 00:05:13,919
supermarkets that carry different sandwich ingredients
超市一样，带有不同的三明治成分

88
00:05:13,919 --> 00:05:17,680
as a result when you want a sandwich on an intel machine
，因此当你想要在英特尔机器上吃三明治时，

89
00:05:17,680 --> 00:05:22,080
you'll have to drive all over town because one store will have the turkey
你 必须开车跑遍全城，因为一家商店有火鸡，

90
00:05:22,080 --> 00:05:26,720
another store will have the cheese yet another store will have the mayonnaise
另一家商店有奶酪，另一家商店每家都有蛋黄酱

91
00:05:26,720 --> 00:05:30,320
each store might be really good at their own process and have the best
商店可能真的很擅长自己的流程并拥有最好的

92
00:05:30,320 --> 00:05:33,280
ingredients but each store also takes a lot of power
原料，但每家商店也需要大量的电力

93
00:05:33,280 --> 00:05:37,280
to run losing out on the efficiency and since all you really want is just to
才能失去效率，因为你真正想要的只是

94
00:05:37,280 --> 00:05:40,960
make a simple sandwich you're wasting a ton of time and energy
做一个简单的三明治，你浪费了很多 时间和精力

95
00:05:40,960 --> 00:05:44,400
picking up the ingredients from all the different stores of course some
从所有不同的商店挑选原料当然有些人

96
00:05:44,400 --> 00:05:48,320
might say the drawback with the system on chip design is that
可能会说片上系统设计的缺点是，

97
00:05:48,320 --> 00:05:51,440
at least for now with the current selection of apple max you won't be able
至少在目前选择的 apple max 中，您将

98
00:05:51,440 --> 00:05:55,120
to upgrade or change any of the components you get what's on
无法升级或更改任何 你得到的组件是什么

99
00:05:55,120 --> 00:05:58,160
the menu and that's it but that's not news to most people that
在菜单上，仅此而已，但对于大多数熟悉苹果生态系统的人来说，这并不是什么新鲜事，

100
00:05:58,160 --> 00:06:01,600
are familiar with the apple ecosystem once you accept that idea you might even
一旦你接受了这个想法，你甚至可能会

101
00:06:01,600 --> 00:06:04,240
see the benefits of having a more efficient design


102
00:06:04,240 --> 00:06:08,319
where all the components are on one chip and they outweigh the cons
看到所有组件都在一个芯片上的更高效设计的好处并且它们胜过缺点，

103
00:06:08,319 --> 00:06:11,600
and still provide better performance than the alternative all right
并且仍然提供比替代方案更好的性能，好吧

104
00:06:11,600 --> 00:06:14,800
that's enough talk about food so how does this all affect
，谈论食物就足够了，所以这一切如何影响

105
00:06:14,800 --> 00:06:19,039
real world development workflows so i've been doing a bunch of developer focused
现实世界的开发工作流程，所以我一直在做 一堆开发人员在我的频道

106
00:06:19,039 --> 00:06:22,400
tests on the latest apple silicon machines over on my channel
上对最新的苹果硅机器进行了集中测试，

107
00:06:22,400 --> 00:06:26,560
as well as comparing them to other machines like the intel max and pc
并将它们与其他机器（如英特尔 max 和 pc

108
00:06:26,560 --> 00:06:29,280
machines too and in general the new design has been
机器）进行了比较，总的来说，新设计

109
00:06:29,280 --> 00:06:32,800
showing really great promise for my own workflows as a developer
对我自己作为开发人员的工作流程显示出非常好的前景

110
00:06:32,800 --> 00:06:37,120
coffee and sandwiches excluded now there are lots of technology stacks that
咖啡和三明治现在被排除在外

111
00:06:37,120 --> 00:06:41,039
developers use of course and i'm trying builds in a few of them
，当然有很多开发人员使用的技术栈，我正在尝试构建其中的一些，

112
00:06:41,039 --> 00:06:44,880
but now let me share some of the results i've seen with node and javascript tests
但现在让我分享一些我在节点和 javascript 测试中看到的结果

113
00:06:44,880 --> 00:06:48,720
and after that i'll also discuss the tech stacks that have the biggest gains
，然后我' 我还将讨论在新机器上获得最大收益的技术堆栈，

114
00:06:48,720 --> 00:06:50,960
on the new machines and also the stacks that have the
以及

115
00:06:50,960 --> 00:06:54,560
biggest losses right now at the moment i started off trying out some existing
在我开始尝试

116
00:06:54,560 --> 00:06:59,199
javascript tests that are in the browser and then in node the browser test
浏览器中的一些现有 JavaScript 测试，然后在浏览器测试节点

117
00:06:59,199 --> 00:07:02,880
consisted of running speedometer which is a browser benchmark that
由运行速度计组成，这是一个浏览器基准测试，用于

118
00:07:02,880 --> 00:07:05,680
measures the responsiveness of web applications
测量 Web 应用程序的响应能力

119
00:07:05,680 --> 00:07:09,440
it uses demo web apps to simulate their actions such as
它使用演示 Web 应用程序来模拟它们的操作，例如

120
00:07:09,440 --> 00:07:13,120
adding to-do items you visit the app in a browser of choice
添加待办事项 您在选择的浏览器中访问该应用程序

121
00:07:13,120 --> 00:07:17,039
i tried chrome and safari for this and you execute the automated test that runs
我为此尝试了 chrome 和 safari，然后您执行自动化测试，该测试运行

122
00:07:17,039 --> 00:07:20,560
through a collection of applications built with some of the more popular
通过使用一些更流行的

123
00:07:20,560 --> 00:07:26,319
ui frameworks like angular react amber even vanilla js and jquery and a whole
ui 框架（如 angular react amber甚至 vanilla js 和 jquery 等）构建的应用程序集合

124
00:07:26,319 --> 00:07:29,039
bunch more and then this test reports the results
更多，然后这个测试在

125
00:07:29,039 --> 00:07:32,479
as a single number when it's done this number represents the runs per
完成时将结果报告为一个数字，这个数字代表每分钟的运行次数

126
00:07:32,479 --> 00:07:35,840
minute and the higher the better when it was finished i found that it had
，完成时越高越好我发现它

127
00:07:35,840 --> 00:07:39,919
significantly more iterations on the m1 safari had the best
在 m1 safari 上的迭代次数明显更多，

128
00:07:39,919 --> 00:07:44,240
results even going off the scale and chrome did pretty well too i also
甚至在 off the scale和 chrome 也做得很好 我

129
00:07:44,240 --> 00:07:47,599
ran some javascript benchmarks in a node environment
还在节点环境中运行了一些 javascript 基准测试，

130
00:07:47,599 --> 00:07:51,360
and found a pretty cpu intensive algorithm called
并发现了一个相当 cpu 密集型算法，称为

131
00:07:51,360 --> 00:07:54,479
fancook redux that's implemented in javascript
fancook redux，它是在 javascript 中实现的，

132
00:07:54,479 --> 00:07:58,479
and created for benchmarks game a website that collects
并为基准测试游戏创建了一个收集

133
00:07:58,479 --> 00:08:02,080
algorithms and tests in different languages and while my 16-inch
不同语言的算法和测试的网站，同时 我的 16 英寸

134
00:08:02,080 --> 00:08:05,440
macbook pro with the intel core i9 processor
macbook pro 配备英特尔酷睿 i9处理器

135
00:08:05,440 --> 00:08:09,759
did beat the macbook air with the m1 chip it really didn't do so by a lot
确实击败了配备 m1 芯片的 macbook air确实做到了 不要经常这样做

136
00:08:09,759 --> 00:08:12,960
and when you consider the price differences between the machines
，当您考虑机器之间的价格差异

137
00:08:12,960 --> 00:08:16,479
and the fact that the m1 stayed cool throughout the test and
以及 m1 在整个测试过程中保持凉爽

138
00:08:16,479 --> 00:08:19,759
that the battery hardly even took a hit on the m1
以及电池几乎没有对 m1 造成影响的事实时，

139
00:08:19,759 --> 00:08:23,840
you might be thinking whether the extra few seconds saved while running this
您可能会想是否额外的几秒钟 在英特尔 i9 上运行这个

140
00:08:23,840 --> 00:08:26,479
benchmark on the intel i9 is really worth the
基准测试时节省下来的

141
00:08:26,479 --> 00:08:29,280
money so running benchmarks is often very telling
钱确实物有所值，所以运行基准测试通常很能说明问题，

142
00:08:29,280 --> 00:08:32,719
but it doesn't necessarily line up with real-world scenarios
但它不一定符合现实世界的场景，

143
00:08:32,719 --> 00:08:37,120
so that's why i also like to conduct my own tests whether using my own projects
所以这就是为什么我也喜欢进行自己的测试，无论是否使用我自己的项目

144
00:08:37,120 --> 00:08:40,640
or other open source projects that are out there and that commenters
或其他开源项目，并且评论者

145
00:08:40,640 --> 00:08:43,760
sent to me and here's what i found i ran a build of the official
发送给我，这就是我发现我运行了官方

146
00:08:43,760 --> 00:08:47,279
nativescript plugins repository which is a project based on
nativescript 插件存储库的构建，这是一个基于

147
00:08:47,279 --> 00:08:51,040
nx workspaces if you're not familiar with nx workspaces it allows you to
nx 工作区的项目，如果你不熟悉 nx 工作区它允许你 要

148
00:08:51,040 --> 00:08:54,080
scale large javascript and other tech stack
扩展大型 javascript 和其他技术堆栈

149
00:08:54,080 --> 00:08:56,959
projects and you can see the nx quickstart right
项目，您可以

150
00:08:56,959 --> 00:09:00,080
here on this channel in my test the build that took about
在我的测试中在此频道上看到 nx 快速入门，

151
00:09:00,080 --> 00:09:04,160
three minutes on each machine only differed in build time by tens of
在每台机器上花费大约三分钟的构建只是不同 m1 macbook air 在三分之二的时间内击败了英特尔 macbook pro，将构建时间缩短了数十秒，

152
00:09:04,160 --> 00:09:07,200
seconds with the m1 macbook air beating out


153
00:09:07,200 --> 00:09:10,320
the intel macbook pro two out of three times so
所以

154
00:09:10,320 --> 00:09:14,480
let's talk about what dev stacks benefit the most from the new apple silicon
让我们来谈谈目前对于 javascript 开发人员来说，哪些开发堆栈从新的苹果硅

155
00:09:14,480 --> 00:09:16,959
chips at this time for javascript developers
芯片中

156
00:09:16,959 --> 00:09:20,800
the benefits are already visible however if you're building mobile apps
获益最多 可见但是，如果您正在为 ios 构建移动应用程序

157
00:09:20,800 --> 00:09:24,720
for ios for compiling c plus plus code then this is where you'll
以编译 cplus plus 代码，那么在这里您将

158
00:09:24,720 --> 00:09:30,320
see a 40 to 50 percent improvement in build times i ran a few xcode builds
看到构建时间缩短 40% 到 50%我运行了一些 xcode 构建

159
00:09:30,320 --> 00:09:33,519
and swift builds and i did some c plus plus algorithms
和快速构建，并且我做了一些 c plus plus 算法

160
00:09:33,519 --> 00:09:37,920
and built opencv and webkit in all those tests the m1
并在所有这些测试中构建了 opencv 和 webkit，m1

161
00:09:37,920 --> 00:09:41,279
came out on top so what devstacks benefit the least so
名列前茅，所以

162
00:09:41,279 --> 00:09:44,399
far in my own testing any builds that have to do with running
到目前为止，在我自己的测试中，devstacks 受益最少的任何与运行

163
00:09:44,399 --> 00:09:47,920
natively built software and building using native tooling
本机构建的软件和使用本机工具构建有关的构建

164
00:09:47,920 --> 00:09:52,480
has absolutely destroyed intel and speed and battery performance
都绝对破坏了英特尔和速度和电池性能

165
00:09:52,480 --> 00:09:56,080
native being compiled for the apple silicon architecture
本机是为苹果硅架构编译的，

166
00:09:56,080 --> 00:09:59,440
even when running some software via apple's rosetta
即使通过苹果的 Rosetta 运行一些软件

167
00:09:59,440 --> 00:10:03,760
that's the translation layer that allows you to run intel and amd based
，这是允许你运行 inte 的翻译层l 和基于 AMD 的

168
00:10:03,760 --> 00:10:07,600
x64 and x86 programs on the new apple hardware
x64 和 x86 程序在新的苹果硬件上运行，

169
00:10:07,600 --> 00:10:11,040
even some of those software packages ran better than on intel
甚至其中一些软件包比英特尔运行得更好

170
00:10:11,040 --> 00:10:14,399
and that's just amazing but there are workflows that aren't
，这真是太棒了，但是

171
00:10:14,399 --> 00:10:19,279
ready yet in my opinion if you are an android developer android studio
如果你是一个安卓开发者和安卓工作室

172
00:10:19,279 --> 00:10:23,040
and official android emulators work on apple silicon
，我认为有些工作流程还没有准备好 官方的 android 模拟器在苹果芯片上工作，

173
00:10:23,040 --> 00:10:26,399
but they're currently using rosetta for translations
但他们目前正在使用 Rosetta 进行翻译

174
00:10:26,399 --> 00:10:30,000
and while rosetta is generally pretty good at running x86
，虽然 Rosetta 通常非常擅长在 arm 芯片上运行 x86

175
00:10:30,000 --> 00:10:34,560
targeted code on arm chips it's not enough for the cpu hungry android
目标代码，但这对于 cpu 饥饿的 android

176
00:10:34,560 --> 00:10:37,519
workflows and i found the results to be not very
工作流程来说还不够，我发现结果不是很有

177
00:10:37,519 --> 00:10:40,399
usable at the moment the latest version of dot net which is
用目前，最新版本的 dot net 即

178
00:10:40,399 --> 00:10:44,320
version 5 right now isn't fully supported to run on arm
版本5 不完全支持在 arm 上运行

179
00:10:44,320 --> 00:10:47,360
simple console applications ran just fine for me
简单的控制台应用程序对我来说运行得很好，

180
00:10:47,360 --> 00:10:51,279
but testing any web workflows like asp.net core
但是测试任何 web 工作流（如asp.net core）

181
00:10:51,279 --> 00:10:54,240
doesn't work at all yet now it's expected that by the end of this year
现在根本不起作用预计到今年年底，

182
00:10:54,240 --> 00:10:57,920
dot net six will come out it's in alpha right now and we'll have
dot net 6 将推出它现在处于 alpha 状态，如果您需要开发.net 应用程序，我们将在此之前

183
00:10:57,920 --> 00:11:01,440
full support for arm until then if you need to develop.net
完全支持 arm，

184
00:11:01,440 --> 00:11:05,519
apps i suggest using a pc with windows oh and if you think you can
我建议您使用 一台带 windows 的电脑哦，如果你认为你可以

185
00:11:05,519 --> 00:11:09,600
use a virtual windows machine i've tested this as well parallels is
使用虚拟 windows 机器，我也测试过 parallels

186
00:11:09,600 --> 00:11:12,480
the only vendor that currently supports the m1
是目前唯一支持 m1

187
00:11:12,480 --> 00:11:15,920
chip to create a virtual windows environment but the issue is that the
芯片来创建虚拟 windows环境的供应商，但问题是

188
00:11:15,920 --> 00:11:20,160
windows guest operating system for arm is still quite immature and needs a lot
windows 客户操作系统 对于 arm还很不成熟，还需要

189
00:11:20,160 --> 00:11:24,240
of work also visual studio 2019 the latest visual
大量工作Visual Studio 2019 不幸的是，微软最新的 Visual

190
00:11:24,240 --> 00:11:28,240
studio offering from microsoft is unfortunately not compatible with arm
Studio 产品与 arm 完全不兼容，

191
00:11:28,240 --> 00:11:33,200
at all and my test is not stable even using the built-in windows
即使使用

192
00:11:33,200 --> 00:11:37,200
translation of x64 software to run on
x64 软件的内置 Windows 翻译运行，我的测试也不稳定 在

193
00:11:37,200 --> 00:11:41,120
arm hardware for game developers that use unity i'm pleased to say that it
使用 unity 的游戏开发人员的 arm 硬件上我很高兴地说，它

194
00:11:41,120 --> 00:11:44,000
works surprisingly well on apple silicon via rosetta
通过 Rosetta 在苹果芯片上运行得非常好，

195
00:11:44,000 --> 00:11:47,200
however it's not as performant as running natively on x86
但是它的性能不如在 x86 上原生运行，

196
00:11:47,200 --> 00:11:50,959
but by the time you watch this video unity might have a version natively
但是当你观看这个视频时，unity 可能有一个原生兼容的版本

197
00:11:50,959 --> 00:11:54,320
compatible with m1 which i know they're working hard to get
有了 m1，我知道他们正在努力

198
00:11:54,320 --> 00:11:57,519
out as soon as possible overall apple silicon has really put a
尽快退出整个苹果芯片确实

199
00:11:57,519 --> 00:12:01,440
boost into many workflows for developers and other professions and
为开发人员和其他人的许多工作流程带来了推动力 专业，

200
00:12:01,440 --> 00:12:05,120
eventually even gaming and with the m1 tests we're seeing the
最终甚至游戏，通过 m1 测试，我们看到了

201
00:12:05,120 --> 00:12:08,480
improvements with just their entry level machines the
他们的入门级机器的改进，

202
00:12:08,480 --> 00:12:12,240
upcoming second and third generation apple silicon machines will be even more
即将到来的第二代和第三代苹果硅机器将更加

203
00:12:12,240 --> 00:12:16,320
performant and i can't wait to see that i think it's really gonna help us as
性能，我迫不及待地想看到它真的会 随着

204
00:12:16,320 --> 00:12:19,920
developers move to the next level and i think it's just gonna lift up the entire
开发人员迈向新的水平，帮助我们，我认为这只会提升整个

205
00:12:19,920 --> 00:12:22,560
industry to follow the updates on the new apple
行业来关注新苹果硅芯片的更新，

206
00:12:22,560 --> 00:12:27,040
silicon chips as they relate to us developers as well as seeing me conduct
因为它们与我们的开发人员有关，并看到我进行

207
00:12:27,040 --> 00:12:28,880
these tests that i've been discussing here
我一直在讨论的这些测试在这里

208
00:12:28,880 --> 00:12:32,480
consider subscribing to my channel as well the link is down below
考虑订阅我的频道，链接在下面

209
00:12:32,480 --> 00:12:36,000
i'm gonna wrap it up there thanks to fireship for hosting me to share this


210
00:12:36,000 --> 00:12:44,880
amazing new world that we're about to enter as developers
