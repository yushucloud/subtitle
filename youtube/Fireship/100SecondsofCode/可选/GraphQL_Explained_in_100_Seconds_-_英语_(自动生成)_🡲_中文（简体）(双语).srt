1
00:00:00,640 --> 00:00:05,759
graphql a query language for reading and mutating data in apis
graphql 一种查询语言，用于作为后端开发人员在 apis 中读取和修改数据

2
00:00:05,759 --> 00:00:09,120
as a back-end developer graphql provides a type system
graphql 提供了一个类型系统

3
00:00:09,120 --> 00:00:12,400
where you can describe a schema for your data in turn
，您可以在其中描述数据的模式，

4
00:00:12,400 --> 00:00:16,080
this gives front-end consumers of the api the power to explore
这使api 的前端消费者能够探索

5
00:00:16,080 --> 00:00:19,199
and request the exact data they need traditionally
和请求确切的数据 他们需要的数据传统上，

6
00:00:19,199 --> 00:00:23,199
web developers have consumed apis using rest where data entities
Web 开发人员使用 api 使用休息方式，其中数据实体

7
00:00:23,199 --> 00:00:26,720
live on a bunch of urls on a server when a request is received
存在于服务器上的一堆 url 上，当收到请求时

8
00:00:26,720 --> 00:00:30,000
the api responds with the full data payload of that entity
，api 会使用该实体的完整数据有效负载进行响应，

9
00:00:30,000 --> 00:00:33,440
that sounds simple enough but there are two potential drawbacks here
这听起来很简单，但这里有两个潜在的缺点

10
00:00:33,440 --> 00:00:36,480
we may need multiple entities at one time in which case
我们可能一次需要多个实体，在这种情况下，

11
00:00:36,480 --> 00:00:39,760
each request is under fetching the actual data we want
每个请求都在获取我们想要的实际数据，而

12
00:00:39,760 --> 00:00:43,760
in other cases we may only want a small subset of a data entity
在其他情况下，我们可能只需要数据实体的一小部分，

13
00:00:43,760 --> 00:00:48,000
in which case we need to over fetch from the api and that of course is bad for
在这种情况下，我们需要从 api 中过度获取，当然 对环境不好

14
00:00:48,000 --> 00:00:51,760
the environment how dare you instead of multiple urls a
你怎么敢而不是多个 url 一个

15
00:00:51,760 --> 00:00:55,520
graphql api has a single entry point data is queried
graphql api有一个入口点

16
00:00:55,520 --> 00:00:58,399
or fetched by describing it with a syntax that
通过使用反映其 retu 的语法来描述它来查询或获取数据

17
00:00:58,399 --> 00:01:02,160
mirrors its return shape in json the front-end developer describes the
rn shape injson 前端开发人员描述

18
00:01:02,160 --> 00:01:04,320
data they want while the back-end developer
他们想要的数据，而后端开发人员

19
00:01:04,320 --> 00:01:08,479
writes code to resolve the request and it all happens in a syntax that can work
编写代码来解决请求，这一切都发生在可以

20
00:01:08,479 --> 00:01:11,840
with any programming language we can start defining a schema with our
与任何编程语言一起使用的语法中，我们可以开始使用我们

21
00:01:11,840 --> 00:01:14,320
own custom objects using the type keyword
自己的自定义定义模式 使用 type关键字

22
00:01:14,320 --> 00:01:17,520
a type can have multiple fields like a unique id
的对象 一个类型可以有多个字段，例如一个唯一的 id

23
00:01:17,520 --> 00:01:21,119
and we'll make that required with a bang let's also give it integer and string
，我们将用一个 bang 使其成为必需让我们也给它整数和字符串

24
00:01:21,119 --> 00:01:23,680
values then create a relationship with another
值，然后创建与另一个

25
00:01:23,680 --> 00:01:27,840
type a creator can have many videos which we can represent by wrapping the
类型的关系 创建者可以拥有许多我们可以代表的视频 通过将

26
00:01:27,840 --> 00:01:32,640
type in brackets on the flip side a video belongs to a creator now every
类型包装在另一侧的括号中，视频属于创建者现在每个

27
00:01:32,640 --> 00:01:35,920
graphql api has a query type which is the main entry
graphql api都有一个查询类型，它是

28
00:01:35,920 --> 00:01:40,159
point for a consumer of the api we can query a list of videos or an
api 消费者的主要入口点，我们可以根据他们查询视频列表或

29
00:01:40,159 --> 00:01:43,840
individual user based on their id that's how a consumer reads data but
单个用户 id这就是消费者读取数据的方式，但

30
00:01:43,840 --> 00:01:48,000
they may also want to mutate data in which case we implement a mutation
他们可能还想改变数据，在这种情况下，我们实现了一个突变

31
00:01:48,000 --> 00:01:51,360
type that defines how data can be modified on the api
类型，它定义了如何在

32
00:01:51,360 --> 00:01:55,280
from there we can define code to resolve this data in any programming language
api 上修改数据，我们可以定义要解析的代码

33
00:01:55,280 --> 00:01:59,360
once deployed any developer consuming this api will be able to explore it with
一旦部署了任何编程语言中的此数据，任何使用此 API 的开发人员都将能够在

34
00:01:59,360 --> 00:02:02,560
a complete understanding of all possible queries and data
完全了解所有可能的查询和数据

35
00:02:02,560 --> 00:02:06,240
entities which means the tooling can autocomplete your query as you type it
实体的情况下探索它，这意味着该工具可以在您在编辑器中输入查询时自动完成您的查询

36
00:02:06,240 --> 00:02:09,679
out in your editor this has been graphql in 100 seconds if
graphql 在 100 秒内如果

37
00:02:09,679 --> 00:02:12,879
you want to see more short videos like this make sure to like and subscribe and
你想看更多这样的短视频，请确保喜欢并订阅并

38
00:02:12,879 --> 00:02:15,760
turn on notifications because there is a lot more on the way
打开通知，因为还有更多的内容

39
00:02:15,760 --> 00:02:23,840
thanks for watching and i will see you in the next one
感谢观看，我会在下一个看到你