1
00:00:00,240 --> 00:00:02,720
the central processing unit or cpu is


2
00:00:02,720 --> 00:00:04,000
like the engine in your car


3
00:00:04,000 --> 00:00:05,839
or the brain in your skull and is like a


4
00:00:05,839 --> 00:00:07,200
really fancy calculator


5
00:00:07,200 --> 00:00:09,040
used to run the applications on your


6
00:00:09,040 --> 00:00:10,719
computer when you write software in a


7
00:00:10,719 --> 00:00:12,559
language like javascript or python


8
00:00:12,559 --> 00:00:13,920
you're actually writing a set of


9
00:00:13,920 --> 00:00:15,920
instructions that will be executed as


10
00:00:15,920 --> 00:00:17,600
machine code by a cpu


11
00:00:17,600 --> 00:00:19,520
which itself is a carefully crafted


12
00:00:19,520 --> 00:00:21,760
piece of metal and silicon that contains


13
00:00:21,760 --> 00:00:23,439
billions of tiny transistors


14
00:00:23,439 --> 00:00:25,760
or on off switches that represent ones


15
00:00:25,760 --> 00:00:26,480
and zeros


16
00:00:26,480 --> 00:00:28,720
to perform mathematical calculations a


17
00:00:28,720 --> 00:00:30,960
cpu will combine multiple transistors


18
00:00:30,960 --> 00:00:32,800
together to form logic gates


19
00:00:32,800 --> 00:00:35,120
for example and will take two binary


20
00:00:35,120 --> 00:00:37,200
inputs and validate that both are true


21
00:00:37,200 --> 00:00:39,280
to produce a true output it only takes a


22
00:00:39,280 --> 00:00:41,360
few basic logic gates to solve highly


23
00:00:41,360 --> 00:00:43,280
complex computational problems


24
00:00:43,280 --> 00:00:44,800
modern chips contain billions of


25
00:00:44,800 --> 00:00:46,719
transistors and they can be flipped on


26
00:00:46,719 --> 00:00:48,640
and off billions of times per second


27
00:00:48,640 --> 00:00:50,640
the state of the cpu is synchronized by


28
00:00:50,640 --> 00:00:52,399
an oscillator known as the clock


29
00:00:52,399 --> 00:00:53,120
generator


30
00:00:53,120 --> 00:00:54,800
in general the more times the clock can


31
00:00:54,800 --> 00:00:57,120
pulse per second the faster the cpu can


32
00:00:57,120 --> 00:00:58,879
compute and is normally measured in


33
00:00:58,879 --> 00:00:59,680
gigahertz


34
00:00:59,680 --> 00:01:01,440
gamers will sometimes overclock their


35
00:01:01,440 --> 00:01:03,280
cpus to gain more performance


36
00:01:03,280 --> 00:01:05,280
at the cost of higher temperatures and a


37
00:01:05,280 --> 00:01:07,200
lower life expectancy now in order to


38
00:01:07,200 --> 00:01:09,200
run applications it interacts with the


39
00:01:09,200 --> 00:01:10,560
system memory or ram


40
00:01:10,560 --> 00:01:12,479
in a series of four steps known as the


41
00:01:12,479 --> 00:01:14,240
machine or instruction cycle


42
00:01:14,240 --> 00:01:16,479
step one is the fetch phase think of a


43
00:01:16,479 --> 00:01:18,080
software program as a set of


44
00:01:18,080 --> 00:01:20,320
instructions stored in the ram the cpu


45
00:01:20,320 --> 00:01:22,479
has registers to temporarily store the


46
00:01:22,479 --> 00:01:24,159
address and memory that it wants to


47
00:01:24,159 --> 00:01:26,080
interact with the program counter starts


48
00:01:26,080 --> 00:01:26,720
at 0


49
00:01:26,720 --> 00:01:28,640
and copies that address to the memory


50
00:01:28,640 --> 00:01:30,560
address register then the control unit


51
00:01:30,560 --> 00:01:32,720
sends out a signal to copy the data from


52
00:01:32,720 --> 00:01:33,439
that address


53
00:01:33,439 --> 00:01:35,280
to the instruction register at which


54
00:01:35,280 --> 00:01:37,200
point it needs to figure out how to use


55
00:01:37,200 --> 00:01:38,079
this instruction


56
00:01:38,079 --> 00:01:40,000
in the decode phase the control unit


57
00:01:40,000 --> 00:01:41,439
parses the actual bits in the


58
00:01:41,439 --> 00:01:42,159
instruction


59
00:01:42,159 --> 00:01:44,079
most importantly the opt code contains


60
00:01:44,079 --> 00:01:46,479
the instruction like add or subtract and


61
00:01:46,479 --> 00:01:48,720
the operand is the address in memory to


62
00:01:48,720 --> 00:01:50,320
perform that operation on


63
00:01:50,320 --> 00:01:52,079
the final execute stage takes the


64
00:01:52,079 --> 00:01:54,240
decoded information and passes it as


65
00:01:54,240 --> 00:01:56,159
electrical signals to the relevant parts


66
00:01:56,159 --> 00:01:57,040
of the cpu


67
00:01:57,040 --> 00:01:59,439
the arithmetic logic unit or alu can


68
00:01:59,439 --> 00:02:01,280
perform math on the data and then store


69
00:02:01,280 --> 00:02:03,119
the results in ram to change the state


70
00:02:03,119 --> 00:02:04,960
of the program the cycle is repeated


71
00:02:04,960 --> 00:02:06,320
billions of times per second


72
00:02:06,320 --> 00:02:08,399
and modern chips utilize multiple cpu


73
00:02:08,399 --> 00:02:10,319
cores to run multiple computations in


74
00:02:10,319 --> 00:02:11,039
parallel


75
00:02:11,039 --> 00:02:12,959
that's how a cpu works under the hood


76
00:02:12,959 --> 00:02:14,319
but there's a lot more you should know


77
00:02:14,319 --> 00:02:16,160
about processor architectures if you're


78
00:02:16,160 --> 00:02:17,760
a developer and that's why i've invited


79
00:02:17,760 --> 00:02:19,440
alex from the most underrated tech


80
00:02:19,440 --> 00:02:20,480
channel on youtube


81
00:02:20,480 --> 00:02:21,680
to break down some more advanced


82
00:02:21,680 --> 00:02:23,760
concepts like apple silicon and how to


83
00:02:23,760 --> 00:02:25,520
run performance benchmarking on your own


84
00:02:25,520 --> 00:02:26,000
machine


85
00:02:26,000 --> 00:02:27,680
hi everybody my name is alex and i'm


86
00:02:27,680 --> 00:02:30,080
here to take you beyond 100 seconds in


87
00:02:30,080 --> 00:02:30,959
your quest


88
00:02:30,959 --> 00:02:32,720
to learn about how processor


89
00:02:32,720 --> 00:02:34,640
architectures differ and also how those


90
00:02:34,640 --> 00:02:36,640
differences affect our productivity


91
00:02:36,640 --> 00:02:38,640
as developers i'll show you what the


92
00:02:38,640 --> 00:02:39,680
apple silicon


93
00:02:39,680 --> 00:02:42,160
chip and a refrigerator have in common


94
00:02:42,160 --> 00:02:43,760
and then i'll share some of my own


95
00:02:43,760 --> 00:02:46,239
experiences with using developer tools


96
00:02:46,239 --> 00:02:48,080
and build execution on the first


97
00:02:48,080 --> 00:02:50,319
generation apple silicon chip


98
00:02:50,319 --> 00:02:53,280
called the m1 ship as compared to the


99
00:02:53,280 --> 00:02:54,400
intel chip


100
00:02:54,400 --> 00:02:55,920
first and foremost i just want to say


101
00:02:55,920 --> 00:02:57,599
that my personal productivity as a


102
00:02:57,599 --> 00:02:59,840
developer depends less on processors


103
00:02:59,840 --> 00:03:01,040
inside my computer


104
00:03:01,040 --> 00:03:03,440
and more on how much coffee i had and


105
00:03:03,440 --> 00:03:04,959
whether i'm trying to work after a big


106
00:03:04,959 --> 00:03:06,560
meal


107
00:03:06,560 --> 00:03:08,800
but aside from human factors let's dig


108
00:03:08,800 --> 00:03:09,680
deeper into


109
00:03:09,680 --> 00:03:12,239
why the new apple silicon machines have


110
00:03:12,239 --> 00:03:13,760
been really kicking up a storm and


111
00:03:13,760 --> 00:03:15,200
changing the industry


112
00:03:15,200 --> 00:03:17,040
software development included and


113
00:03:17,040 --> 00:03:19,760
spoiler alert the m1 machines have been


114
00:03:19,760 --> 00:03:21,360
beating the intel machines in pretty


115
00:03:21,360 --> 00:03:23,760
much every build test i've thrown at it


116
00:03:23,760 --> 00:03:26,560
except a couple but it's not all roses


117
00:03:26,560 --> 00:03:28,720
so let's talk about some downsides later


118
00:03:28,720 --> 00:03:29,120
too


119
00:03:29,120 --> 00:03:31,360
so why is it so darn fast the first


120
00:03:31,360 --> 00:03:32,480
point i want to discuss


121
00:03:32,480 --> 00:03:34,480
is the physicality differences of the


122
00:03:34,480 --> 00:03:36,239
new apple silicon way


123
00:03:36,239 --> 00:03:39,120
versus the old intel and amd way this is


124
00:03:39,120 --> 00:03:41,440
what apple silicon and your refrigerator


125
00:03:41,440 --> 00:03:42,480
at home


126
00:03:42,480 --> 00:03:44,400
have in common all right imagine for a


127
00:03:44,400 --> 00:03:45,840
minute that you want to make a turkey


128
00:03:45,840 --> 00:03:47,120
with cheese sandwich


129
00:03:47,120 --> 00:03:49,040
you go over to the refrigerator and in


130
00:03:49,040 --> 00:03:50,319
one place


131
00:03:50,319 --> 00:03:52,720
you have the turkey breast the cheese


132
00:03:52,720 --> 00:03:54,319
the mayonnaise the mustard


133
00:03:54,319 --> 00:03:56,159
all those ingredients are right there in


134
00:03:56,159 --> 00:03:57,519
one place and you don't have to run


135
00:03:57,519 --> 00:03:59,200
around the house to gather them you


136
00:03:59,200 --> 00:04:01,120
don't have to drive to lots of stores to


137
00:04:01,120 --> 00:04:01,920
pick them up


138
00:04:01,920 --> 00:04:03,840
and this saves you lots of time and


139
00:04:03,840 --> 00:04:05,840
energy this kind of efficiency can be


140
00:04:05,840 --> 00:04:07,840
found in the new apple silicon


141
00:04:07,840 --> 00:04:10,319
chips because they aren't just a new


142
00:04:10,319 --> 00:04:11,200
processor


143
00:04:11,200 --> 00:04:13,120
apple silicon is a collection of many


144
00:04:13,120 --> 00:04:14,799
chips that are housed inside


145
00:04:14,799 --> 00:04:16,880
one silicon container and this type of


146
00:04:16,880 --> 00:04:19,759
system is known as a system on chip


147
00:04:19,759 --> 00:04:22,400
or sock and it's essentially an entire


148
00:04:22,400 --> 00:04:23,120
computer


149
00:04:23,120 --> 00:04:26,479
on one chip the main cpu the gpu


150
00:04:26,479 --> 00:04:29,199
the i o controller the ml engine they're


151
00:04:29,199 --> 00:04:30,720
all co-located


152
00:04:30,720 --> 00:04:32,800
so when the task is to make an


153
00:04:32,800 --> 00:04:34,800
electronic sandwich so to speak


154
00:04:34,800 --> 00:04:36,639
or in other words to do some work that


155
00:04:36,639 --> 00:04:38,479
involves all these different components


156
00:04:38,479 --> 00:04:40,560
a system on chip is going to be a lot


157
00:04:40,560 --> 00:04:41,840
more efficient


158
00:04:41,840 --> 00:04:44,320
in terms of energy usage using only a


159
00:04:44,320 --> 00:04:45,520
tiny bit of power


160
00:04:45,520 --> 00:04:46,960
and at the same time it's going to be


161
00:04:46,960 --> 00:04:48,960
faster than say a typical machine that


162
00:04:48,960 --> 00:04:50,320
has all the components


163
00:04:50,320 --> 00:04:53,040
separate intel based machines have a cpu


164
00:04:53,040 --> 00:04:54,000
that's a single


165
00:04:54,000 --> 00:04:56,400
chip and memory is located somewhere


166
00:04:56,400 --> 00:04:57,759
else on the motherboard


167
00:04:57,759 --> 00:05:00,639
the i o is somewhere else the individual


168
00:05:00,639 --> 00:05:02,400
components might be even more powerful


169
00:05:02,400 --> 00:05:04,160
than the ones available at the moment on


170
00:05:04,160 --> 00:05:06,720
the latest apple silicon based machines


171
00:05:06,720 --> 00:05:09,440
but that comes at a cost since these


172
00:05:09,440 --> 00:05:10,800
powerful components are like


173
00:05:10,800 --> 00:05:12,560
supermarkets that carry different


174
00:05:12,560 --> 00:05:13,919
sandwich ingredients


175
00:05:13,919 --> 00:05:16,400
as a result when you want a sandwich on


176
00:05:16,400 --> 00:05:17,680
an intel machine


177
00:05:17,680 --> 00:05:19,600
you'll have to drive all over town


178
00:05:19,600 --> 00:05:22,080
because one store will have the turkey


179
00:05:22,080 --> 00:05:24,639
another store will have the cheese yet


180
00:05:24,639 --> 00:05:26,720
another store will have the mayonnaise


181
00:05:26,720 --> 00:05:28,720
each store might be really good at their


182
00:05:28,720 --> 00:05:30,320
own process and have the best


183
00:05:30,320 --> 00:05:31,120
ingredients


184
00:05:31,120 --> 00:05:33,280
but each store also takes a lot of power


185
00:05:33,280 --> 00:05:35,440
to run losing out on the efficiency


186
00:05:35,440 --> 00:05:37,280
and since all you really want is just to


187
00:05:37,280 --> 00:05:38,880
make a simple sandwich


188
00:05:38,880 --> 00:05:40,960
you're wasting a ton of time and energy


189
00:05:40,960 --> 00:05:42,400
picking up the ingredients from


190
00:05:42,400 --> 00:05:44,400
all the different stores of course some


191
00:05:44,400 --> 00:05:45,919
might say the drawback


192
00:05:45,919 --> 00:05:48,320
with the system on chip design is that


193
00:05:48,320 --> 00:05:49,759
at least for now with the current


194
00:05:49,759 --> 00:05:51,440
selection of apple max you won't be able


195
00:05:51,440 --> 00:05:52,800
to upgrade or change


196
00:05:52,800 --> 00:05:55,120
any of the components you get what's on


197
00:05:55,120 --> 00:05:56,400
the menu and that's it


198
00:05:56,400 --> 00:05:58,160
but that's not news to most people that


199
00:05:58,160 --> 00:06:00,080
are familiar with the apple ecosystem


200
00:06:00,080 --> 00:06:01,600
once you accept that idea you might even


201
00:06:01,600 --> 00:06:03,120
see the benefits of having a more


202
00:06:03,120 --> 00:06:04,240
efficient design


203
00:06:04,240 --> 00:06:06,479
where all the components are on one chip


204
00:06:06,479 --> 00:06:08,319
and they outweigh the cons


205
00:06:08,319 --> 00:06:09,840
and still provide better performance


206
00:06:09,840 --> 00:06:11,600
than the alternative all right


207
00:06:11,600 --> 00:06:13,520
that's enough talk about food so how


208
00:06:13,520 --> 00:06:14,800
does this all affect


209
00:06:14,800 --> 00:06:17,280
real world development workflows so i've


210
00:06:17,280 --> 00:06:19,039
been doing a bunch of developer focused


211
00:06:19,039 --> 00:06:20,800
tests on the latest apple silicon


212
00:06:20,800 --> 00:06:22,400
machines over on my channel


213
00:06:22,400 --> 00:06:24,400
as well as comparing them to other


214
00:06:24,400 --> 00:06:26,560
machines like the intel max and pc


215
00:06:26,560 --> 00:06:27,680
machines too


216
00:06:27,680 --> 00:06:29,280
and in general the new design has been


217
00:06:29,280 --> 00:06:31,120
showing really great promise for my own


218
00:06:31,120 --> 00:06:32,800
workflows as a developer


219
00:06:32,800 --> 00:06:35,120
coffee and sandwiches excluded now there


220
00:06:35,120 --> 00:06:37,120
are lots of technology stacks that


221
00:06:37,120 --> 00:06:38,560
developers use of course


222
00:06:38,560 --> 00:06:41,039
and i'm trying builds in a few of them


223
00:06:41,039 --> 00:06:42,560
but now let me share some of the results


224
00:06:42,560 --> 00:06:44,880
i've seen with node and javascript tests


225
00:06:44,880 --> 00:06:46,560
and after that i'll also discuss the


226
00:06:46,560 --> 00:06:48,720
tech stacks that have the biggest gains


227
00:06:48,720 --> 00:06:49,680
on the new machines


228
00:06:49,680 --> 00:06:50,960
and also the stacks that have the


229
00:06:50,960 --> 00:06:52,800
biggest losses right now at the moment i


230
00:06:52,800 --> 00:06:54,560
started off trying out some existing


231
00:06:54,560 --> 00:06:57,120
javascript tests that are in the browser


232
00:06:57,120 --> 00:06:59,199
and then in node the browser test


233
00:06:59,199 --> 00:07:01,120
consisted of running speedometer


234
00:07:01,120 --> 00:07:02,880
which is a browser benchmark that


235
00:07:02,880 --> 00:07:04,720
measures the responsiveness of web


236
00:07:04,720 --> 00:07:05,680
applications


237
00:07:05,680 --> 00:07:08,160
it uses demo web apps to simulate their


238
00:07:08,160 --> 00:07:09,440
actions such as


239
00:07:09,440 --> 00:07:11,759
adding to-do items you visit the app in


240
00:07:11,759 --> 00:07:13,120
a browser of choice


241
00:07:13,120 --> 00:07:15,039
i tried chrome and safari for this and


242
00:07:15,039 --> 00:07:17,039
you execute the automated test that runs


243
00:07:17,039 --> 00:07:18,880
through a collection of applications


244
00:07:18,880 --> 00:07:20,560
built with some of the more popular


245
00:07:20,560 --> 00:07:23,919
ui frameworks like angular react amber


246
00:07:23,919 --> 00:07:26,319
even vanilla js and jquery and a whole


247
00:07:26,319 --> 00:07:27,039
bunch more


248
00:07:27,039 --> 00:07:29,039
and then this test reports the results


249
00:07:29,039 --> 00:07:30,720
as a single number when it's done


250
00:07:30,720 --> 00:07:32,479
this number represents the runs per


251
00:07:32,479 --> 00:07:34,400
minute and the higher the better when it


252
00:07:34,400 --> 00:07:35,840
was finished i found that it had


253
00:07:35,840 --> 00:07:37,120
significantly more


254
00:07:37,120 --> 00:07:39,919
iterations on the m1 safari had the best


255
00:07:39,919 --> 00:07:42,080
results even going off the scale


256
00:07:42,080 --> 00:07:44,240
and chrome did pretty well too i also


257
00:07:44,240 --> 00:07:46,639
ran some javascript benchmarks in a node


258
00:07:46,639 --> 00:07:47,599
environment


259
00:07:47,599 --> 00:07:49,840
and found a pretty cpu intensive


260
00:07:49,840 --> 00:07:51,360
algorithm called


261
00:07:51,360 --> 00:07:53,680
fancook redux that's implemented in


262
00:07:53,680 --> 00:07:54,479
javascript


263
00:07:54,479 --> 00:07:57,199
and created for benchmarks game a


264
00:07:57,199 --> 00:07:58,479
website that collects


265
00:07:58,479 --> 00:07:59,919
algorithms and tests in different


266
00:07:59,919 --> 00:08:02,080
languages and while my 16-inch


267
00:08:02,080 --> 00:08:04,639
macbook pro with the intel core i9


268
00:08:04,639 --> 00:08:05,440
processor


269
00:08:05,440 --> 00:08:07,759
did beat the macbook air with the m1


270
00:08:07,759 --> 00:08:09,759
chip it really didn't do so by a lot


271
00:08:09,759 --> 00:08:11,039
and when you consider the price


272
00:08:11,039 --> 00:08:12,960
differences between the machines


273
00:08:12,960 --> 00:08:14,800
and the fact that the m1 stayed cool


274
00:08:14,800 --> 00:08:16,479
throughout the test and


275
00:08:16,479 --> 00:08:18,720
that the battery hardly even took a hit


276
00:08:18,720 --> 00:08:19,759
on the m1


277
00:08:19,759 --> 00:08:21,919
you might be thinking whether the extra


278
00:08:21,919 --> 00:08:23,840
few seconds saved while running this


279
00:08:23,840 --> 00:08:24,479
benchmark


280
00:08:24,479 --> 00:08:26,479
on the intel i9 is really worth the


281
00:08:26,479 --> 00:08:28,479
money so running benchmarks is often


282
00:08:28,479 --> 00:08:29,280
very telling


283
00:08:29,280 --> 00:08:31,280
but it doesn't necessarily line up with


284
00:08:31,280 --> 00:08:32,719
real-world scenarios


285
00:08:32,719 --> 00:08:34,640
so that's why i also like to conduct my


286
00:08:34,640 --> 00:08:37,120
own tests whether using my own projects


287
00:08:37,120 --> 00:08:38,959
or other open source projects that are


288
00:08:38,959 --> 00:08:40,640
out there and that commenters


289
00:08:40,640 --> 00:08:42,560
sent to me and here's what i found i ran


290
00:08:42,560 --> 00:08:43,760
a build of the official


291
00:08:43,760 --> 00:08:46,080
nativescript plugins repository which is


292
00:08:46,080 --> 00:08:47,279
a project based on


293
00:08:47,279 --> 00:08:49,279
nx workspaces if you're not familiar


294
00:08:49,279 --> 00:08:51,040
with nx workspaces it allows you to


295
00:08:51,040 --> 00:08:51,519
scale


296
00:08:51,519 --> 00:08:54,080
large javascript and other tech stack


297
00:08:54,080 --> 00:08:54,720
projects


298
00:08:54,720 --> 00:08:56,959
and you can see the nx quickstart right


299
00:08:56,959 --> 00:08:57,920
here on this channel


300
00:08:57,920 --> 00:09:00,080
in my test the build that took about


301
00:09:00,080 --> 00:09:01,839
three minutes on each machine


302
00:09:01,839 --> 00:09:04,160
only differed in build time by tens of


303
00:09:04,160 --> 00:09:06,800
seconds with the m1 macbook air beating


304
00:09:06,800 --> 00:09:07,200
out


305
00:09:07,200 --> 00:09:09,440
the intel macbook pro two out of three


306
00:09:09,440 --> 00:09:10,320
times so


307
00:09:10,320 --> 00:09:12,560
let's talk about what dev stacks benefit


308
00:09:12,560 --> 00:09:14,480
the most from the new apple silicon


309
00:09:14,480 --> 00:09:14,959
chips


310
00:09:14,959 --> 00:09:16,959
at this time for javascript developers


311
00:09:16,959 --> 00:09:18,880
the benefits are already visible


312
00:09:18,880 --> 00:09:20,800
however if you're building mobile apps


313
00:09:20,800 --> 00:09:22,880
for ios for compiling c


314
00:09:22,880 --> 00:09:24,720
plus plus code then this is where you'll


315
00:09:24,720 --> 00:09:27,279
see a 40 to 50 percent improvement


316
00:09:27,279 --> 00:09:30,320
in build times i ran a few xcode builds


317
00:09:30,320 --> 00:09:31,440
and swift builds


318
00:09:31,440 --> 00:09:33,519
and i did some c plus plus algorithms


319
00:09:33,519 --> 00:09:34,959
and built opencv


320
00:09:34,959 --> 00:09:37,920
and webkit in all those tests the m1


321
00:09:37,920 --> 00:09:38,959
came out on top


322
00:09:38,959 --> 00:09:41,279
so what devstacks benefit the least so


323
00:09:41,279 --> 00:09:43,200
far in my own testing any builds that


324
00:09:43,200 --> 00:09:44,399
have to do with running


325
00:09:44,399 --> 00:09:46,480
natively built software and building


326
00:09:46,480 --> 00:09:47,920
using native tooling


327
00:09:47,920 --> 00:09:51,040
has absolutely destroyed intel and speed


328
00:09:51,040 --> 00:09:52,480
and battery performance


329
00:09:52,480 --> 00:09:54,880
native being compiled for the apple


330
00:09:54,880 --> 00:09:56,080
silicon architecture


331
00:09:56,080 --> 00:09:58,240
even when running some software via


332
00:09:58,240 --> 00:09:59,440
apple's rosetta


333
00:09:59,440 --> 00:10:01,440
that's the translation layer that allows


334
00:10:01,440 --> 00:10:03,760
you to run intel and amd based


335
00:10:03,760 --> 00:10:06,959
x64 and x86 programs on the new apple


336
00:10:06,959 --> 00:10:07,600
hardware


337
00:10:07,600 --> 00:10:09,600
even some of those software packages ran


338
00:10:09,600 --> 00:10:11,040
better than on intel


339
00:10:11,040 --> 00:10:12,880
and that's just amazing but there are


340
00:10:12,880 --> 00:10:14,399
workflows that aren't


341
00:10:14,399 --> 00:10:16,720
ready yet in my opinion if you are an


342
00:10:16,720 --> 00:10:19,279
android developer android studio


343
00:10:19,279 --> 00:10:22,000
and official android emulators work on


344
00:10:22,000 --> 00:10:23,040
apple silicon


345
00:10:23,040 --> 00:10:25,360
but they're currently using rosetta for


346
00:10:25,360 --> 00:10:26,399
translations


347
00:10:26,399 --> 00:10:28,399
and while rosetta is generally pretty


348
00:10:28,399 --> 00:10:30,000
good at running x86


349
00:10:30,000 --> 00:10:32,399
targeted code on arm chips it's not


350
00:10:32,399 --> 00:10:34,560
enough for the cpu hungry android


351
00:10:34,560 --> 00:10:35,360
workflows


352
00:10:35,360 --> 00:10:37,519
and i found the results to be not very


353
00:10:37,519 --> 00:10:38,560
usable at the moment


354
00:10:38,560 --> 00:10:40,399
the latest version of dot net which is


355
00:10:40,399 --> 00:10:42,000
version 5 right now


356
00:10:42,000 --> 00:10:44,320
isn't fully supported to run on arm


357
00:10:44,320 --> 00:10:46,480
simple console applications ran just


358
00:10:46,480 --> 00:10:47,360
fine for me


359
00:10:47,360 --> 00:10:49,760
but testing any web workflows like


360
00:10:49,760 --> 00:10:51,279
asp.net core


361
00:10:51,279 --> 00:10:52,720
doesn't work at all yet now it's


362
00:10:52,720 --> 00:10:54,240
expected that by the end of this year


363
00:10:54,240 --> 00:10:55,839
dot net six will come out


364
00:10:55,839 --> 00:10:57,920
it's in alpha right now and we'll have


365
00:10:57,920 --> 00:10:59,279
full support for arm


366
00:10:59,279 --> 00:11:01,440
until then if you need to develop.net


367
00:11:01,440 --> 00:11:03,440
apps i suggest using a pc


368
00:11:03,440 --> 00:11:05,519
with windows oh and if you think you can


369
00:11:05,519 --> 00:11:07,279
use a virtual windows machine


370
00:11:07,279 --> 00:11:09,600
i've tested this as well parallels is


371
00:11:09,600 --> 00:11:11,680
the only vendor that currently supports


372
00:11:11,680 --> 00:11:12,480
the m1


373
00:11:12,480 --> 00:11:14,160
chip to create a virtual windows


374
00:11:14,160 --> 00:11:15,920
environment but the issue is that the


375
00:11:15,920 --> 00:11:18,160
windows guest operating system for arm


376
00:11:18,160 --> 00:11:20,160
is still quite immature and needs a lot


377
00:11:20,160 --> 00:11:21,279
of work also


378
00:11:21,279 --> 00:11:24,240
visual studio 2019 the latest visual


379
00:11:24,240 --> 00:11:26,160
studio offering from microsoft


380
00:11:26,160 --> 00:11:28,240
is unfortunately not compatible with arm


381
00:11:28,240 --> 00:11:30,240
at all and my test is not


382
00:11:30,240 --> 00:11:33,200
stable even using the built-in windows


383
00:11:33,200 --> 00:11:34,079
translation


384
00:11:34,079 --> 00:11:37,200
of x64 software to run on


385
00:11:37,200 --> 00:11:39,279
arm hardware for game developers that


386
00:11:39,279 --> 00:11:41,120
use unity i'm pleased to say that it


387
00:11:41,120 --> 00:11:42,079
works surprisingly


388
00:11:42,079 --> 00:11:44,000
well on apple silicon via rosetta


389
00:11:44,000 --> 00:11:45,440
however it's not as performant as


390
00:11:45,440 --> 00:11:47,200
running natively on x86


391
00:11:47,200 --> 00:11:49,120
but by the time you watch this video


392
00:11:49,120 --> 00:11:50,959
unity might have a version natively


393
00:11:50,959 --> 00:11:52,399
compatible with m1


394
00:11:52,399 --> 00:11:54,320
which i know they're working hard to get


395
00:11:54,320 --> 00:11:55,440
out as soon as possible


396
00:11:55,440 --> 00:11:57,519
overall apple silicon has really put a


397
00:11:57,519 --> 00:11:59,519
boost into many workflows


398
00:11:59,519 --> 00:12:01,440
for developers and other professions and


399
00:12:01,440 --> 00:12:02,880
eventually even gaming


400
00:12:02,880 --> 00:12:05,120
and with the m1 tests we're seeing the


401
00:12:05,120 --> 00:12:06,240
improvements with


402
00:12:06,240 --> 00:12:08,480
just their entry level machines the


403
00:12:08,480 --> 00:12:10,320
upcoming second and third generation


404
00:12:10,320 --> 00:12:12,240
apple silicon machines will be even more


405
00:12:12,240 --> 00:12:14,560
performant and i can't wait to see that


406
00:12:14,560 --> 00:12:16,320
i think it's really gonna help us as


407
00:12:16,320 --> 00:12:18,240
developers move to the next level and i


408
00:12:18,240 --> 00:12:19,920
think it's just gonna lift up the entire


409
00:12:19,920 --> 00:12:20,560
industry


410
00:12:20,560 --> 00:12:22,560
to follow the updates on the new apple


411
00:12:22,560 --> 00:12:24,959
silicon chips as they relate to us


412
00:12:24,959 --> 00:12:27,040
developers as well as seeing me conduct


413
00:12:27,040 --> 00:12:28,480
these tests that i've been discussing


414
00:12:28,480 --> 00:12:28,880
here


415
00:12:28,880 --> 00:12:30,639
consider subscribing to my channel as


416
00:12:30,639 --> 00:12:32,480
well the link is down below


417
00:12:32,480 --> 00:12:34,240
i'm gonna wrap it up there thanks to


418
00:12:34,240 --> 00:12:36,000
fireship for hosting me to share this


419
00:12:36,000 --> 00:12:36,959
amazing new world


420
00:12:36,959 --> 00:12:44,880
that we're about to enter as developers


