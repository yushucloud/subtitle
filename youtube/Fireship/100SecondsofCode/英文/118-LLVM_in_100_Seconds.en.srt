1
00:00:00,160 --> 00:00:03,040
llvm a toolkit used to build and


2
00:00:03,040 --> 00:00:04,799
optimize compilers building a


3
00:00:04,799 --> 00:00:06,319
programming language from scratch is


4
00:00:06,319 --> 00:00:08,000
hard you have humans who want to write


5
00:00:08,000 --> 00:00:09,920
code in a nice simple syntax than


6
00:00:09,920 --> 00:00:11,759
machines that need to run it on all


7
00:00:11,759 --> 00:00:14,559
sorts of architectures llvm standardizes


8
00:00:14,559 --> 00:00:16,720
the extremely complex process of turning


9
00:00:16,720 --> 00:00:18,560
source code into machine code it was


10
00:00:18,560 --> 00:00:21,119
created in 2003 by grad student chris


11
00:00:21,119 --> 00:00:23,039
lattner at the university of illinois


12
00:00:23,039 --> 00:00:24,960
and today it's the magic behind clang


13
00:00:24,960 --> 00:00:27,359
for c and c plus as well as languages


14
00:00:27,359 --> 00:00:30,080
like rust swift julia and many others


15
00:00:30,080 --> 00:00:31,920
most importantly it represents high


16
00:00:31,920 --> 00:00:34,160
level source code in a language agnostic


17
00:00:34,160 --> 00:00:36,320
code called intermediate representation


18
00:00:36,320 --> 00:00:38,399
or ir this means vastly different


19
00:00:38,399 --> 00:00:40,719
languages like cuda and ruby produce the


20
00:00:40,719 --> 00:00:42,960
same ir allowing them to share tools for


21
00:00:42,960 --> 00:00:45,039
analysis and optimization before they're


22
00:00:45,039 --> 00:00:46,960
converted to machine code for a specific


23
00:00:46,960 --> 00:00:48,800
chip architecture a compiler can be


24
00:00:48,800 --> 00:00:50,719
broken down into three parts the front


25
00:00:50,719 --> 00:00:52,480
end parses the source code text and


26
00:00:52,480 --> 00:00:54,719
converts it into ir the middle end


27
00:00:54,719 --> 00:00:57,039
analyzes and optimizes this generated


28
00:00:57,039 --> 00:00:59,039
code and finally the backend converts


29
00:00:59,039 --> 00:01:01,520
the ir into native machine code to build


30
00:01:01,520 --> 00:01:02,719
your own programming language from


31
00:01:02,719 --> 00:01:05,040
scratch right now install llvm then


32
00:01:05,040 --> 00:01:06,240
create a c


33
00:01:06,240 --> 00:01:07,760
file now envision the programming


34
00:01:07,760 --> 00:01:09,600
language syntax of your dreams to make


35
00:01:09,600 --> 00:01:11,200
that high level code work you'll first


36
00:01:11,200 --> 00:01:13,119
need to write a lexer to scan the raw


37
00:01:13,119 --> 00:01:14,720
source code and break it into a


38
00:01:14,720 --> 00:01:16,560
collection of tokens like literals


39
00:01:16,560 --> 00:01:19,040
identifiers keywords operators and so on


40
00:01:19,040 --> 00:01:20,720
next we'll need to define an abstract


41
00:01:20,720 --> 00:01:22,640
syntax tree to represent the actual


42
00:01:22,640 --> 00:01:24,240
structure of the code and how different


43
00:01:24,240 --> 00:01:25,840
tokens relate to each other which is


44
00:01:25,840 --> 00:01:27,600
accomplished by giving each node its own


45
00:01:27,600 --> 00:01:30,000
class third we need a parser to loop


46
00:01:30,000 --> 00:01:31,759
over each token and build out the


47
00:01:31,759 --> 00:01:33,680
abstract syntax tree if you made it this


48
00:01:33,680 --> 00:01:35,600
far congratulations because the hard


49
00:01:35,600 --> 00:01:37,280
part is over now we can import a bunch


50
00:01:37,280 --> 00:01:39,439
of llvm primitives to generate the


51
00:01:39,439 --> 00:01:41,520
intermediate representation each type in


52
00:01:41,520 --> 00:01:43,439
the abstract syntax tree is given a


53
00:01:43,439 --> 00:01:45,520
method called cogen which always returns


54
00:01:45,520 --> 00:01:48,560
an llbm value object used to represent a


55
00:01:48,560 --> 00:01:50,320
single assignment register which is a


56
00:01:50,320 --> 00:01:52,079
variable for the compiler that can only


57
00:01:52,079 --> 00:01:53,600
be assigned once what's interesting


58
00:01:53,600 --> 00:01:55,600
about these ir primitives is that unlike


59
00:01:55,600 --> 00:01:57,439
assembly they're independent of any


60
00:01:57,439 --> 00:01:59,280
particular machine architecture and that


61
00:01:59,280 --> 00:02:00,799
dramatically simplifies things for


62
00:02:00,799 --> 00:02:02,399
language developers who no longer need


63
00:02:02,399 --> 00:02:04,240
to match the output to a processor's


64
00:02:04,240 --> 00:02:05,840
instruction set now that the front end


65
00:02:05,840 --> 00:02:08,479
can generate ir the op tool is used to


66
00:02:08,479 --> 00:02:10,959
analyze and optimize the generated code


67
00:02:10,959 --> 00:02:13,120
it makes multiple passes over the ir and


68
00:02:13,120 --> 00:02:14,879
does things like dead code elimination


69
00:02:14,879 --> 00:02:17,040
and scalar replacement of aggregates and


70
00:02:17,040 --> 00:02:18,640
finally that brings us to the back end


71
00:02:18,640 --> 00:02:20,879
where we write a module that takes ir as


72
00:02:20,879 --> 00:02:23,120
an input that emits object code that can


73
00:02:23,120 --> 00:02:25,599
run on any architecture congratulations


74
00:02:25,599 --> 00:02:26,959
you just built your own custom


75
00:02:26,959 --> 00:02:29,280
programming language and compiler in 100


76
00:02:29,280 --> 00:02:30,560
seconds hit the like button and


77
00:02:30,560 --> 00:02:32,000
subscribe if you want to see more short


78
00:02:32,000 --> 00:02:33,920
videos like this thanks for watching and


79
00:02:33,920 --> 00:02:37,760
i will see you in the next one


