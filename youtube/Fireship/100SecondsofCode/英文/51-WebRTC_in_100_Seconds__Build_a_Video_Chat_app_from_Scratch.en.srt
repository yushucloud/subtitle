1
00:00:00,199 --> 00:00:03,360
webrtc exchange real-time audio video


2
00:00:03,360 --> 00:00:04,640
streams with your friends


3
00:00:04,640 --> 00:00:06,720
entirely in the browser i'm here live


4
00:00:06,720 --> 00:00:08,320
that's not i'm not a cat


5
00:00:08,320 --> 00:00:09,760
if you want to build your own video


6
00:00:09,760 --> 00:00:11,599
conferencing app to capitalize on the


7
00:00:11,599 --> 00:00:12,639
work from home boom


8
00:00:12,639 --> 00:00:14,960
then webrtc is the api you're looking


9
00:00:14,960 --> 00:00:17,199
for because it allows you to establish a


10
00:00:17,199 --> 00:00:18,960
peer-to-peer connection between two or


11
00:00:18,960 --> 00:00:19,840
more browsers


12
00:00:19,840 --> 00:00:21,600
where they can exchange audio video


13
00:00:21,600 --> 00:00:23,519
media directly without the need for a


14
00:00:23,519 --> 00:00:25,279
third-party server or native app


15
00:00:25,279 --> 00:00:27,359
it works like this the first pier will


16
00:00:27,359 --> 00:00:28,480
create an offer


17
00:00:28,480 --> 00:00:30,240
asking for another peer to connect to


18
00:00:30,240 --> 00:00:31,599
them this will result


19
00:00:31,599 --> 00:00:34,239
in an stp object or session description


20
00:00:34,239 --> 00:00:34,880
protocol


21
00:00:34,880 --> 00:00:36,719
which contains information describing


22
00:00:36,719 --> 00:00:38,000
the peer-to-peer connection


23
00:00:38,000 --> 00:00:40,320
like the video codec timing and so on


24
00:00:40,320 --> 00:00:42,399
the data will then be saved in a server


25
00:00:42,399 --> 00:00:44,079
where it can then be read by another


26
00:00:44,079 --> 00:00:45,920
peer to answer the call which is


27
00:00:45,920 --> 00:00:48,160
achieved by creating an stp answer


28
00:00:48,160 --> 00:00:50,000
and writing that to the server this


29
00:00:50,000 --> 00:00:51,199
process is known as


30
00:00:51,199 --> 00:00:53,039
signaling and it's handled by a third


31
00:00:53,039 --> 00:00:55,199
party server the signaling server allows


32
00:00:55,199 --> 00:00:57,199
the two parties to securely exchange


33
00:00:57,199 --> 00:00:58,160
connection data


34
00:00:58,160 --> 00:00:59,680
but never touches the media that's


35
00:00:59,680 --> 00:01:01,600
actually transmitted between the peers


36
00:01:01,600 --> 00:01:03,359
but here's where things get tricky most


37
00:01:03,359 --> 00:01:05,199
devices in the real world sit behind


38
00:01:05,199 --> 00:01:05,920
firewalls


39
00:01:05,920 --> 00:01:07,920
and ip addresses constantly change


40
00:01:07,920 --> 00:01:10,000
thanks to network address translation


41
00:01:10,000 --> 00:01:11,360
this makes peer-to-peer connection


42
00:01:11,360 --> 00:01:13,520
complicated from a networking standpoint


43
00:01:13,520 --> 00:01:15,600
but luckily there's a standard called


44
00:01:15,600 --> 00:01:17,840
interactive connectivity establishment


45
00:01:17,840 --> 00:01:20,000
or ice which helps clients coordinate


46
00:01:20,000 --> 00:01:22,400
the discovery of their public-facing ip


47
00:01:22,400 --> 00:01:23,200
addresses


48
00:01:23,200 --> 00:01:25,520
now both peers will generate a list of


49
00:01:25,520 --> 00:01:26,479
ice candidates


50
00:01:26,479 --> 00:01:28,640
which contain an ip address and port


51
00:01:28,640 --> 00:01:31,200
that pier 1 can use to connect to pier


52
00:01:31,200 --> 00:01:31,680
2.


53
00:01:31,680 --> 00:01:34,079
in the background webrtc will do this by


54
00:01:34,079 --> 00:01:36,320
making a series of requests to a stun


55
00:01:36,320 --> 00:01:36,880
server


56
00:01:36,880 --> 00:01:38,479
a stun server is not something you need


57
00:01:38,479 --> 00:01:40,079
to set up on your own because there are


58
00:01:40,079 --> 00:01:41,520
many free options out there


59
00:01:41,520 --> 00:01:43,840
from reliable sources like google each


60
00:01:43,840 --> 00:01:45,600
peer will save their ice candidates in


61
00:01:45,600 --> 00:01:47,200
the database where they can then be read


62
00:01:47,200 --> 00:01:48,399
by the other peer


63
00:01:48,399 --> 00:01:50,079
the algorithm will then automatically


64
00:01:50,079 --> 00:01:52,159
determine which candidate is best


65
00:01:52,159 --> 00:01:54,240
at which point real-time media can begin


66
00:01:54,240 --> 00:01:55,759
flowing between the two peers


67
00:01:55,759 --> 00:01:58,719
this has been webrtc in 100 seconds if


68
00:01:58,719 --> 00:02:00,079
you want to see more short videos like


69
00:02:00,079 --> 00:02:00,399
this


70
00:02:00,399 --> 00:02:02,079
make sure to hit the like button then


71
00:02:02,079 --> 00:02:03,600
stay tuned because now we're going to


72
00:02:03,600 --> 00:02:05,439
build our own video chat app from


73
00:02:05,439 --> 00:02:06,000
scratch


74
00:02:06,000 --> 00:02:07,680
that may sound pretty complicated but


75
00:02:07,680 --> 00:02:09,280
the webrtc api


76
00:02:09,280 --> 00:02:10,879
allows all this stuff to magically


77
00:02:10,879 --> 00:02:12,400
happen in the background over the next


78
00:02:12,400 --> 00:02:14,239
few minutes you'll build a peer-to-peer


79
00:02:14,239 --> 00:02:15,920
video calling app from scratch


80
00:02:15,920 --> 00:02:18,080
using nothing but vanilla javascript and


81
00:02:18,080 --> 00:02:20,080
firebase as the signalling server


82
00:02:20,080 --> 00:02:21,680
by the end of this tutorial you'll know


83
00:02:21,680 --> 00:02:23,760
how to implement real-time features that


84
00:02:23,760 --> 00:02:25,520
cater to the needs of the new work from


85
00:02:25,520 --> 00:02:27,040
home paradigm that we live in


86
00:02:27,040 --> 00:02:28,720
in addition to this video you can also


87
00:02:28,720 --> 00:02:30,560
reference the full article on fire ship


88
00:02:30,560 --> 00:02:31,040
io


89
00:02:31,040 --> 00:02:32,800
and the source code on github let's


90
00:02:32,800 --> 00:02:34,239
start by taking a look at the demo


91
00:02:34,239 --> 00:02:36,080
we have the local user's video feed on


92
00:02:36,080 --> 00:02:38,000
the left side and the remote video


93
00:02:38,000 --> 00:02:39,840
on the right side the local user will


94
00:02:39,840 --> 00:02:41,840
first grant permission for the app to


95
00:02:41,840 --> 00:02:42,959
access the webcam


96
00:02:42,959 --> 00:02:44,640
that user can then create a call which


97
00:02:44,640 --> 00:02:47,040
will write a document to firestore with


98
00:02:47,040 --> 00:02:48,480
the offer details


99
00:02:48,480 --> 00:02:50,400
at the same time we'll create a peer


100
00:02:50,400 --> 00:02:52,239
connection instance in the browser


101
00:02:52,239 --> 00:02:54,640
which handles the webrtc negotiation


102
00:02:54,640 --> 00:02:55,280
process


103
00:02:55,280 --> 00:02:57,280
the offer will have a unique id that can


104
00:02:57,280 --> 00:02:59,200
then be accessed by another user


105
00:02:59,200 --> 00:03:00,560
somewhere else in the world


106
00:03:00,560 --> 00:03:02,159
that user will then join the call with


107
00:03:02,159 --> 00:03:04,480
the unique id then establish their own


108
00:03:04,480 --> 00:03:05,440
peer connection


109
00:03:05,440 --> 00:03:07,680
and write the answer details to the same


110
00:03:07,680 --> 00:03:08,480
document


111
00:03:08,480 --> 00:03:10,159
then both peers will write their ice


112
00:03:10,159 --> 00:03:12,000
candidates to the database we have one


113
00:03:12,000 --> 00:03:13,920
sub-collection for offer candidates


114
00:03:13,920 --> 00:03:16,239
and another for answer candidates this


115
00:03:16,239 --> 00:03:18,080
data model will allow signaling to


116
00:03:18,080 --> 00:03:20,000
take place between the two peers the


117
00:03:20,000 --> 00:03:21,360
data itself looks like a bunch of


118
00:03:21,360 --> 00:03:23,599
nonsense but what it contains is an ip


119
00:03:23,599 --> 00:03:25,280
address port pair that allows the two


120
00:03:25,280 --> 00:03:27,120
peers to establish a connection


121
00:03:27,120 --> 00:03:28,959
now both users can listen to this data


122
00:03:28,959 --> 00:03:31,920
in real time then use the web rtc api in


123
00:03:31,920 --> 00:03:34,000
the browser to establish the connection


124
00:03:34,000 --> 00:03:36,000
giving us a one-to-one video chat


125
00:03:36,000 --> 00:03:38,080
feature and now we're ready to jump into


126
00:03:38,080 --> 00:03:39,680
our javascript code i started by


127
00:03:39,680 --> 00:03:41,599
creating a vanilla javascript project


128
00:03:41,599 --> 00:03:43,840
using a tool called veet which is a very


129
00:03:43,840 --> 00:03:45,280
simple build tool developed by the


130
00:03:45,280 --> 00:03:46,319
vue.js guy


131
00:03:46,319 --> 00:03:48,000
we can initialize a new project by


132
00:03:48,000 --> 00:03:49,360
running npm init


133
00:03:49,360 --> 00:03:52,720
vjs app from the command line basically


134
00:03:52,720 --> 00:03:54,400
it gives us a web project where we can


135
00:03:54,400 --> 00:03:56,080
install dependencies without having to


136
00:03:56,080 --> 00:03:57,519
worry about things like webpack


137
00:03:57,519 --> 00:03:59,280
after initializing the project we need


138
00:03:59,280 --> 00:04:00,640
to install firebase


139
00:04:00,640 --> 00:04:02,560
firebase contains the firestore database


140
00:04:02,560 --> 00:04:04,319
which we can use as our backend


141
00:04:04,319 --> 00:04:05,200
signaling server


142
00:04:05,200 --> 00:04:07,040
firebase is an exceptional choice for a


143
00:04:07,040 --> 00:04:08,799
signalling server because it's easy to


144
00:04:08,799 --> 00:04:10,560
listen to updates to the database in


145
00:04:10,560 --> 00:04:11,200
real time


146
00:04:11,200 --> 00:04:12,480
if we were working with a traditional


147
00:04:12,480 --> 00:04:14,239
database we'd likely have to implement


148
00:04:14,239 --> 00:04:16,000
something like websockets to make that


149
00:04:16,000 --> 00:04:18,239
possible and this video would be a crazy


150
00:04:18,239 --> 00:04:19,680
20 minutes long or something


151
00:04:19,680 --> 00:04:21,519
from the firebase console initialize


152
00:04:21,519 --> 00:04:23,360
firestore in test mode


153
00:04:23,360 --> 00:04:25,280
then create a web project from the


154
00:04:25,280 --> 00:04:27,280
settings panel and grab your project


155
00:04:27,280 --> 00:04:28,080
credentials


156
00:04:28,080 --> 00:04:30,240
we can then go into the main.js file


157
00:04:30,240 --> 00:04:31,360
import firebase


158
00:04:31,360 --> 00:04:33,360
and initialize the app with our firebase


159
00:04:33,360 --> 00:04:35,280
config now that we have firebase set up


160
00:04:35,280 --> 00:04:37,360
we're going to initialize three pieces


161
00:04:37,360 --> 00:04:39,360
of global state these are values you


162
00:04:39,360 --> 00:04:40,720
would likely want to share between


163
00:04:40,720 --> 00:04:42,880
multiple components if you're using a ui


164
00:04:42,880 --> 00:04:45,040
framework like react or angular


165
00:04:45,040 --> 00:04:47,040
the first and most important value is


166
00:04:47,040 --> 00:04:49,120
the rtc peer connection


167
00:04:49,120 --> 00:04:50,960
this object is where all the action


168
00:04:50,960 --> 00:04:52,639
happens it emits a bunch of different


169
00:04:52,639 --> 00:04:54,080
events that we can listen to


170
00:04:54,080 --> 00:04:56,320
to update the database and to add media


171
00:04:56,320 --> 00:04:58,000
streams to the connection itself


172
00:04:58,000 --> 00:04:59,680
one very important thing it does is


173
00:04:59,680 --> 00:05:01,360
generate the ice candidates


174
00:05:01,360 --> 00:05:03,120
but in order to do that it needs to know


175
00:05:03,120 --> 00:05:04,800
which stun servers to use


176
00:05:04,800 --> 00:05:06,080
there are many different options out


177
00:05:06,080 --> 00:05:07,600
there but we're just going to use the


178
00:05:07,600 --> 00:05:08,880
free ones from google


179
00:05:08,880 --> 00:05:10,560
from there we have values for local


180
00:05:10,560 --> 00:05:12,080
stream and remote stream


181
00:05:12,080 --> 00:05:13,840
which are the video streams from the


182
00:05:13,840 --> 00:05:15,520
webcams of each user


183
00:05:15,520 --> 00:05:16,800
now because we're working with vanilla


184
00:05:16,800 --> 00:05:19,520
js we need to use imperative dom apis


185
00:05:19,520 --> 00:05:22,080
we're using document git element by id


186
00:05:22,080 --> 00:05:23,600
to grab a bunch of elements from the


187
00:05:23,600 --> 00:05:24,560
html


188
00:05:24,560 --> 00:05:26,880
like video elements to show the actual


189
00:05:26,880 --> 00:05:27,759
video feeds


190
00:05:27,759 --> 00:05:28,960
along with buttons that provide


191
00:05:28,960 --> 00:05:30,800
different interaction in the ui the


192
00:05:30,800 --> 00:05:32,639
first thing the user will do is click a


193
00:05:32,639 --> 00:05:33,280
button


194
00:05:33,280 --> 00:05:35,520
to open up their webcam we'll go ahead


195
00:05:35,520 --> 00:05:37,280
and register an event handler for the


196
00:05:37,280 --> 00:05:39,440
click event on the webcam button


197
00:05:39,440 --> 00:05:40,880
obtaining a stream from the user's


198
00:05:40,880 --> 00:05:43,360
webcam is very easy we just await


199
00:05:43,360 --> 00:05:46,160
the navigator media devices get user


200
00:05:46,160 --> 00:05:47,199
media method


201
00:05:47,199 --> 00:05:49,600
and we'll set video and audio to true


202
00:05:49,600 --> 00:05:51,680
that'll bring up a dialog in the browser


203
00:05:51,680 --> 00:05:53,840
asking the user for permission to access


204
00:05:53,840 --> 00:05:55,520
the webcam when that's complete


205
00:05:55,520 --> 00:05:57,360
the promise will resolve to a media


206
00:05:57,360 --> 00:05:59,440
stream object once we have access to the


207
00:05:59,440 --> 00:06:00,080
webcam


208
00:06:00,080 --> 00:06:01,759
we can also go ahead and set up the


209
00:06:01,759 --> 00:06:03,199
remote stream here


210
00:06:03,199 --> 00:06:05,199
which itself will just be an empty media


211
00:06:05,199 --> 00:06:07,520
stream now from here we need to take our


212
00:06:07,520 --> 00:06:08,319
two streams


213
00:06:08,319 --> 00:06:09,840
and make them available on the peer


214
00:06:09,840 --> 00:06:11,680
connection and show them on


215
00:06:11,680 --> 00:06:13,680
video elements in the dom the local


216
00:06:13,680 --> 00:06:15,360
stream is already running here in the


217
00:06:15,360 --> 00:06:16,000
browser


218
00:06:16,000 --> 00:06:18,080
so we can get its tracks and then loop


219
00:06:18,080 --> 00:06:20,080
over them and for each track


220
00:06:20,080 --> 00:06:22,560
we'll call peer connection ad track with


221
00:06:22,560 --> 00:06:24,319
that track and the local stream


222
00:06:24,319 --> 00:06:26,319
now the remote stream is currently empty


223
00:06:26,319 --> 00:06:27,919
and it will be updated by the peer


224
00:06:27,919 --> 00:06:28,960
connection itself


225
00:06:28,960 --> 00:06:31,120
so what we can do is listen to the on


226
00:06:31,120 --> 00:06:33,039
track event on the pure connection


227
00:06:33,039 --> 00:06:35,120
then get the tracks from the stream loop


228
00:06:35,120 --> 00:06:37,440
over them and add them to the remote


229
00:06:37,440 --> 00:06:38,639
stream when they come in


230
00:06:38,639 --> 00:06:40,240
now the final step for managing our


231
00:06:40,240 --> 00:06:42,400
streams is to apply them to video


232
00:06:42,400 --> 00:06:44,080
elements in the dom we can do that by


233
00:06:44,080 --> 00:06:46,240
simply calling the video element source


234
00:06:46,240 --> 00:06:46,800
object


235
00:06:46,800 --> 00:06:49,360
and setting it equal to the stream at


236
00:06:49,360 --> 00:06:51,039
this point we have a way to manage a


237
00:06:51,039 --> 00:06:52,880
local and remote stream through the peer


238
00:06:52,880 --> 00:06:53,520
connection


239
00:06:53,520 --> 00:06:55,280
but in order to make that happen we need


240
00:06:55,280 --> 00:06:57,199
to do some signaling with firestore


241
00:06:57,199 --> 00:06:59,039
the user who starts a call is the one


242
00:06:59,039 --> 00:07:01,199
who makes an offer we have a call button


243
00:07:01,199 --> 00:07:02,000
in the dom to


244
00:07:02,000 --> 00:07:03,840
handle that functionality inside this


245
00:07:03,840 --> 00:07:05,120
async function here


246
00:07:05,120 --> 00:07:07,039
we have a call document which is used to


247
00:07:07,039 --> 00:07:09,039
manage the answer and offer from both


248
00:07:09,039 --> 00:07:10,000
users


249
00:07:10,000 --> 00:07:12,080
then we have offer candidates and answer


250
00:07:12,080 --> 00:07:14,000
candidates which are sub collections


251
00:07:14,000 --> 00:07:15,039
under that document


252
00:07:15,039 --> 00:07:17,039
that contain all the candidates for each


253
00:07:17,039 --> 00:07:18,400
of those users


254
00:07:18,400 --> 00:07:20,000
when we reference a document without an


255
00:07:20,000 --> 00:07:22,400
id firebase will automatically generate


256
00:07:22,400 --> 00:07:23,599
a random id for


257
00:07:23,599 --> 00:07:25,280
us so we'll go ahead and use that to


258
00:07:25,280 --> 00:07:27,360
populate an input in the ui


259
00:07:27,360 --> 00:07:28,800
which can then be used in another


260
00:07:28,800 --> 00:07:30,960
browser tab or by another user somewhere


261
00:07:30,960 --> 00:07:33,199
else in the world to answer the call


262
00:07:33,199 --> 00:07:35,039
now we're ready to create an offer and


263
00:07:35,039 --> 00:07:36,400
save it to the database


264
00:07:36,400 --> 00:07:39,080
the first thing we'll do is await the


265
00:07:39,080 --> 00:07:40,800
peerconnectioncreateoffer method


266
00:07:40,800 --> 00:07:42,479
which will return us with an offer


267
00:07:42,479 --> 00:07:44,240
description we'll then set it as the


268
00:07:44,240 --> 00:07:46,400
local description on the peer connection


269
00:07:46,400 --> 00:07:48,560
most importantly this object contains an


270
00:07:48,560 --> 00:07:49,680
sdp value


271
00:07:49,680 --> 00:07:51,520
which stands for session description


272
00:07:51,520 --> 00:07:53,520
protocol that's the value we want to


273
00:07:53,520 --> 00:07:55,280
save to the database so we'll go ahead


274
00:07:55,280 --> 00:07:56,879
and convert it to a plain


275
00:07:56,879 --> 00:07:58,960
javascript object then write it to the


276
00:07:58,960 --> 00:08:00,800
database by calling await


277
00:08:00,800 --> 00:08:03,440
call document set with that data now


278
00:08:03,440 --> 00:08:04,720
what's inside the sdp


279
00:08:04,720 --> 00:08:06,400
object isn't really important but it


280
00:08:06,400 --> 00:08:08,240
contains information about the video


281
00:08:08,240 --> 00:08:08,720
codec


282
00:08:08,720 --> 00:08:10,319
along with a bunch of other stuff to


283
00:08:10,319 --> 00:08:12,560
negotiate the connection now one really


284
00:08:12,560 --> 00:08:13,840
important thing to point out here


285
00:08:13,840 --> 00:08:15,599
is that when we called set local


286
00:08:15,599 --> 00:08:17,759
description it automatically started


287
00:08:17,759 --> 00:08:19,440
generating the ice candidates


288
00:08:19,440 --> 00:08:22,000
an ice candidate contains a potential ip


289
00:08:22,000 --> 00:08:23,520
address and port pair


290
00:08:23,520 --> 00:08:25,440
that can be used to establish the actual


291
00:08:25,440 --> 00:08:26,720
peer-to-peer connection


292
00:08:26,720 --> 00:08:28,080
we need to be listening to the ice


293
00:08:28,080 --> 00:08:29,599
candidates so it's important that we


294
00:08:29,599 --> 00:08:31,520
have a listener established before we


295
00:08:31,520 --> 00:08:32,479
make that call


296
00:08:32,479 --> 00:08:34,560
that listens to the on ice candidate


297
00:08:34,560 --> 00:08:36,479
event when the event is fired we'll make


298
00:08:36,479 --> 00:08:37,360
sure that a candidate


299
00:08:37,360 --> 00:08:40,159
exists then write the data as json to


300
00:08:40,159 --> 00:08:41,919
the offer candidates collection


301
00:08:41,919 --> 00:08:43,919
so at this point as the caller making


302
00:08:43,919 --> 00:08:46,160
the offer we are saving all of our data


303
00:08:46,160 --> 00:08:47,279
to the database


304
00:08:47,279 --> 00:08:49,360
but now we need to also be listening for


305
00:08:49,360 --> 00:08:51,279
the answer from the user on the other


306
00:08:51,279 --> 00:08:51,760
end


307
00:08:51,760 --> 00:08:53,600
the way we do that is by listening to


308
00:08:53,600 --> 00:08:55,360
changes to the called document in


309
00:08:55,360 --> 00:08:56,240
firestore


310
00:08:56,240 --> 00:08:58,080
the on snapshot method will fire a


311
00:08:58,080 --> 00:09:00,000
callback anytime the document in the


312
00:09:00,000 --> 00:09:01,200
database changes


313
00:09:01,200 --> 00:09:02,880
if our peer connection doesn't have a


314
00:09:02,880 --> 00:09:04,240
current remote description


315
00:09:04,240 --> 00:09:06,640
and the data has an answer then we'll go


316
00:09:06,640 --> 00:09:08,000
ahead and set an


317
00:09:08,000 --> 00:09:10,000
answer description on our peer


318
00:09:10,000 --> 00:09:11,519
connection here locally


319
00:09:11,519 --> 00:09:12,959
in other words we're listening to our


320
00:09:12,959 --> 00:09:14,880
database for an answer and when that


321
00:09:14,880 --> 00:09:16,800
answer is received we update it on our


322
00:09:16,800 --> 00:09:18,080
peer connection


323
00:09:18,080 --> 00:09:20,080
that negotiates the initial connection


324
00:09:20,080 --> 00:09:21,680
but we also need to listen for ice


325
00:09:21,680 --> 00:09:23,760
candidates from the answering user we do


326
00:09:23,760 --> 00:09:24,959
that by listening to


327
00:09:24,959 --> 00:09:26,640
updates to the answer candidates


328
00:09:26,640 --> 00:09:28,640
collection firestore has a cool little


329
00:09:28,640 --> 00:09:30,320
feature where you can listen to


330
00:09:30,320 --> 00:09:32,240
only the documents that have been added


331
00:09:32,240 --> 00:09:34,000
to the collection which is handled with


332
00:09:34,000 --> 00:09:36,160
the doc changes method on the query


333
00:09:36,160 --> 00:09:38,000
so every time we have a new document


334
00:09:38,000 --> 00:09:40,480
added we can then create a new ice


335
00:09:40,480 --> 00:09:42,640
candidate with the document data


336
00:09:42,640 --> 00:09:44,800
and then add that candidate to our peer


337
00:09:44,800 --> 00:09:45,680
connection


338
00:09:45,680 --> 00:09:47,360
at this point we're listening to updates


339
00:09:47,360 --> 00:09:49,279
from the answer side but we still need


340
00:09:49,279 --> 00:09:51,440
to give the answer and user a way to


341
00:09:51,440 --> 00:09:53,360
actually answer the call answering a


342
00:09:53,360 --> 00:09:55,279
call is very similar to initiating a


343
00:09:55,279 --> 00:09:55,680
call


344
00:09:55,680 --> 00:09:57,279
the main difference is that we're going


345
00:09:57,279 --> 00:09:59,519
to listen to a document in firestore


346
00:09:59,519 --> 00:10:01,279
with the same document id that was


347
00:10:01,279 --> 00:10:02,880
created by the caller we'll make a


348
00:10:02,880 --> 00:10:04,240
reference to that document


349
00:10:04,240 --> 00:10:05,839
as well as the answer candidates


350
00:10:05,839 --> 00:10:07,920
collection then listen to the ice


351
00:10:07,920 --> 00:10:10,000
candidate event on the peer connection


352
00:10:10,000 --> 00:10:12,079
to update the answer candidates


353
00:10:12,079 --> 00:10:14,079
collection whenever a new candidate


354
00:10:14,079 --> 00:10:16,560
is generated from there we can fetch the


355
00:10:16,560 --> 00:10:18,160
call document from the database


356
00:10:18,160 --> 00:10:20,480
and grab its data it contains the offer


357
00:10:20,480 --> 00:10:22,480
data which we can use to set


358
00:10:22,480 --> 00:10:24,560
a remote description on the peer


359
00:10:24,560 --> 00:10:26,160
connection after that


360
00:10:26,160 --> 00:10:28,320
we can then generate an answer locally


361
00:10:28,320 --> 00:10:30,160
then set the local description as the


362
00:10:30,160 --> 00:10:30,959
answer


363
00:10:30,959 --> 00:10:32,640
now just like we did with the offer in


364
00:10:32,640 --> 00:10:34,720
the previous function we'll set it up as


365
00:10:34,720 --> 00:10:36,079
a plain object


366
00:10:36,079 --> 00:10:38,320
and then update it on the call document


367
00:10:38,320 --> 00:10:40,160
so that the other user can listen to the


368
00:10:40,160 --> 00:10:40,880
answer


369
00:10:40,880 --> 00:10:42,800
in addition we'll set up a listener on


370
00:10:42,800 --> 00:10:44,560
the offer candidates collection


371
00:10:44,560 --> 00:10:46,800
and whenever a new ice candidate is


372
00:10:46,800 --> 00:10:48,000
added to that collection


373
00:10:48,000 --> 00:10:49,920
then we'll go ahead and create an ice


374
00:10:49,920 --> 00:10:51,279
candidate here locally


375
00:10:51,279 --> 00:10:53,120
and that's all it takes to build a video


376
00:10:53,120 --> 00:10:55,040
chat feature with webrtc


377
00:10:55,040 --> 00:10:56,880
the vast majority of the work is just


378
00:10:56,880 --> 00:10:59,040
signaling data between the two users


379
00:10:59,040 --> 00:11:01,279
webrtc handles all the complicated


380
00:11:01,279 --> 00:11:02,959
peer-to-peer networking and media


381
00:11:02,959 --> 00:11:04,240
streaming under the hood


382
00:11:04,240 --> 00:11:05,519
i'm going to go ahead and wrap things up


383
00:11:05,519 --> 00:11:07,120
there if this video helped you please


384
00:11:07,120 --> 00:11:08,079
like and subscribe


385
00:11:08,079 --> 00:11:09,279
and if you want to learn more advanced


386
00:11:09,279 --> 00:11:11,440
concepts about the web and firebase


387
00:11:11,440 --> 00:11:13,120
consider becoming a pro member at


388
00:11:13,120 --> 00:11:14,320
fireshipio


389
00:11:14,320 --> 00:11:16,160
thanks for watching and i will see you


390
00:11:16,160 --> 00:11:20,000
in the next one


