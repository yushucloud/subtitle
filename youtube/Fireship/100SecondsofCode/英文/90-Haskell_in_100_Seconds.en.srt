1
00:00:00,160 --> 00:00:01,839
haskell a statically typed


2
00:00:01,839 --> 00:00:03,840
general-purpose language made famous for


3
00:00:03,840 --> 00:00:05,680
expanding the minds of developers into


4
00:00:05,680 --> 00:00:07,440
the functional programming paradigm you


5
00:00:07,440 --> 00:00:09,440
see haskell is a purely functional


6
00:00:09,440 --> 00:00:11,599
language based on lambda calculus which


7
00:00:11,599 --> 00:00:13,360
means a function always produces the


8
00:00:13,360 --> 00:00:15,759
same output given the same input unlike


9
00:00:15,759 --> 00:00:17,520
an imperative language your code can't


10
00:00:17,520 --> 00:00:19,279
modify the inputs or produce side


11
00:00:19,279 --> 00:00:20,880
effects that would otherwise change the


12
00:00:20,880 --> 00:00:22,960
behavior of the application it was first


13
00:00:22,960 --> 00:00:25,199
developed in 1987 and named after


14
00:00:25,199 --> 00:00:27,519
logician haskell curry whose work had a


15
00:00:27,519 --> 00:00:29,039
massive influence on the functional


16
00:00:29,039 --> 00:00:30,720
programming world it's been used to


17
00:00:30,720 --> 00:00:32,480
build a wide variety of server-side


18
00:00:32,480 --> 00:00:34,640
applications like the hasura api


19
00:00:34,640 --> 00:00:37,040
platform spam filtering at facebook and


20
00:00:37,040 --> 00:00:39,360
compilers for other languages like elm


21
00:00:39,360 --> 00:00:41,200
and purescript and it's responsible for


22
00:00:41,200 --> 00:00:42,960
a countless number of blog posts about


23
00:00:42,960 --> 00:00:45,120
monads in haskell you write declarative


24
00:00:45,120 --> 00:00:46,960
code where the program is a single


25
00:00:46,960 --> 00:00:48,800
expression that is executed by


26
00:00:48,800 --> 00:00:50,960
evaluating that expression it also uses


27
00:00:50,960 --> 00:00:52,719
lazy evaluation which means an


28
00:00:52,719 --> 00:00:55,039
expression is not evaluated until it's


29
00:00:55,039 --> 00:00:56,719
actually used by a function this can


30
00:00:56,719 --> 00:00:58,480
result in big performance gains but


31
00:00:58,480 --> 00:01:00,640
unpredictable memory use at runtime all


32
00:01:00,640 --> 00:01:02,719
data in a haskell program is immutable


33
00:01:02,719 --> 00:01:04,640
which produces a lot of memory garbage


34
00:01:04,640 --> 00:01:06,560
so it contains a garbage collector to


35
00:01:06,560 --> 00:01:08,479
clean things up to get started install


36
00:01:08,479 --> 00:01:10,640
the glasgow haskell compiler then create


37
00:01:10,640 --> 00:01:12,799
a file ending in dot hs we don't work


38
00:01:12,799 --> 00:01:14,880
with statements here only expressions


39
00:01:14,880 --> 00:01:16,640
which is code that will always evaluate


40
00:01:16,640 --> 00:01:18,799
to a value create a string with double


41
00:01:18,799 --> 00:01:20,479
quotes then give it a name with the


42
00:01:20,479 --> 00:01:22,479
equal sign the value is immutable and


43
00:01:22,479 --> 00:01:24,080
can never be changed the type will


44
00:01:24,080 --> 00:01:25,680
automatically be inferred or we can


45
00:01:25,680 --> 00:01:27,759
strongly type it with a double colon as


46
00:01:27,759 --> 00:01:30,000
a list of characters now to define a


47
00:01:30,000 --> 00:01:31,840
function start with a name followed by


48
00:01:31,840 --> 00:01:33,520
the arguments that you want to pass to


49
00:01:33,520 --> 00:01:35,280
it on the right side define the logic of


50
00:01:35,280 --> 00:01:36,960
the function and it will automatically


51
00:01:36,960 --> 00:01:38,720
return a value based on the result of


52
00:01:38,720 --> 00:01:40,560
the expression we can also statically


53
00:01:40,560 --> 00:01:42,479
type it using an arrow to separate the


54
00:01:42,479 --> 00:01:44,399
argument and return value we can call


55
00:01:44,399 --> 00:01:46,159
the function by referencing its name


56
00:01:46,159 --> 00:01:48,240
with the arguments all values including


57
00:01:48,240 --> 00:01:50,159
functions are first class which means


58
00:01:50,159 --> 00:01:52,079
they can be passed as arguments to other


59
00:01:52,079 --> 00:01:53,920
functions if we try to print the result


60
00:01:53,920 --> 00:01:55,680
to the standard output we get an error


61
00:01:55,680 --> 00:01:57,680
that's because working with io creates a


62
00:01:57,680 --> 00:01:59,280
side effect to write a program that


63
00:01:59,280 --> 00:02:01,119
actually does something we write a main


64
00:02:01,119 --> 00:02:03,200
function with a do block here we can


65
00:02:03,200 --> 00:02:05,119
chain together a sequence of actions


66
00:02:05,119 --> 00:02:06,640
where the side effects are abstracted


67
00:02:06,640 --> 00:02:08,879
away made possible by a mathematical


68
00:02:08,879 --> 00:02:10,959
concept known as the monad which is


69
00:02:10,959 --> 00:02:12,560
basically a wrapper that can make


70
00:02:12,560 --> 00:02:14,800
functional code more modular now to run


71
00:02:14,800 --> 00:02:16,480
your code you can use the interactive


72
00:02:16,480 --> 00:02:18,160
interpreter or compile it to an


73
00:02:18,160 --> 00:02:20,800
executable by running ghc make this has


74
00:02:20,800 --> 00:02:23,120
been haskell in 100 seconds hit the like


75
00:02:23,120 --> 00:02:24,640
button and subscribe if you want to see


76
00:02:24,640 --> 00:02:26,319
more short videos like this thanks for


77
00:02:26,319 --> 00:02:28,319
watching and i will see you in the next


78
00:02:28,319 --> 00:02:31,280
one


