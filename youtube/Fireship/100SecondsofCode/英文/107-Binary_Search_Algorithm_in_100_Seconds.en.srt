1
00:00:00,160 --> 00:00:02,560
binary search an algorithm for finding


2
00:00:02,560 --> 00:00:04,480
an element in a sorted array by


3
00:00:04,480 --> 00:00:06,480
continuously chopping the search area in


4
00:00:06,480 --> 00:00:08,320
half the first known implementation took


5
00:00:08,320 --> 00:00:10,880
place around 200 bc and ancient babylon


6
00:00:10,880 --> 00:00:13,040
on clay tablets used for record keeping


7
00:00:13,040 --> 00:00:14,799
but your brain has likely implemented


8
00:00:14,799 --> 00:00:16,640
binary search in everyday life without


9
00:00:16,640 --> 00:00:18,240
you even knowing it imagine looking for


10
00:00:18,240 --> 00:00:20,240
a word like magic in the dictionary you


11
00:00:20,240 --> 00:00:21,760
wouldn't flip every page until you get


12
00:00:21,760 --> 00:00:24,080
to m instead you open it in the middle


13
00:00:24,080 --> 00:00:26,000
if you overshoot to the cues then you go


14
00:00:26,000 --> 00:00:27,760
to the middle of that chunk this time


15
00:00:27,760 --> 00:00:29,439
you undershoot to the js so you do the


16
00:00:29,439 --> 00:00:31,039
same thing again but in the other


17
00:00:31,039 --> 00:00:32,640
direction until finally you find the


18
00:00:32,640 --> 00:00:34,399
page you're looking for easy enough now


19
00:00:34,399 --> 00:00:36,000
it's time for your technical interview


20
00:00:36,000 --> 00:00:37,920
you might be given a question like given


21
00:00:37,920 --> 00:00:39,920
a sorted array write a function that


22
00:00:39,920 --> 00:00:41,840
returns the index for the given element


23
00:00:41,840 --> 00:00:43,520
the easy way to solve that problem is


24
00:00:43,520 --> 00:00:45,520
with a simple for loop just loop over


25
00:00:45,520 --> 00:00:47,039
every element in the array until you


26
00:00:47,039 --> 00:00:48,559
find the one you're looking for that


27
00:00:48,559 --> 00:00:50,000
works but you failed the interview


28
00:00:50,000 --> 00:00:51,920
because you need to go faster a regular


29
00:00:51,920 --> 00:00:54,000
loop results in linear time complexity


30
00:00:54,000 --> 00:00:55,280
but you can do better than that here's


31
00:00:55,280 --> 00:00:56,960
how we might map out a binary search on


32
00:00:56,960 --> 00:00:58,960
a whiteboard first we need to figure out


33
00:00:58,960 --> 00:01:00,719
the middle index instead of starting at


34
00:01:00,719 --> 00:01:02,640
index 0 we start in the middle if it's


35
00:01:02,640 --> 00:01:04,320
equal to the target then we return that


36
00:01:04,320 --> 00:01:06,159
index but if that element is greater


37
00:01:06,159 --> 00:01:07,840
than the target we know the target must


38
00:01:07,840 --> 00:01:09,439
be somewhere on the left so we find the


39
00:01:09,439 --> 00:01:11,280
middle of that slice of the array but if


40
00:01:11,280 --> 00:01:12,640
it's less than the target then we know


41
00:01:12,640 --> 00:01:14,159
the target is somewhere on the right so


42
00:01:14,159 --> 00:01:15,920
we repeat the process for that slice of


43
00:01:15,920 --> 00:01:17,759
the array the result is a much faster


44
00:01:17,759 --> 00:01:19,280
algorithm with logarithmic time


45
00:01:19,280 --> 00:01:21,280
complexity because it's able to divide


46
00:01:21,280 --> 00:01:23,280
and conquer now to implement the code we


47
00:01:23,280 --> 00:01:24,960
could use an iterative approach with a


48
00:01:24,960 --> 00:01:26,960
while loop or a recursive function


49
00:01:26,960 --> 00:01:28,479
either way is acceptable but let's


50
00:01:28,479 --> 00:01:30,079
define a recursive function in


51
00:01:30,079 --> 00:01:32,159
javascript the function takes the target


52
00:01:32,159 --> 00:01:33,840
value as an argument as well as a


53
00:01:33,840 --> 00:01:35,680
starting and ending index first we have


54
00:01:35,680 --> 00:01:37,759
a base condition to stop looping when it


55
00:01:37,759 --> 00:01:39,520
reaches the end of the array at which


56
00:01:39,520 --> 00:01:41,360
point we know the target is not in the


57
00:01:41,360 --> 00:01:43,119
array from there we compute the middle


58
00:01:43,119 --> 00:01:44,720
index then we check to see if that


59
00:01:44,720 --> 00:01:46,560
middle index is equal to the target at


60
00:01:46,560 --> 00:01:48,159
which point we can return because we


61
00:01:48,159 --> 00:01:49,600
found the element we're looking for


62
00:01:49,600 --> 00:01:51,520
otherwise we need to continue searching


63
00:01:51,520 --> 00:01:52,880
and that's where recursion comes into


64
00:01:52,880 --> 00:01:54,720
play if the middle value is greater than


65
00:01:54,720 --> 00:01:56,159
the target then we'll call the same


66
00:01:56,159 --> 00:01:57,840
function but this time we'll put the


67
00:01:57,840 --> 00:01:59,840
ending index at the middle the other


68
00:01:59,840 --> 00:02:01,920
possibility is that the middle value is


69
00:02:01,920 --> 00:02:03,680
less than the target in which case we


70
00:02:03,680 --> 00:02:05,759
can also recurse but this time we'll put


71
00:02:05,759 --> 00:02:07,520
the starting index in the middle and now


72
00:02:07,520 --> 00:02:09,039
we have an algorithm that can find an


73
00:02:09,039 --> 00:02:10,879
element in a sorted array much faster


74
00:02:10,879 --> 00:02:12,319
than a regular loop if you want to see


75
00:02:12,319 --> 00:02:13,840
more videos about algorithms on this


76
00:02:13,840 --> 00:02:15,440
channel hit the like button and let me


77
00:02:15,440 --> 00:02:17,200
know in the comments thanks for watching


78
00:02:17,200 --> 00:02:21,280
and i will see you in the next one


