1
00:00:00,719 --> 00:00:03,360
bitcoin a peer-to-peer electronic cash


2
00:00:03,360 --> 00:00:03,919
system


3
00:00:03,919 --> 00:00:06,399
first described in a 2008 white paper


4
00:00:06,399 --> 00:00:08,240
authored by the mysterious satoshi


5
00:00:08,240 --> 00:00:10,400
nakamoto the modern financial system


6
00:00:10,400 --> 00:00:12,480
relies on our trust of big centralized


7
00:00:12,480 --> 00:00:14,400
banks to hold our fiat currencies


8
00:00:14,400 --> 00:00:16,640
and execute transactions but trust is a


9
00:00:16,640 --> 00:00:18,320
weakness that eventually requires


10
00:00:18,320 --> 00:00:20,560
intervention by lawyers and government


11
00:00:20,560 --> 00:00:22,480
bitcoin allows two parties to make


12
00:00:22,480 --> 00:00:23,920
reliable transactions


13
00:00:23,920 --> 00:00:26,000
based on cryptographic proof eliminating


14
00:00:26,000 --> 00:00:27,760
the need for a trustee middleman


15
00:00:27,760 --> 00:00:29,599
the optimists call it digital gold the


16
00:00:29,599 --> 00:00:31,119
pessimists call it fool's gold


17
00:00:31,119 --> 00:00:33,200
but in reality it's just software and


18
00:00:33,200 --> 00:00:35,200
like all software its purpose is to


19
00:00:35,200 --> 00:00:37,120
arrange ones and zeros in a meaningful


20
00:00:37,120 --> 00:00:37,600
way


21
00:00:37,600 --> 00:00:39,360
the protocol that makes it meaningful is


22
00:00:39,360 --> 00:00:41,280
blockchain which allows two parties to


23
00:00:41,280 --> 00:00:43,360
engage in transactions denominated in


24
00:00:43,360 --> 00:00:44,000
bitcoins


25
00:00:44,000 --> 00:00:46,160
or satoshi's and just like dollars and


26
00:00:46,160 --> 00:00:47,520
cents they have value


27
00:00:47,520 --> 00:00:49,200
because we believe they do from a


28
00:00:49,200 --> 00:00:51,280
financial perspective the blockchain


29
00:00:51,280 --> 00:00:53,280
is like a shared public ledger that


30
00:00:53,280 --> 00:00:55,280
contains all transactions from all


31
00:00:55,280 --> 00:00:56,320
bitcoin users


32
00:00:56,320 --> 00:00:58,079
and is distributed and synchronized


33
00:00:58,079 --> 00:00:59,680
around the world which eliminates the


34
00:00:59,680 --> 00:01:01,760
need for a central authority to maintain


35
00:01:01,760 --> 00:01:02,640
and validate it


36
00:01:02,640 --> 00:01:04,320
from a technical perspective think of


37
00:01:04,320 --> 00:01:06,159
the blockchain as a database


38
00:01:06,159 --> 00:01:08,320
structured as a linked list where each


39
00:01:08,320 --> 00:01:09,439
record or block


40
00:01:09,439 --> 00:01:11,520
represents a group of transactions that


41
00:01:11,520 --> 00:01:13,200
have been permanently committed to the


42
00:01:13,200 --> 00:01:13,840
database


43
00:01:13,840 --> 00:01:15,520
it works kind of like a git repo that


44
00:01:15,520 --> 00:01:17,680
can never be rebased the important thing


45
00:01:17,680 --> 00:01:19,280
is that each new block is


46
00:01:19,280 --> 00:01:20,479
linked to the previous one in the


47
00:01:20,479 --> 00:01:22,640
blockchain and its creation goes through


48
00:01:22,640 --> 00:01:24,880
a very strict set of cryptographic rules


49
00:01:24,880 --> 00:01:27,280
each user or wallet has a unique public


50
00:01:27,280 --> 00:01:28,640
key for receiving money


51
00:01:28,640 --> 00:01:30,720
kind of like a username and a unique


52
00:01:30,720 --> 00:01:32,479
private key for spending money


53
00:01:32,479 --> 00:01:34,720
kind of like a password but before you


54
00:01:34,720 --> 00:01:36,240
can spend money you'll need to prove


55
00:01:36,240 --> 00:01:38,000
that you're the owner of a public key


56
00:01:38,000 --> 00:01:40,079
that money has been sent to in the past


57
00:01:40,079 --> 00:01:42,320
each transaction contains a hash or


58
00:01:42,320 --> 00:01:43,759
encrypted representation


59
00:01:43,759 --> 00:01:45,840
of the previous transaction and the new


60
00:01:45,840 --> 00:01:46,960
owner's public key


61
00:01:46,960 --> 00:01:48,479
the hash is then signed with the


62
00:01:48,479 --> 00:01:50,000
previous owner's private key


63
00:01:50,000 --> 00:01:51,759
this makes it possible to validate the


64
00:01:51,759 --> 00:01:53,520
chain of ownership without the need to


65
00:01:53,520 --> 00:01:54,000
expose


66
00:01:54,000 --> 00:01:55,680
the private key and the signature makes


67
00:01:55,680 --> 00:01:57,119
it virtually impossible to


68
00:01:57,119 --> 00:01:58,960
alter the transaction after it's been


69
00:01:58,960 --> 00:02:01,200
issued but what if somebody tries to pay


70
00:02:01,200 --> 00:02:02,880
two different people with bitcoin at the


71
00:02:02,880 --> 00:02:03,840
exact same time


72
00:02:03,840 --> 00:02:05,520
or double spend their money that's where


73
00:02:05,520 --> 00:02:07,680
mining comes in which is a system that


74
00:02:07,680 --> 00:02:09,440
allows multiple computers around the


75
00:02:09,440 --> 00:02:09,840
world


76
00:02:09,840 --> 00:02:11,920
to agree on the appropriate state of the


77
00:02:11,920 --> 00:02:13,520
entire system or ledger


78
00:02:13,520 --> 00:02:15,840
each new transaction is broadcast to all


79
00:02:15,840 --> 00:02:16,800
nodes in the network


80
00:02:16,800 --> 00:02:18,480
the transactions are packaged into a


81
00:02:18,480 --> 00:02:20,640
block then miners will expend computing


82
00:02:20,640 --> 00:02:22,800
power to validate proof of work


83
00:02:22,800 --> 00:02:24,480
they compute a proof for a random


84
00:02:24,480 --> 00:02:26,400
problem that is very difficult to solve


85
00:02:26,400 --> 00:02:28,000
but very easy to verify


86
00:02:28,000 --> 00:02:29,920
the first miner to solve the proof which


87
00:02:29,920 --> 00:02:31,280
happens via dumb luck


88
00:02:31,280 --> 00:02:32,959
gets a portion of the bitcoin as a


89
00:02:32,959 --> 00:02:35,120
reward the block is then broadcast back


90
00:02:35,120 --> 00:02:35,599
to all


91
00:02:35,599 --> 00:02:37,040
other nodes where it's permanently


92
00:02:37,040 --> 00:02:38,800
confirmed on the blockchain this has


93
00:02:38,800 --> 00:02:40,720
been bitcoin in 100 seconds


94
00:02:40,720 --> 00:02:42,080
if you want to see more short videos


95
00:02:42,080 --> 00:02:43,360
like this make sure to like and


96
00:02:43,360 --> 00:02:44,080
subscribe


97
00:02:44,080 --> 00:02:45,200
and if you really want to learn how


98
00:02:45,200 --> 00:02:47,599
blockchain technology works stay tuned


99
00:02:47,599 --> 00:02:49,200
because today we're going beyond 100


100
00:02:49,200 --> 00:02:50,879
seconds to build a blockchain from


101
00:02:50,879 --> 00:02:53,040
scratch with node.js and typescript and


102
00:02:53,040 --> 00:02:53,680
in the process


103
00:02:53,680 --> 00:02:54,879
you'll learn all kinds of useful


104
00:02:54,879 --> 00:02:56,959
information about cryptography


105
00:02:56,959 --> 00:02:58,480
whether you're into cryptocurrency or


106
00:02:58,480 --> 00:03:00,000
not there's many concepts in


107
00:03:00,000 --> 00:03:01,760
cryptography that you should know about


108
00:03:01,760 --> 00:03:02,800
as a developer


109
00:03:02,800 --> 00:03:04,400
things like encryption and signing


110
00:03:04,400 --> 00:03:06,640
hashing functions and algorithms like


111
00:03:06,640 --> 00:03:07,360
sha


112
00:03:07,360 --> 00:03:10,080
rsa and md5 that make all this stuff


113
00:03:10,080 --> 00:03:10,640
possible


114
00:03:10,640 --> 00:03:12,000
over the next few minutes you'll learn


115
00:03:12,000 --> 00:03:13,680
about these concepts by implementing


116
00:03:13,680 --> 00:03:15,440
your own blockchain from scratch


117
00:03:15,440 --> 00:03:18,159
using nothing but node.js and typescript


118
00:03:18,159 --> 00:03:19,840
our blockchain will contain wallets


119
00:03:19,840 --> 00:03:21,519
where users can send money back and


120
00:03:21,519 --> 00:03:22,000
forth


121
00:03:22,000 --> 00:03:24,560
each transaction is added into a block


122
00:03:24,560 --> 00:03:26,720
then that block is mined with a proof of


123
00:03:26,720 --> 00:03:27,519
work system


124
00:03:27,519 --> 00:03:29,040
at which point it can be added and


125
00:03:29,040 --> 00:03:30,560
confirmed on the blockchain and


126
00:03:30,560 --> 00:03:31,760
throughout this process you'll learn


127
00:03:31,760 --> 00:03:32,080
about


128
00:03:32,080 --> 00:03:33,760
all kinds of important concepts and how


129
00:03:33,760 --> 00:03:35,440
they apply to different areas of


130
00:03:35,440 --> 00:03:36,239
development


131
00:03:36,239 --> 00:03:38,000
to get started you'll need node.js


132
00:03:38,000 --> 00:03:39,519
installed on your system


133
00:03:39,519 --> 00:03:41,599
then we'll open up vs code to an empty


134
00:03:41,599 --> 00:03:44,159
directory run npm init y


135
00:03:44,159 --> 00:03:46,720
to create a new node.js project i'll be


136
00:03:46,720 --> 00:03:48,080
using typescript in this code


137
00:03:48,080 --> 00:03:50,080
because we'll be using object-oriented


138
00:03:50,080 --> 00:03:51,840
programming principles to implement the


139
00:03:51,840 --> 00:03:53,599
blockchain and having types will just


140
00:03:53,599 --> 00:03:55,120
make our code a bit more readable


141
00:03:55,120 --> 00:03:57,360
you can install it with npm then create


142
00:03:57,360 --> 00:03:58,640
a ts config file


143
00:03:58,640 --> 00:04:00,560
and copy and paste the values from the


144
00:04:00,560 --> 00:04:02,560
main source code from there we can go


145
00:04:02,560 --> 00:04:03,920
into our package json


146
00:04:03,920 --> 00:04:06,400
and create a script called dev that runs


147
00:04:06,400 --> 00:04:08,319
the typescript compiler with the watch


148
00:04:08,319 --> 00:04:08,879
flag


149
00:04:08,879 --> 00:04:10,480
to constantly compile our code in the


150
00:04:10,480 --> 00:04:12,480
background to plain javascript from


151
00:04:12,480 --> 00:04:13,760
there you should be able to run


152
00:04:13,760 --> 00:04:16,160
npm run dev from the command line to


153
00:04:16,160 --> 00:04:17,519
keep typescript running in the


154
00:04:17,519 --> 00:04:18,400
background


155
00:04:18,400 --> 00:04:20,079
now we'll write all of our source code


156
00:04:20,079 --> 00:04:22,000
in the index cs file


157
00:04:22,000 --> 00:04:24,240
at the top of that file we will import


158
00:04:24,240 --> 00:04:26,560
the crypto library which is a built-in


159
00:04:26,560 --> 00:04:29,040
in node.js as the name implies it's a


160
00:04:29,040 --> 00:04:31,040
modular node that handles a bunch of


161
00:04:31,040 --> 00:04:33,199
different functionality for cryptography


162
00:04:33,199 --> 00:04:34,960
our simple blockchain implementation


163
00:04:34,960 --> 00:04:36,560
here has four classes


164
00:04:36,560 --> 00:04:39,600
a transaction a block a chain and a


165
00:04:39,600 --> 00:04:40,400
wallet


166
00:04:40,400 --> 00:04:41,680
let's start by implementing the


167
00:04:41,680 --> 00:04:43,520
transaction which is the fundamental


168
00:04:43,520 --> 00:04:45,280
purpose of any cryptocurrency


169
00:04:45,280 --> 00:04:47,440
transfer funds from one user to another


170
00:04:47,440 --> 00:04:49,280
user in a transaction


171
00:04:49,280 --> 00:04:51,199
a transaction object has three


172
00:04:51,199 --> 00:04:53,600
properties the amount of the transaction


173
00:04:53,600 --> 00:04:56,479
denominated in bitcoins or fire coins or


174
00:04:56,479 --> 00:04:58,240
whatever you want to call your coin


175
00:04:58,240 --> 00:04:59,759
along with the person paying the money


176
00:04:59,759 --> 00:05:01,360
and the person receiving the money


177
00:05:01,360 --> 00:05:03,039
eventually we'll set up public keys for


178
00:05:03,039 --> 00:05:04,960
these users which you can think of as a


179
00:05:04,960 --> 00:05:06,880
username that will eventually set as


180
00:05:06,880 --> 00:05:08,720
these values in the transaction


181
00:05:08,720 --> 00:05:10,479
one final thing we'll do here is add a


182
00:05:10,479 --> 00:05:12,400
method to the class to convert the


183
00:05:12,400 --> 00:05:13,759
object to a string


184
00:05:13,759 --> 00:05:15,199
as we go through the tutorial we're


185
00:05:15,199 --> 00:05:16,960
going to serialize everything as


186
00:05:16,960 --> 00:05:18,880
strings just to make the cryptographic


187
00:05:18,880 --> 00:05:20,320
objects easier to work with


188
00:05:20,320 --> 00:05:21,840
and now we're ready to move on to the


189
00:05:21,840 --> 00:05:23,759
block implementation


190
00:05:23,759 --> 00:05:26,240
a block is like a container for multiple


191
00:05:26,240 --> 00:05:27,280
transactions


192
00:05:27,280 --> 00:05:29,440
or in our case just a single transaction


193
00:05:29,440 --> 00:05:30,560
to keep things simple


194
00:05:30,560 --> 00:05:32,479
you can think of a block like an element


195
00:05:32,479 --> 00:05:34,880
in an array or more accurately a linked


196
00:05:34,880 --> 00:05:35,440
list


197
00:05:35,440 --> 00:05:37,600
because each block has a reference or


198
00:05:37,600 --> 00:05:39,759
link to the previous block in the chain


199
00:05:39,759 --> 00:05:42,000
with the previous hash property and that


200
00:05:42,000 --> 00:05:44,080
brings up a good cryptographic question


201
00:05:44,080 --> 00:05:46,560
what is a hash a hashing function allows


202
00:05:46,560 --> 00:05:48,960
you to take a value of an arbitrary size


203
00:05:48,960 --> 00:05:51,600
like say a transaction then map it to a


204
00:05:51,600 --> 00:05:52,000
value


205
00:05:52,000 --> 00:05:54,240
with a fixed length like a hexadecimal


206
00:05:54,240 --> 00:05:56,000
string the value returned from the


207
00:05:56,000 --> 00:05:56,960
hashing function


208
00:05:56,960 --> 00:05:59,600
is often called a hash or a hash digest


209
00:05:59,600 --> 00:06:01,120
when you create a hash it cannot be


210
00:06:01,120 --> 00:06:02,880
reversed to reconstruct the


211
00:06:02,880 --> 00:06:05,039
contents of the original value but what


212
00:06:05,039 --> 00:06:07,199
you can do is validate that two values


213
00:06:07,199 --> 00:06:08,080
are identical


214
00:06:08,080 --> 00:06:10,000
by comparing their hashes and that's


215
00:06:10,000 --> 00:06:11,680
important for a blockchain because it


216
00:06:11,680 --> 00:06:13,440
ensures that two blocks can be linked


217
00:06:13,440 --> 00:06:15,360
together without being manipulated


218
00:06:15,360 --> 00:06:17,120
now to create a hash of a block we're


219
00:06:17,120 --> 00:06:18,720
going to implement a getter


220
00:06:18,720 --> 00:06:20,560
that will first stringify the object


221
00:06:20,560 --> 00:06:22,560
itself then we'll use the create hash


222
00:06:22,560 --> 00:06:24,240
function from node crypto


223
00:06:24,240 --> 00:06:26,400
which specifies a specific hashing


224
00:06:26,400 --> 00:06:28,360
algorithm in this case


225
00:06:28,360 --> 00:06:31,280
sha-256 it stands for secure hash


226
00:06:31,280 --> 00:06:31,919
algorithm


227
00:06:31,919 --> 00:06:34,720
with a length of 256 bits it was


228
00:06:34,720 --> 00:06:37,039
developed by the nsa back in 2001


229
00:06:37,039 --> 00:06:38,880
and it's what's known as a one-way


230
00:06:38,880 --> 00:06:40,240
cryptographic function


231
00:06:40,240 --> 00:06:42,000
which means that it can encrypt data but


232
00:06:42,000 --> 00:06:43,680
it cannot decrypt data back to its


233
00:06:43,680 --> 00:06:44,720
original form


234
00:06:44,720 --> 00:06:46,560
we can use the function to hash the


235
00:06:46,560 --> 00:06:48,080
string version of the block


236
00:06:48,080 --> 00:06:50,560
then return the hash value or digest as


237
00:06:50,560 --> 00:06:52,080
a hexadecimal string


238
00:06:52,080 --> 00:06:53,759
and that's all it takes to build a block


239
00:06:53,759 --> 00:06:55,440
in this case it's a transaction


240
00:06:55,440 --> 00:06:56,880
that has a link to the previous


241
00:06:56,880 --> 00:06:58,800
transaction in the form of a hash


242
00:06:58,800 --> 00:07:00,800
and it also contains a timestamp because


243
00:07:00,800 --> 00:07:02,240
all blocks will be placed in


244
00:07:02,240 --> 00:07:03,680
chronological order


245
00:07:03,680 --> 00:07:05,280
now we can move on to the chain which


246
00:07:05,280 --> 00:07:07,680
again is like a linked list of blocks


247
00:07:07,680 --> 00:07:09,599
there should only be one blockchain so


248
00:07:09,599 --> 00:07:11,520
we'll go ahead and make it a singleton


249
00:07:11,520 --> 00:07:12,000
instance


250
00:07:12,000 --> 00:07:14,880
by setting up a static instance property


251
00:07:14,880 --> 00:07:16,720
that is equal to a new chain


252
00:07:16,720 --> 00:07:18,400
instance that'll just ensure that we


253
00:07:18,400 --> 00:07:20,400
have one chain instance instantiated


254
00:07:20,400 --> 00:07:21,680
before anything else


255
00:07:21,680 --> 00:07:23,360
now we can declare a property for the


256
00:07:23,360 --> 00:07:25,520
chain itself which is just an array of


257
00:07:25,520 --> 00:07:26,080
blocks


258
00:07:26,080 --> 00:07:27,599
in the constructor we'll define the


259
00:07:27,599 --> 00:07:29,440
first block in the chain which is called


260
00:07:29,440 --> 00:07:30,639
the genesis block


261
00:07:30,639 --> 00:07:32,319
the previous hash is null because


262
00:07:32,319 --> 00:07:33,919
there's nothing for it to link to


263
00:07:33,919 --> 00:07:36,160
then it instantiates a new transaction


264
00:07:36,160 --> 00:07:37,840
that transfers a hundred coins to


265
00:07:37,840 --> 00:07:38,560
satoshi


266
00:07:38,560 --> 00:07:40,080
notice how we're creating money out of


267
00:07:40,080 --> 00:07:41,680
thin air here that's no different than


268
00:07:41,680 --> 00:07:43,280
when the central bankers or federal


269
00:07:43,280 --> 00:07:44,960
reserve turn on the money printer


270
00:07:44,960 --> 00:07:46,800
now in the blockchain class we'll often


271
00:07:46,800 --> 00:07:48,879
need to grab the last block in the chain


272
00:07:48,879 --> 00:07:50,800
so we'll go ahead and create a getter to


273
00:07:50,800 --> 00:07:52,000
help us out with that


274
00:07:52,000 --> 00:07:54,080
then we'll define a new method named add


275
00:07:54,080 --> 00:07:56,319
block that takes a transaction


276
00:07:56,319 --> 00:07:59,039
the sender's public key and a signature


277
00:07:59,039 --> 00:08:00,080
that we can verify


278
00:08:00,080 --> 00:08:02,080
before adding a new block to the chain a


279
00:08:02,080 --> 00:08:04,000
naive and simple implementation might


280
00:08:04,000 --> 00:08:04,879
look like this


281
00:08:04,879 --> 00:08:07,280
we instantiate a new block taking the


282
00:08:07,280 --> 00:08:09,039
last block's hash and this new


283
00:08:09,039 --> 00:08:09,840
transaction


284
00:08:09,840 --> 00:08:11,520
then we push that new block onto the


285
00:08:11,520 --> 00:08:13,599
chain but the problem is that there's no


286
00:08:13,599 --> 00:08:15,199
way to know that this is a legitimate


287
00:08:15,199 --> 00:08:16,080
transaction


288
00:08:16,080 --> 00:08:18,070
anybody could send arbitrary 

289
00:08:18,070 --> 00:08:18,080
anybody could send arbitrary transaction


290
00:08:18,080 --> 00:08:19,280
data to transfer


291
00:08:19,280 --> 00:08:21,599
coin to someone else we can allow people


292
00:08:21,599 --> 00:08:23,919
to securely send coin back and forth by


293
00:08:23,919 --> 00:08:25,120
implementing a wallet


294
00:08:25,120 --> 00:08:27,039
which is essentially just a wrapper for


295
00:08:27,039 --> 00:08:28,800
a public key and a private key


296
00:08:28,800 --> 00:08:30,479
the public key is for receiving money


297
00:08:30,479 --> 00:08:32,560
the private key is for spending money


298
00:08:32,560 --> 00:08:34,479
to generate a public and private key


299
00:08:34,479 --> 00:08:36,320
we're going to use a different algorithm


300
00:08:36,320 --> 00:08:37,680
called rsa


301
00:08:37,680 --> 00:08:39,279
which stands for the names of the guys


302
00:08:39,279 --> 00:08:40,880
that created it and unlike


303
00:08:40,880 --> 00:08:43,599
sha this is a full encryption algorithm


304
00:08:43,599 --> 00:08:44,959
that can encrypt data


305
00:08:44,959 --> 00:08:46,560
and then decrypt it if you have the


306
00:08:46,560 --> 00:08:49,040
proper key to do so to encrypt a value


307
00:08:49,040 --> 00:08:50,800
you would use the public key to convert


308
00:08:50,800 --> 00:08:53,120
it to ciphertext which is an unreadable


309
00:08:53,120 --> 00:08:55,040
version of the original value then you


310
00:08:55,040 --> 00:08:57,120
would use the private key to decrypt it


311
00:08:57,120 --> 00:08:58,880
back to its original form


312
00:08:58,880 --> 00:09:00,399
but what we're actually more interested


313
00:09:00,399 --> 00:09:02,720
in is using the key pair to create a


314
00:09:02,720 --> 00:09:03,839
digital signature


315
00:09:03,839 --> 00:09:05,600
with signing we don't need to encrypt


316
00:09:05,600 --> 00:09:07,920
the message but instead create a hash of


317
00:09:07,920 --> 00:09:09,440
it we then sign the hash with our


318
00:09:09,440 --> 00:09:10,240
private key


319
00:09:10,240 --> 00:09:12,000
then the message can be verified later


320
00:09:12,000 --> 00:09:14,000
using the public key if anybody tried to


321
00:09:14,000 --> 00:09:15,600
change the message it would produce a


322
00:09:15,600 --> 00:09:17,040
different hash in which case the


323
00:09:17,040 --> 00:09:18,480
verification would fail


324
00:09:18,480 --> 00:09:20,160
and that's really important for a coin


325
00:09:20,160 --> 00:09:21,519
because if we didn't have a signature


326
00:09:21,519 --> 00:09:23,120
then someone could intercept the


327
00:09:23,120 --> 00:09:24,880
transaction message and change the


328
00:09:24,880 --> 00:09:26,640
amount or change the payee


329
00:09:26,640 --> 00:09:28,480
with no way to detect that anything was


330
00:09:28,480 --> 00:09:30,000
out of the ordinary


331
00:09:30,000 --> 00:09:31,440
now when generating the key pair with


332
00:09:31,440 --> 00:09:33,920
node crypto i'm going to format them as


333
00:09:33,920 --> 00:09:34,560
strings


334
00:09:34,560 --> 00:09:36,160
and to do that i'm going to add some


335
00:09:36,160 --> 00:09:37,920
extra options here for encoding the


336
00:09:37,920 --> 00:09:38,880
important one to know


337
00:09:38,880 --> 00:09:40,480
is the format pem which you would


338
00:09:40,480 --> 00:09:42,080
normally save to a file


339
00:09:42,080 --> 00:09:43,839
on the user's computer system where it


340
00:09:43,839 --> 00:09:45,279
could be reused in the future


341
00:09:45,279 --> 00:09:46,640
now that we have a public key and


342
00:09:46,640 --> 00:09:48,880
private key we can use it to send money


343
00:09:48,880 --> 00:09:50,160
to another user


344
00:09:50,160 --> 00:09:52,080
the way we do that is by specifying an


345
00:09:52,080 --> 00:09:53,760
amount and the public key


346
00:09:53,760 --> 00:09:55,920
of the user being paid we can then use


347
00:09:55,920 --> 00:09:58,000
node crypto to create a signature


348
00:09:58,000 --> 00:10:00,720
again an sha 256 format using the


349
00:10:00,720 --> 00:10:02,640
transaction data as the value


350
00:10:02,640 --> 00:10:04,240
we can then create a signature by


351
00:10:04,240 --> 00:10:05,839
signing it with a private key


352
00:10:05,839 --> 00:10:07,680
this is kind of like creating a one-time


353
00:10:07,680 --> 00:10:10,000
password it allows us to verify our


354
00:10:10,000 --> 00:10:12,079
identity with the private key without


355
00:10:12,079 --> 00:10:13,760
actually having to expose the private


356
00:10:13,760 --> 00:10:15,600
key the signature depends on both the


357
00:10:15,600 --> 00:10:17,680
transaction data and the private key


358
00:10:17,680 --> 00:10:19,440
but it can be verified as authentic


359
00:10:19,440 --> 00:10:21,440
using the public key we can now attempt


360
00:10:21,440 --> 00:10:23,440
to add that block to the blockchain by


361
00:10:23,440 --> 00:10:24,720
passing the transaction


362
00:10:24,720 --> 00:10:27,040
the public key and the signature in real


363
00:10:27,040 --> 00:10:28,640
life those values would be transferred


364
00:10:28,640 --> 00:10:29,600
over the internet


365
00:10:29,600 --> 00:10:31,440
then the signature could be verified


366
00:10:31,440 --> 00:10:33,440
let's go ahead and refactor the add


367
00:10:33,440 --> 00:10:34,240
block method


368
00:10:34,240 --> 00:10:36,800
in the chain class it'll use node crypto


369
00:10:36,800 --> 00:10:38,959
to create a signature verification


370
00:10:38,959 --> 00:10:40,880
then pass the same transaction data to


371
00:10:40,880 --> 00:10:42,720
the verifier we can then validate it


372
00:10:42,720 --> 00:10:44,480
by verifying that the transaction data


373
00:10:44,480 --> 00:10:45,760
has not been tampered with


374
00:10:45,760 --> 00:10:47,920
using the sender's public key and the


375
00:10:47,920 --> 00:10:48,959
signature itself


376
00:10:48,959 --> 00:10:50,880
and we're now able to securely verify


377
00:10:50,880 --> 00:10:52,800
that that user is actually trying to


378
00:10:52,800 --> 00:10:54,640
spend that amount of money to the other


379
00:10:54,640 --> 00:10:55,600
user


380
00:10:55,600 --> 00:10:57,120
but there's still one more big issue


381
00:10:57,120 --> 00:10:58,880
with our blockchain and that is the


382
00:10:58,880 --> 00:11:00,160
double spend issue


383
00:11:00,160 --> 00:11:02,160
imagine the spender tried to send money


384
00:11:02,160 --> 00:11:04,320
to two different users at the same time


385
00:11:04,320 --> 00:11:05,760
they could potentially spend more money


386
00:11:05,760 --> 00:11:07,519
than they actually own before their


387
00:11:07,519 --> 00:11:09,040
transaction is confirmed on the


388
00:11:09,040 --> 00:11:09,680
blockchain


389
00:11:09,680 --> 00:11:11,680
the way bitcoin addresses that issue is


390
00:11:11,680 --> 00:11:13,440
with a proof of work system which


391
00:11:13,440 --> 00:11:14,000
requires


392
00:11:14,000 --> 00:11:15,920
each new block to go through a process


393
00:11:15,920 --> 00:11:17,760
called mining where a difficult


394
00:11:17,760 --> 00:11:19,920
computational problem is solved in order


395
00:11:19,920 --> 00:11:21,120
to confirm the block


396
00:11:21,120 --> 00:11:23,200
but it's very easy to verify that work


397
00:11:23,200 --> 00:11:25,200
by multiple other nodes on the system


398
00:11:25,200 --> 00:11:26,800
when mining is distributed around the


399
00:11:26,800 --> 00:11:28,720
world it means you have multiple nodes


400
00:11:28,720 --> 00:11:29,440
competing


401
00:11:29,440 --> 00:11:31,680
to confirm a block on the blockchain and


402
00:11:31,680 --> 00:11:33,519
works like a big lottery the winner of


403
00:11:33,519 --> 00:11:35,440
the lottery earns a portion of the coin


404
00:11:35,440 --> 00:11:36,320
as incentive


405
00:11:36,320 --> 00:11:38,079
which motivates people to invest in the


406
00:11:38,079 --> 00:11:40,240
computing resources to mine a coin


407
00:11:40,240 --> 00:11:41,920
and also to pump the price of the coin


408
00:11:41,920 --> 00:11:43,440
higher and higher because the higher the


409
00:11:43,440 --> 00:11:44,880
price the more money you make


410
00:11:44,880 --> 00:11:46,160
you can think of it like converting


411
00:11:46,160 --> 00:11:48,560
cloud computing resources into money


412
00:11:48,560 --> 00:11:50,560
now to implement a basic proof of work


413
00:11:50,560 --> 00:11:52,240
system we'll go back into our block


414
00:11:52,240 --> 00:11:52,720
class


415
00:11:52,720 --> 00:11:54,720
and add a nonce value which is a


416
00:11:54,720 --> 00:11:56,560
one-time use random number


417
00:11:56,560 --> 00:11:58,240
then in the chain class we'll add a


418
00:11:58,240 --> 00:12:00,639
method called mine that takes that nonce


419
00:12:00,639 --> 00:12:01,600
as an argument


420
00:12:01,600 --> 00:12:03,440
what this method will do is attempt to


421
00:12:03,440 --> 00:12:05,279
find a number that when added to the


422
00:12:05,279 --> 00:12:05,760
nonce


423
00:12:05,760 --> 00:12:07,600
will produce a hash that starts with


424
00:12:07,600 --> 00:12:09,600
four zeros the only real way to figure


425
00:12:09,600 --> 00:12:11,600
out that value is with brute force by


426
00:12:11,600 --> 00:12:13,600
creating a while loop that goes digit by


427
00:12:13,600 --> 00:12:14,079
digit


428
00:12:14,079 --> 00:12:16,240
until we find the requested value to


429
00:12:16,240 --> 00:12:17,920
handle the brute force computation


430
00:12:17,920 --> 00:12:19,920
we'll create a while loop that creates a


431
00:12:19,920 --> 00:12:22,320
hash with the md5 algorithm


432
00:12:22,320 --> 00:12:25,519
it's very similar to sha-256 but is only


433
00:12:25,519 --> 00:12:26,880
128 bits


434
00:12:26,880 --> 00:12:28,880
and is faster to compute we'll continue


435
00:12:28,880 --> 00:12:30,000
to create new hashes


436
00:12:30,000 --> 00:12:31,839
inside the while loop until we find one


437
00:12:31,839 --> 00:12:33,360
that starts with four zeros


438
00:12:33,360 --> 00:12:34,880
when we find it we can return the


439
00:12:34,880 --> 00:12:36,800
solution and then send it off to other


440
00:12:36,800 --> 00:12:38,160
nodes where it can be verified


441
00:12:38,160 --> 00:12:39,920
and the block can finally be confirmed


442
00:12:39,920 --> 00:12:41,920
on the blockchain and that takes care of


443
00:12:41,920 --> 00:12:43,519
our blockchain implementation


444
00:12:43,519 --> 00:12:45,600
if we go down to the example usage here


445
00:12:45,600 --> 00:12:47,839
you can see we instantiate a few wallets


446
00:12:47,839 --> 00:12:49,279
for different users


447
00:12:49,279 --> 00:12:51,360
then allow those users to send money to


448
00:12:51,360 --> 00:12:53,120
each other using their various public


449
00:12:53,120 --> 00:12:53,680
keys


450
00:12:53,680 --> 00:12:55,040
if we go ahead and log out the chain


451
00:12:55,040 --> 00:12:56,959
itself you can see we have a bunch of


452
00:12:56,959 --> 00:12:58,959
blocks or transactions linked to each


453
00:12:58,959 --> 00:12:59,519
other


454
00:12:59,519 --> 00:13:01,519
based on a hash of the previous block


455
00:13:01,519 --> 00:13:03,120
now this blockchain is obviously not


456
00:13:03,120 --> 00:13:03,680
perfect


457
00:13:03,680 --> 00:13:04,800
and something that i just hacked


458
00:13:04,800 --> 00:13:06,480
together to teach you the gist of how a


459
00:13:06,480 --> 00:13:07,440
blockchain works


460
00:13:07,440 --> 00:13:09,200
feel free to grab the full source code


461
00:13:09,200 --> 00:13:10,880
on github if you learned something in


462
00:13:10,880 --> 00:13:11,519
the process


463
00:13:11,519 --> 00:13:13,120
please make sure to like and subscribe


464
00:13:13,120 --> 00:13:15,200
and consider sending me some bitcoin or


465
00:13:15,200 --> 00:13:17,200
sponsoring me on github for just one


466
00:13:17,200 --> 00:13:18,639
dollar a fiat per month


467
00:13:18,639 --> 00:13:20,720
i use all that income to sponsor other


468
00:13:20,720 --> 00:13:21,760
developers myself


469
00:13:21,760 --> 00:13:23,680
thanks for watching and i will see you


470
00:13:23,680 --> 00:13:30,079
in the next one


