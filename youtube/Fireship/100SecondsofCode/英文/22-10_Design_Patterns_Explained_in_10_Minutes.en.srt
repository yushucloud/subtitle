1
00:00:00,080 --> 00:00:01,920
when you first become a junior developer


2
00:00:01,920 --> 00:00:03,919
your code will look like play-doh snakes


3
00:00:03,919 --> 00:00:05,839
but as you progress to senior developer


4
00:00:05,839 --> 00:00:07,680
and learn about software design patterns


5
00:00:07,680 --> 00:00:09,280
your code will look like the sistine


6
00:00:09,280 --> 00:00:11,360
chapel but when you then progress to


7
00:00:11,360 --> 00:00:13,040
principal engineer you'll realize that


8
00:00:13,040 --> 00:00:14,639
nobody wants to maintain the sistine


9
00:00:14,639 --> 00:00:16,480
chapel for a silly website and go back


10
00:00:16,480 --> 00:00:18,160
to making play-doh snakes in today's


11
00:00:18,160 --> 00:00:19,760
video you'll learn about 10 different


12
00:00:19,760 --> 00:00:21,439
software design patterns along with the


13
00:00:21,439 --> 00:00:23,279
pros and cons of using them which can be


14
00:00:23,279 --> 00:00:25,279
very subjective and controversial one of


15
00:00:25,279 --> 00:00:26,640
the most influential books in the


16
00:00:26,640 --> 00:00:28,240
history of programming is design


17
00:00:28,240 --> 00:00:30,560
patterns by four c plus plus engineers


18
00:00:30,560 --> 00:00:32,320
called the gang of four it breaks down


19
00:00:32,320 --> 00:00:34,160
23 different approaches to address


20
00:00:34,160 --> 00:00:36,079
recurring problems that programmers face


21
00:00:36,079 --> 00:00:37,760
which are categorized as creational


22
00:00:37,760 --> 00:00:39,520
patterns how objects are created


23
00:00:39,520 --> 00:00:41,280
structural patterns how objects relate


24
00:00:41,280 --> 00:00:43,120
to each other and behavioral patterns


25
00:00:43,120 --> 00:00:45,039
how objects communicate with each other


26
00:00:45,039 --> 00:00:46,960
becoming a proficient software engineer


27
00:00:46,960 --> 00:00:48,879
is not about memorizing the syntax of a


28
00:00:48,879 --> 00:00:50,640
programming language but rather the


29
00:00:50,640 --> 00:00:52,879
ability to solve problems with it by the


30
00:00:52,879 --> 00:00:54,640
end of this video you'll understand a


31
00:00:54,640 --> 00:00:56,160
variety of different patterns for


32
00:00:56,160 --> 00:00:57,840
solving problems as they relate to


33
00:00:57,840 --> 00:00:59,520
modern app developers before we get


34
00:00:59,520 --> 00:01:01,120
started i want to give a big shout out


35
00:01:01,120 --> 00:01:03,120
to refactoring.guru they gave me


36
00:01:03,120 --> 00:01:04,960
permission to use some of their graphics


37
00:01:04,960 --> 00:01:06,799
that explain design patterns better than


38
00:01:06,799 --> 00:01:08,240
anything else out there they're based in


39
00:01:08,240 --> 00:01:09,760
ukraine and it's seriously one of the


40
00:01:09,760 --> 00:01:11,200
coolest programming websites on the


41
00:01:11,200 --> 00:01:12,720
internet design patterns are really


42
00:01:12,720 --> 00:01:14,000
interesting because they're not just


43
00:01:14,000 --> 00:01:15,840
like algorithms that you can copy and


44
00:01:15,840 --> 00:01:17,439
paste from stack overflow you actually


45
00:01:17,439 --> 00:01:19,040
need to use your brain to implement them


46
00:01:19,040 --> 00:01:20,720
it can be tempting to implement them all


47
00:01:20,720 --> 00:01:22,640
over the place but when used improperly


48
00:01:22,640 --> 00:01:24,400
they can add additional complexity and


49
00:01:24,400 --> 00:01:26,240
boilerplate to a codebase the book is


50
00:01:26,240 --> 00:01:27,520
not the bible and there are many


51
00:01:27,520 --> 00:01:29,520
criticisms of it regardless knowing how


52
00:01:29,520 --> 00:01:31,360
to recognize design patterns will help


53
00:01:31,360 --> 00:01:33,200
you level up as a programmer the first


54
00:01:33,200 --> 00:01:34,960
pattern we'll look at is singleton which


55
00:01:34,960 --> 00:01:36,799
is very easy to understand it's a type


56
00:01:36,799 --> 00:01:39,040
of object that can only be instantiated


57
00:01:39,040 --> 00:01:41,040
once in typescript we might implement a


58
00:01:41,040 --> 00:01:42,799
singleton class called settings to


59
00:01:42,799 --> 00:01:44,960
represent the global app settings data


60
00:01:44,960 --> 00:01:46,880
we'll give it a static instance property


61
00:01:46,880 --> 00:01:48,560
and then make its constructor private so


62
00:01:48,560 --> 00:01:50,079
that it cannot be instantiated with a


63
00:01:50,079 --> 00:01:52,240
new keyword we then create a static git


64
00:01:52,240 --> 00:01:54,000
instance method that will check to see


65
00:01:54,000 --> 00:01:55,680
if the instance has already been created


66
00:01:55,680 --> 00:01:57,520
and if not it will create a new one and


67
00:01:57,520 --> 00:01:59,520
that ensures that only one object can be


68
00:01:59,520 --> 00:02:01,119
created that's great and all but here's


69
00:02:01,119 --> 00:02:02,240
where things become a little more


70
00:02:02,240 --> 00:02:04,240
nuanced in javascript we have object


71
00:02:04,240 --> 00:02:06,399
literals and also the concept of global


72
00:02:06,399 --> 00:02:08,319
data and objects are passed around by


73
00:02:08,319 --> 00:02:09,920
reference we get all the same basic


74
00:02:09,920 --> 00:02:11,680
characteristics as this pattern by


75
00:02:11,680 --> 00:02:13,599
simply creating a global object the


76
00:02:13,599 --> 00:02:15,440
pattern itself is really just extra


77
00:02:15,440 --> 00:02:17,040
boilerplate that we don't need it's an


78
00:02:17,040 --> 00:02:19,040
entirely different story in c plus plus


79
00:02:19,040 --> 00:02:20,560
but the moral is to lean on your


80
00:02:20,560 --> 00:02:22,319
language's built-in features before


81
00:02:22,319 --> 00:02:24,160
implementing a fancy design pattern now


82
00:02:24,160 --> 00:02:25,760
let's take a look at the prototype


83
00:02:25,760 --> 00:02:28,000
pattern which is just a fancy word for


84
00:02:28,000 --> 00:02:29,760
clone if you've done object-oriented


85
00:02:29,760 --> 00:02:31,440
programming you should be familiar with


86
00:02:31,440 --> 00:02:33,280
inheritance where a class can be


87
00:02:33,280 --> 00:02:35,360
extended with a subclass one problem


88
00:02:35,360 --> 00:02:37,120
with inheritance is that it can lead to


89
00:02:37,120 --> 00:02:39,120
a complex hierarchy of code the


90
00:02:39,120 --> 00:02:41,040
prototype pattern is an alternative way


91
00:02:41,040 --> 00:02:42,959
to implement inheritance but instead of


92
00:02:42,959 --> 00:02:44,959
inheriting functionality from a class it


93
00:02:44,959 --> 00:02:46,640
comes from an object that's already been


94
00:02:46,640 --> 00:02:48,640
created this creates a flat prototype


95
00:02:48,640 --> 00:02:50,560
chain that makes it much easier to share


96
00:02:50,560 --> 00:02:52,560
functionality between objects especially


97
00:02:52,560 --> 00:02:54,480
in a dynamic language like javascript


98
00:02:54,480 --> 00:02:56,319
which supports prototypal inheritance


99
00:02:56,319 --> 00:02:58,319
out of the box imagine we have an object


100
00:02:58,319 --> 00:03:00,319
named zombie this is our prototype but


101
00:03:00,319 --> 00:03:02,319
now we want to create a new object based


102
00:03:02,319 --> 00:03:04,159
on it that also has a name we can do


103
00:03:04,159 --> 00:03:06,560
that with object create by passing the


104
00:03:06,560 --> 00:03:08,560
zombie as the prototype then specify


105
00:03:08,560 --> 00:03:10,480
additional properties like name for the


106
00:03:10,480 --> 00:03:12,319
new object the interesting thing is that


107
00:03:12,319 --> 00:03:14,159
if you log this object you'll only see


108
00:03:14,159 --> 00:03:16,319
the name and not the eat brains method


109
00:03:16,319 --> 00:03:18,239
however if you try to call that method


110
00:03:18,239 --> 00:03:19,760
it will still work that's because


111
00:03:19,760 --> 00:03:21,599
javascript will go up the prototype


112
00:03:21,599 --> 00:03:23,519
chain until it reaches the root looking


113
00:03:23,519 --> 00:03:25,120
for any methods or properties on the


114
00:03:25,120 --> 00:03:26,799
parent objects you can always get the


115
00:03:26,799 --> 00:03:28,640
prototype from an object by using this


116
00:03:28,640 --> 00:03:30,560
proto property however that's not a


117
00:03:30,560 --> 00:03:32,319
modern best practice and instead you


118
00:03:32,319 --> 00:03:34,720
should use object get prototype of now


119
00:03:34,720 --> 00:03:36,640
when it comes to classes in javascript


120
00:03:36,640 --> 00:03:38,879
prototype refers to its constructor and


121
00:03:38,879 --> 00:03:40,799
that means that we can extend a class


122
00:03:40,799 --> 00:03:42,560
with additional functions if we want to


123
00:03:42,560 --> 00:03:44,319
however that's also generally considered


124
00:03:44,319 --> 00:03:46,400
a bad practice now let's switch gears to


125
00:03:46,400 --> 00:03:47,680
the builder pattern imagine you're


126
00:03:47,680 --> 00:03:49,200
running a hot dog stand and when a


127
00:03:49,200 --> 00:03:50,640
customer places an order they need to


128
00:03:50,640 --> 00:03:51,680
tell you everything they want in the


129
00:03:51,680 --> 00:03:53,760
sandwich in the constructor that works


130
00:03:53,760 --> 00:03:55,120
but it's kind of hard to keep track of


131
00:03:55,120 --> 00:03:56,640
all these options and we might want to


132
00:03:56,640 --> 00:03:58,480
defer each step to a later point with


133
00:03:58,480 --> 00:04:00,319
the builder pattern we create the object


134
00:04:00,319 --> 00:04:02,239
step by step using methods rather than


135
00:04:02,239 --> 00:04:03,599
the constructor and we could even


136
00:04:03,599 --> 00:04:05,120
delegate the building logic to an


137
00:04:05,120 --> 00:04:07,120
entirely different class in javascript


138
00:04:07,120 --> 00:04:08,959
we'll have each method return this which


139
00:04:08,959 --> 00:04:10,959
is a reference to the object instance


140
00:04:10,959 --> 00:04:12,480
that allows us to implement method


141
00:04:12,480 --> 00:04:14,400
chaining where we instantiate an object


142
00:04:14,400 --> 00:04:16,160
then chain methods to it but always get


143
00:04:16,160 --> 00:04:18,079
the object as the return value you'll


144
00:04:18,079 --> 00:04:19,519
come across this pattern frequently with


145
00:04:19,519 --> 00:04:21,440
libraries like jquery but it's gone a


146
00:04:21,440 --> 00:04:23,360
bit out of style in recent years another


147
00:04:23,360 --> 00:04:25,440
pattern you may come across is factory


148
00:04:25,440 --> 00:04:26,960
instead of using the new keyword to


149
00:04:26,960 --> 00:04:29,360
instantiate an object you use a function


150
00:04:29,360 --> 00:04:31,040
or method to do it for you that may


151
00:04:31,040 --> 00:04:32,800
sound trivial but here's a practical


152
00:04:32,800 --> 00:04:34,479
example let's imagine we're building a


153
00:04:34,479 --> 00:04:36,800
cross-platform app that runs on both ios


154
00:04:36,800 --> 00:04:38,400
and android they both have the same


155
00:04:38,400 --> 00:04:40,400
interface but in our code we're doing a


156
00:04:40,400 --> 00:04:41,759
bunch of conditional checking to


157
00:04:41,759 --> 00:04:43,520
determine which button to show that's


158
00:04:43,520 --> 00:04:45,360
not very maintainable instead we can


159
00:04:45,360 --> 00:04:47,520
create a subclass or function that will


160
00:04:47,520 --> 00:04:49,440
determine which object to instantiate


161
00:04:49,440 --> 00:04:51,040
now instead of repeating the same logic


162
00:04:51,040 --> 00:04:52,800
we use the factory to determine which


163
00:04:52,800 --> 00:04:54,240
button should be rendered now we're


164
00:04:54,240 --> 00:04:55,680
ready to look at the first structural


165
00:04:55,680 --> 00:04:58,400
pattern facade a facade is the face of a


166
00:04:58,400 --> 00:05:00,080
building inside that building there's


167
00:05:00,080 --> 00:05:02,160
all kinds of shenanigans corruption and


168
00:05:02,160 --> 00:05:04,000
complexity that the end user doesn't


169
00:05:04,000 --> 00:05:06,240
need to know about a facade is basically


170
00:05:06,240 --> 00:05:08,479
just a simplified api to hide other


171
00:05:08,479 --> 00:05:10,400
low-level details in your code base


172
00:05:10,400 --> 00:05:12,080
let's imagine we have classes for the


173
00:05:12,080 --> 00:05:14,240
plumbing system and electrical system


174
00:05:14,240 --> 00:05:15,919
and inside of them we have all kinds of


175
00:05:15,919 --> 00:05:17,919
complex stuff going on like pressure and


176
00:05:17,919 --> 00:05:19,840
voltage the people living in the house


177
00:05:19,840 --> 00:05:21,360
don't need access to these low-level


178
00:05:21,360 --> 00:05:23,840
details so we create a facade class that


179
00:05:23,840 --> 00:05:25,440
contains the low-level systems as


180
00:05:25,440 --> 00:05:27,600
dependencies but then simplifies their


181
00:05:27,600 --> 00:05:29,759
operation like we might combine all the


182
00:05:29,759 --> 00:05:31,759
electrical and plumbing details into a


183
00:05:31,759 --> 00:05:34,000
single method so the end user can simply


184
00:05:34,000 --> 00:05:36,320
turn them on or off with a single method


185
00:05:36,320 --> 00:05:37,840
almost every package that you install


186
00:05:37,840 --> 00:05:39,600
with javascript could be considered a


187
00:05:39,600 --> 00:05:41,759
facade in some way like jquery is a


188
00:05:41,759 --> 00:05:43,840
great example of a facade for the more


189
00:05:43,840 --> 00:05:45,840
annoying low-level javascript features


190
00:05:45,840 --> 00:05:47,360
the next structural pattern we'll look


191
00:05:47,360 --> 00:05:49,840
at is proxy which is just a fancy word


192
00:05:49,840 --> 00:05:51,520
for a substitute like in school you


193
00:05:51,520 --> 00:05:53,199
might have a substitute teacher to


194
00:05:53,199 --> 00:05:55,120
replace the real thing in programming


195
00:05:55,120 --> 00:05:57,120
you can replace a target object with a


196
00:05:57,120 --> 00:05:59,039
proxy but why would you ever want to do


197
00:05:59,039 --> 00:06:00,960
that well a great case study is the


198
00:06:00,960 --> 00:06:03,840
reactivity system in vue.js in vue you


199
00:06:03,840 --> 00:06:05,520
create data but the framework itself


200
00:06:05,520 --> 00:06:07,600
needs a way to intercept that data and


201
00:06:07,600 --> 00:06:10,000
update the ui whenever that data changes


202
00:06:10,000 --> 00:06:11,520
the way view handles that is by


203
00:06:11,520 --> 00:06:13,360
replacing the original object with a


204
00:06:13,360 --> 00:06:15,680
proxy a proxy takes the original object


205
00:06:15,680 --> 00:06:17,600
as the first argument then a handler as


206
00:06:17,600 --> 00:06:19,440
the second argument inside of which we


207
00:06:19,440 --> 00:06:21,600
can override methods like get and set


208
00:06:21,600 --> 00:06:23,520
which allows us to run code whenever a


209
00:06:23,520 --> 00:06:25,520
property is accessed on the object or


210
00:06:25,520 --> 00:06:27,600
changed for example inside of set we


211
00:06:27,600 --> 00:06:29,360
might tell the framework to re-render


212
00:06:29,360 --> 00:06:31,360
then use reflect to update the data on


213
00:06:31,360 --> 00:06:33,440
the original object the end user can now


214
00:06:33,440 --> 00:06:35,360
work with a proxy just like the original


215
00:06:35,360 --> 00:06:37,039
object but it can trigger these side


216
00:06:37,039 --> 00:06:38,880
effects behind the scenes proxies are


217
00:06:38,880 --> 00:06:40,639
also commonly used when you have a very


218
00:06:40,639 --> 00:06:42,560
large object that would be expensive to


219
00:06:42,560 --> 00:06:44,319
duplicate in memory and now we're ready


220
00:06:44,319 --> 00:06:46,160
to look at some behavioral patterns


221
00:06:46,160 --> 00:06:48,080
starting with iterator the iterator


222
00:06:48,080 --> 00:06:50,160
pattern allows you to traverse through a


223
00:06:50,160 --> 00:06:52,240
collection of objects modern languages


224
00:06:52,240 --> 00:06:53,840
already provide abstractions for the


225
00:06:53,840 --> 00:06:55,919
iterator pattern like the for loop when


226
00:06:55,919 --> 00:06:57,680
you loop over an array of items you're


227
00:06:57,680 --> 00:06:59,759
using the iterator pattern but one thing


228
00:06:59,759 --> 00:07:01,039
that really chaps my ass about


229
00:07:01,039 --> 00:07:03,039
javascript is that there's no built-in


230
00:07:03,039 --> 00:07:04,960
range function what i wish i could do is


231
00:07:04,960 --> 00:07:07,199
easily iterate 10 times at a certain


232
00:07:07,199 --> 00:07:08,880
interval we can actually do that fairly


233
00:07:08,880 --> 00:07:11,120
easily by implementing our own iterator


234
00:07:11,120 --> 00:07:13,120
pattern in javascript you can do that by


235
00:07:13,120 --> 00:07:15,440
defining an object that has a next


236
00:07:15,440 --> 00:07:17,199
method on it that function needs to


237
00:07:17,199 --> 00:07:19,680
return an object that has a value which


238
00:07:19,680 --> 00:07:21,360
would be the current value in the loop


239
00:07:21,360 --> 00:07:23,520
and a done property so it knows when to


240
00:07:23,520 --> 00:07:25,360
finish iterating in this case we will


241
00:07:25,360 --> 00:07:27,360
keep moving on to the next step if the


242
00:07:27,360 --> 00:07:30,000
start value is less than the n value but


243
00:07:30,000 --> 00:07:32,080
for each iteration we will increment the


244
00:07:32,080 --> 00:07:34,319
start value with a step eventually the


245
00:07:34,319 --> 00:07:35,759
start will be greater than the end at


246
00:07:35,759 --> 00:07:37,680
which point we can return an object with


247
00:07:37,680 --> 00:07:40,000
the done property as true and that tells


248
00:07:40,000 --> 00:07:42,400
javascript to stop iterating now a cool


249
00:07:42,400 --> 00:07:44,400
technique here is that we can add symbol


250
00:07:44,400 --> 00:07:46,479
iterator to this object which allows us


251
00:07:46,479 --> 00:07:48,960
to use it in a regular for of loop at


252
00:07:48,960 --> 00:07:50,720
the end of the day with iteration you


253
00:07:50,720 --> 00:07:52,319
start with a collection and then write


254
00:07:52,319 --> 00:07:54,080
some code that determines how to get


255
00:07:54,080 --> 00:07:56,000
from the beginning to the end it's a


256
00:07:56,000 --> 00:07:57,599
pull based system unlike the next


257
00:07:57,599 --> 00:07:59,759
pattern we'll look at observer which is


258
00:07:59,759 --> 00:08:02,000
a push-based system the observer pattern


259
00:08:02,000 --> 00:08:04,000
allows many objects to subscribe to


260
00:08:04,000 --> 00:08:06,080
events that are broadcast by another


261
00:08:06,080 --> 00:08:08,319
object it's a one-to-many relationship


262
00:08:08,319 --> 00:08:10,080
in the real world you might have a radio


263
00:08:10,080 --> 00:08:12,080
tower that sends out a signal then a


264
00:08:12,080 --> 00:08:13,919
bunch of receivers who listen in at the


265
00:08:13,919 --> 00:08:15,680
same time this pattern is used all over


266
00:08:15,680 --> 00:08:17,360
the place in app development like in


267
00:08:17,360 --> 00:08:19,039
firebase when your data changes on the


268
00:08:19,039 --> 00:08:20,639
server all your client apps are


269
00:08:20,639 --> 00:08:22,400
subscribed to it and automatically


270
00:08:22,400 --> 00:08:24,240
updated with the latest data in our code


271
00:08:24,240 --> 00:08:26,160
here i'm going to bring in the rxjs


272
00:08:26,160 --> 00:08:28,160
library to simplify the demonstration of


273
00:08:28,160 --> 00:08:30,400
this pattern it provides a subject class


274
00:08:30,400 --> 00:08:32,159
which is the data that we want to listen


275
00:08:32,159 --> 00:08:34,159
to now once we have a subject we can add


276
00:08:34,159 --> 00:08:36,320
multiple subscriptions to it the subject


277
00:08:36,320 --> 00:08:37,279
will keep track of all these


278
00:08:37,279 --> 00:08:39,360
subscriptions and call their callback


279
00:08:39,360 --> 00:08:41,519
functions whenever the data changes


280
00:08:41,519 --> 00:08:43,039
experiment with this pattern right now


281
00:08:43,039 --> 00:08:44,800
by clicking like and subscribe on this


282
00:08:44,800 --> 00:08:46,640
video now at some later points we can


283
00:08:46,640 --> 00:08:49,040
call the next method to push a new value


284
00:08:49,040 --> 00:08:50,880
to the subject whenever that happens


285
00:08:50,880 --> 00:08:52,480
every subscription will be notified


286
00:08:52,480 --> 00:08:54,399
personally i like to think of this as a


287
00:08:54,399 --> 00:08:56,240
loop that unfolds over the dimension of


288
00:08:56,240 --> 00:08:58,480
time but now let's move on to the


289
00:08:58,480 --> 00:09:00,800
mediator pattern a mediator is like a


290
00:09:00,800 --> 00:09:02,720
middleman or broker imagine we have a


291
00:09:02,720 --> 00:09:05,040
class for airplane and runway we might


292
00:09:05,040 --> 00:09:06,720
have multiple runways and multiple


293
00:09:06,720 --> 00:09:08,640
airplanes and somehow we need to figure


294
00:09:08,640 --> 00:09:10,800
out if an airplane is clear to land on a


295
00:09:10,800 --> 00:09:12,880
given runway currently to do that all


296
00:09:12,880 --> 00:09:14,560
these objects would have to communicate


297
00:09:14,560 --> 00:09:16,560
with each other we have a many-to-many


298
00:09:16,560 --> 00:09:18,480
relationship that's very dangerous both


299
00:09:18,480 --> 00:09:20,320
in real life and in programming a


300
00:09:20,320 --> 00:09:22,720
solution is to create a mediator like an


301
00:09:22,720 --> 00:09:24,720
air traffic controller that sits between


302
00:09:24,720 --> 00:09:26,800
the runways and the airplanes to provide


303
00:09:26,800 --> 00:09:28,880
coordination and communication here's a


304
00:09:28,880 --> 00:09:31,040
more practical example in the express.js


305
00:09:31,040 --> 00:09:32,800
web framework there is a middleware


306
00:09:32,800 --> 00:09:34,800
system you have incoming requests and


307
00:09:34,800 --> 00:09:36,880
outgoing responses middleware sits in


308
00:09:36,880 --> 00:09:39,040
the middle by intercepting every request


309
00:09:39,040 --> 00:09:41,040
like an airplane and transforms it into


310
00:09:41,040 --> 00:09:43,040
the proper format for the response the


311
00:09:43,040 --> 00:09:44,959
runway it provides a separation of


312
00:09:44,959 --> 00:09:47,200
concerns and eliminates code duplication


313
00:09:47,200 --> 00:09:48,800
and that brings us to our tenth and


314
00:09:48,800 --> 00:09:50,720
final design pattern state where an


315
00:09:50,720 --> 00:09:52,480
object behaves differently based on a


316
00:09:52,480 --> 00:09:54,560
finite number of states in your code


317
00:09:54,560 --> 00:09:56,480
you've likely used conditional logic or


318
00:09:56,480 --> 00:09:58,560
switch statements to handle a bunch of


319
00:09:58,560 --> 00:10:00,320
different possibilities based on the


320
00:10:00,320 --> 00:10:02,640
state or data in your application code


321
00:10:02,640 --> 00:10:04,240
like this generally doesn't scale very


322
00:10:04,240 --> 00:10:06,240
well the state pattern allows you to


323
00:10:06,240 --> 00:10:08,399
start with one base class then provide


324
00:10:08,399 --> 00:10:10,320
it with different functionality based on


325
00:10:10,320 --> 00:10:12,480
its internal state the idea is related


326
00:10:12,480 --> 00:10:14,480
to finite state machines and libraries


327
00:10:14,480 --> 00:10:16,480
like xstate where the goal is to make an


328
00:10:16,480 --> 00:10:18,399
object's behavior predictable based on


329
00:10:18,399 --> 00:10:20,480
its underlying state in this example we


330
00:10:20,480 --> 00:10:22,160
have a human class that will think


331
00:10:22,160 --> 00:10:24,160
something different based on its mood


332
00:10:24,160 --> 00:10:25,920
currently we're doing that with a switch


333
00:10:25,920 --> 00:10:27,600
statement but another way to go about it


334
00:10:27,600 --> 00:10:29,760
would be to create a separate class for


335
00:10:29,760 --> 00:10:32,160
each possible state inside each class we


336
00:10:32,160 --> 00:10:34,000
will have an identical method that


337
00:10:34,000 --> 00:10:35,839
behaves differently now in the human


338
00:10:35,839 --> 00:10:38,160
class we set the state as a property and


339
00:10:38,160 --> 00:10:39,680
whenever that method is called we


340
00:10:39,680 --> 00:10:41,600
delegate it to its current state that


341
00:10:41,600 --> 00:10:43,200
means whenever the state changes the


342
00:10:43,200 --> 00:10:44,880
object will behave in a completely


343
00:10:44,880 --> 00:10:46,800
different way but at the same time we


344
00:10:46,800 --> 00:10:48,800
don't have to change the api or use a


345
00:10:48,800 --> 00:10:50,399
bunch of conditional logic i'm going to


346
00:10:50,399 --> 00:10:52,320
keep things simple and wrap it up there


347
00:10:52,320 --> 00:10:54,079
but remember there are a bunch of other


348
00:10:54,079 --> 00:10:55,680
design patterns out there to learn


349
00:10:55,680 --> 00:10:58,000
become a pro member at fireship io to


350
00:10:58,000 --> 00:10:59,839
learn how to apply patterns like this in


351
00:10:59,839 --> 00:11:01,839
real applications thanks for watching


352
00:11:01,839 --> 00:11:05,519
and i will see you in the next one


