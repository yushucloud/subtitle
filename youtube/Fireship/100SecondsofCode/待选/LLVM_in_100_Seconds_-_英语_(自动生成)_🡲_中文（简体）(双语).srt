1
00:00:00,160 --> 00:00:04,799
llvm a toolkit used to build and optimize compilers building a
llvm 一个用于构建和优化编译器的工具包

2
00:00:04,799 --> 00:00:08,000
programming language from scratch is hard you have humans who want to write
从头开始构建编程语言很难你有想要以简单

3
00:00:08,000 --> 00:00:11,759
code in a nice simple syntax than machines that need to run it on all
的语法编写代码的人，而不是需要在各种架构上运行它的机器 llvm

4
00:00:11,759 --> 00:00:16,720
sorts of architectures llvm standardizes the extremely complex process of turning
准化了极其复杂的转向过程

5
00:00:16,720 --> 00:00:21,119
source code into machine code it was created in 2003 by grad student chris
将源代码转换为机器代码 它由伊利诺伊大学的研究生 chris lattner 于 2003 年创建

6
00:00:21,119 --> 00:00:24,960
lattner at the university of illinois and today it's the magic behind clang
，如今它是

7
00:00:24,960 --> 00:00:30,080
for c and c plus as well as languages like rust swift julia and many others
c 和 c plus 以及rust swift julia 等语言背后的魔力，

8
00:00:30,080 --> 00:00:34,160
most importantly it represents high level source code in a language agnostic
最重要的是它代表了高级源代码 语言不可知的

9
00:00:34,160 --> 00:00:38,399
code called intermediate representation or ir this means vastly different
代码称为中间表示或 ir 这意味着

10
00:00:38,399 --> 00:00:42,960
languages like cuda and ruby produce the same ir allowing them to share tools for
像 cuda 和 ruby 这样的截然不同的语言会产生相同的 ir 允许它们

11
00:00:42,960 --> 00:00:46,960
analysis and optimization before they're converted to machine code for a specific
在转换为特定芯片

12
00:00:46,960 --> 00:00:50,719
chip architecture a compiler can be broken down into three parts the front
架构的机器代码之前共享用于分析和优化的工具编译器可以分为三部分

13
00:00:50,719 --> 00:00:54,719
end parses the source code text and converts it into ir the middle end
前端解析源代码文本并转换成ir中间 end

14
00:00:54,719 --> 00:00:59,039
analyzes and optimizes this generated code and finally the backend converts
分析和优化这个生成的代码，最后后端

15
00:00:59,039 --> 00:01:02,719
the ir into native machine code to build your own programming language from
将 ir 转换为本地机器代码，从头开始构建你自己的编程语言

16
00:01:02,719 --> 00:01:06,240
scratch right now install llvm then create a c
现在安装 llvm 然后创建一个 c

17
00:01:06,240 --> 00:01:09,600
file now envision the programming language syntax of your dreams to make
文件现在设想你梦想的编程语言语法，

18
00:01:09,600 --> 00:01:13,119
that high level code work you'll first need to write a lexer to scan the raw
使高级代码工作 您首先需要编写一个词法分析器来扫描原始

19
00:01:13,119 --> 00:01:16,560
source code and break it into a collection of tokens like literals
源代码并将其分解为一组标记，如文字

20
00:01:16,560 --> 00:01:20,720
identifiers keywords operators and so on next we'll need to define an abstract
标识符关键字运算符等接下来我们需要定义一个抽象

21
00:01:20,720 --> 00:01:24,240
syntax tree to represent the actual structure of the code and how different
语法树来表示代码的实际结构 以及不同的

22
00:01:24,240 --> 00:01:27,600
tokens relate to each other which is accomplished by giving each node its own
标记如何相互关联，这是通过给每个节点自己的

23
00:01:27,600 --> 00:01:31,759
class third we need a parser to loop over each token and build out the
第三类来完成

24
00:01:31,759 --> 00:01:35,600
abstract syntax tree if you made it this far congratulations because the hard


25
00:01:35,600 --> 00:01:39,439
part is over now we can import a bunch of llvm primitives to generate the
的 可以导入一堆 llvm 原语来生成

26
00:01:39,439 --> 00:01:43,439
intermediate representation each type in the abstract syntax tree is given a
中间表示抽象语法树中的每种类型都有一个

27
00:01:43,439 --> 00:01:48,560
method called cogen which always returns an llbm value object used to represent a
称为 cogen 的方法 它总是返回一个 llbm 值对象，用于表示

28
00:01:48,560 --> 00:01:52,079
single assignment register which is a variable for the compiler that can only
单个赋值寄存器，它是编译器的一个变量，只能

29
00:01:52,079 --> 00:01:55,600
be assigned once what's interesting about these ir primitives is that unlike
被赋值一次关于这些 ir 原语的有趣之处在于，它们与汇编不同，

30
00:01:55,600 --> 00:01:59,280
assembly they're independent of any particular machine architecture and that
它们独立于任何特定的机器架构，并且

31
00:01:59,280 --> 00:02:02,399
dramatically simplifies things for language developers who no longer need
大大简化了 由于前端可以生成 ir，因此不再需要

32
00:02:02,399 --> 00:02:05,840
to match the output to a processor's instruction set now that the front end
将输出与处理器的指令集匹配的语言开发人员的东西

33
00:02:05,840 --> 00:02:10,959
can generate ir the op tool is used to analyze and optimize the generated code
op 工具用于分析和优化生成的代码，

34
00:02:10,959 --> 00:02:14,879
it makes multiple passes over the ir and does things like dead code elimination
它在 ir 上进行多次传递并执行诸如死代码之类的操作

35
00:02:14,879 --> 00:02:18,640
and scalar replacement of aggregates and finally that brings us to the back end
聚合的消除和标量替换，最后将我们带到后端

36
00:02:18,640 --> 00:02:23,120
where we write a module that takes ir as an input that emits object code that can
，我们编写一个以 ir 作为输入的模块，该模块发出可以

37
00:02:23,120 --> 00:02:26,959
run on any architecture congratulations you just built your own custom
在任何架构上运行的目标代码 恭喜您在 100 秒内构建了自己的自定义

38
00:02:26,959 --> 00:02:30,560
programming language and compiler in 100 seconds hit the like button and
编程语言和编译器

39
00:02:30,560 --> 00:02:33,920
subscribe if you want to see more short videos like this thanks for watching and
如果您想看到更多这样的短视频，请点击“喜欢”按钮并订阅，谢谢 r 看，

40
00:02:33,920 --> 00:02:37,760
i will see you in the next one
我会在下一个看到你