1
00:00:00,199 --> 00:00:04,640
webrtc exchange real-time audio video streams with your friends
webrtc

2
00:00:04,640 --> 00:00:08,320
entirely in the browser i'm here live that's not i'm not a cat
完全在浏览器中与您的朋友交换实时音频视频流我在这里直播这不是我不是猫

3
00:00:08,320 --> 00:00:11,599
if you want to build your own video conferencing app to capitalize on the
如果您想构建自己的视频会议应用程序以利用

4
00:00:11,599 --> 00:00:14,960
work from home boom then webrtc is the api you're looking
家庭繁荣的工作那么 webrtc 是 您正在寻找的 api

5
00:00:14,960 --> 00:00:18,960
for because it allows you to establish a peer-to-peer connection between two or
，因为它允许您在两个或多个浏览器之间建立点对点连接

6
00:00:18,960 --> 00:00:21,600
more browsers where they can exchange audio video
，它们可以直接交换音频视频

7
00:00:21,600 --> 00:00:25,279
media directly without the need for a third-party server or native app
媒体，而无需第三方服务器或本机应用程序。

8
00:00:25,279 --> 00:00:28,480
it works like this the first pier will create an offer
码头将创建一个提议，

9
00:00:28,480 --> 00:00:31,599
asking for another peer to connect to them this will result
要求另一个对等方连接到它们，这将

10
00:00:31,599 --> 00:00:34,880
in an stp object or session description protocol
产生一个 stp 对象或会话描述协议

11
00:00:34,880 --> 00:00:38,000
which contains information describing the peer-to-peer connection
，其中包含描述对等连接的信息，

12
00:00:38,000 --> 00:00:42,399
like the video codec timing and so on the data will then be saved in a server
如视频编解码器时间等，然后数据将保存在 一个服务器

13
00:00:42,399 --> 00:00:45,920
where it can then be read by another peer to answer the call which is
，然后另一个对等方可以读取它以应答呼叫，这是

14
00:00:45,920 --> 00:00:50,000
achieved by creating an stp answer and writing that to the server this
通过创建一个 stp 应答并将其写入服务器来实现的。这个

15
00:00:50,000 --> 00:00:53,039
process is known as signaling and it's handled by a third
过程称为信令，它由第三方

16
00:00:53,039 --> 00:00:57,199
party server the signaling server allows the two parties to securely exchange
处理 ty server 信令服务器允许双方安全地交换

17
00:00:57,199 --> 00:00:59,680
connection data but never touches the media that's
连接数据，但从不接触

18
00:00:59,680 --> 00:01:03,359
actually transmitted between the peers but here's where things get tricky most
在对等方之间实际传输的媒体，但这就是事情变得棘手的地方

19
00:01:03,359 --> 00:01:05,920
devices in the real world sit behind firewalls
，现实世界中的大多数设备都位于防火墙后面，

20
00:01:05,920 --> 00:01:10,000
and ip addresses constantly change thanks to network address translation
并且由于网络地址转换，IP 地址不断变化

21
00:01:10,000 --> 00:01:13,520
this makes peer-to-peer connection complicated from a networking standpoint
从网络的角度来看，这使得点对点连接变得复杂，

22
00:01:13,520 --> 00:01:17,840
but luckily there's a standard called interactive connectivity establishment
但幸运的是，有一个称为交互式连接建立

23
00:01:17,840 --> 00:01:22,400
or ice which helps clients coordinate the discovery of their public-facing ip
或 ice 的标准可以帮助客户端协调其面向公众的 IP 地址的发现，

24
00:01:22,400 --> 00:01:25,520
addresses now both peers will generate a list of
现在两个对等点都将生成一个包含一个

25
00:01:25,520 --> 00:01:28,640
ice candidates which contain an ip address and port
ice 候选者的列表

26
00:01:28,640 --> 00:01:31,680
that pier 1 can use to connect to pier 2.
码头 1 可以用来连接到码头2 的 IP 地址和端口。

27
00:01:31,680 --> 00:01:36,320
in the background webrtc will do this by making a series of requests to a stun
在后台 webrtc 将通过向 stun 服务器发出一系列请求来做到这

28
00:01:36,320 --> 00:01:38,479
server a stun server is not something you need
一点 stun 服务器不是您需要

29
00:01:38,479 --> 00:01:41,520
to set up on your own because there are many free options out there
自己设置的东西，因为有很多

30
00:01:41,520 --> 00:01:45,600
from reliable sources like google each peer will save their ice candidates in
来自可靠来源（如谷歌）的免费选项，每个同行都会将他们的候选冰保存在

31
00:01:45,600 --> 00:01:48,399
the database where they can then be read by the other peer
然后其他对等方可以读取它们的数据库

32
00:01:48,399 --> 00:01:52,159
the algorithm will then automatically determine which candidate is best
然后算法将自动确定哪个候选者最好

33
00:01:52,159 --> 00:01:55,759
at which point real-time media can begin flowing between the two peers
在哪个点实时媒体可以开始在两个对等方之间流动

34
00:01:55,759 --> 00:02:00,079
this has been webrtc in 100 seconds if you want to see more short videos like
如果您想看到更多短片，这已经是 100 秒内的 webrtc像

35
00:02:00,079 --> 00:02:02,079
this make sure to hit the like button then
这样的视频一定要点击喜欢按钮，然后

36
00:02:02,079 --> 00:02:05,439
stay tuned because now we're going to build our own video chat app from
继续关注，因为现在我们要从头开始构建我们自己的视频聊天应用程序，

37
00:02:05,439 --> 00:02:07,680
scratch that may sound pretty complicated but
这听起来可能很复杂，

38
00:02:07,680 --> 00:02:10,879
the webrtc api allows all this stuff to magically
但是 webrtc api允许所有这些

39
00:02:10,879 --> 00:02:14,239
happen in the background over the next few minutes you'll build a peer-to-peer
事情在接下来的后台神奇地发生几分钟后，您将从头开始构建一个点对点

40
00:02:14,239 --> 00:02:18,080
video calling app from scratch using nothing but vanilla javascript and
视频通话应用程序，只使用香草 javascript 和

41
00:02:18,080 --> 00:02:21,680
firebase as the signalling server by the end of this tutorial you'll know
firebase 作为信号服务器到本教程结束时，您将知道

42
00:02:21,680 --> 00:02:25,520
how to implement real-time features that cater to the needs of the new work from
如何实现满足需求的实时功能 除了这个视频

43
00:02:25,520 --> 00:02:28,720
home paradigm that we live in in addition to this video you can also
，我们生活的新工作范式还可以

44
00:02:28,720 --> 00:02:31,040
reference the full article on fire ship io
参考fire ship io的完整文章

45
00:02:31,040 --> 00:02:34,239
and the source code on github let's start by taking a look at the demo
和github上的源代码让我们先来看看 演示

46
00:02:34,239 --> 00:02:38,000
we have the local user's video feed on the left side and the remote video
我们在左侧有本地用户的视频源，在右侧有远程视频

47
00:02:38,000 --> 00:02:41,840
on the right side the local user will first grant permission for the app to
本地用户将首先授予应用程序

48
00:02:41,840 --> 00:02:44,640
access the webcam that user can then create a call which
访问网络摄像头的权限，然后用户可以创建一个调用，该调用

49
00:02:44,640 --> 00:02:48,480
will write a document to firestore with the offer details
将写入一个文档到 Firestore

50
00:02:48,480 --> 00:02:52,239
at the same time we'll create a peer connection instance in the browser
同时我们将在浏览器中创建一个对等连接实例

51
00:02:52,239 --> 00:02:55,280
which handles the webrtc negotiation process
来处理 webrtc 协商过程，

52
00:02:55,280 --> 00:02:59,200
the offer will have a unique id that can then be accessed by another user
该报价将具有唯一的 ID，然后世界其他地方的另一个用户可以访问该 ID，

53
00:02:59,200 --> 00:03:02,159
somewhere else in the world that user will then join the call with
然后该用户将加入

54
00:03:02,159 --> 00:03:05,440
the unique id then establish their own peer connection
使用唯一 ID 调用，然后建立他们自己的对等连接

55
00:03:05,440 --> 00:03:08,480
and write the answer details to the same document
并将答案详细信息写入同一个文档，

56
00:03:08,480 --> 00:03:12,000
then both peers will write their ice candidates to the database we have one
然后两个对等方将他们的候选冰写入数据库 我们有一个

57
00:03:12,000 --> 00:03:16,239
sub-collection for offer candidates and another for answer candidates this
用于提供候选的子集合，另一个用于候选答案的子集合，此

58
00:03:16,239 --> 00:03:20,000
data model will allow signaling to take place between the two peers the
数据模型将允许在两个对等点之间发生信令

59
00:03:20,000 --> 00:03:23,599
data itself looks like a bunch of nonsense but what it contains is an ip
数据本身看起来像一堆废话，但它包含的是一个 IP

60
00:03:23,599 --> 00:03:27,120
address port pair that allows the two peers to establish a connection
地址端口对，它允许两者peers 建立连接，

61
00:03:27,120 --> 00:03:31,920
now both users can listen to this data in real time then use the web rtc api in
现在两个用户都可以实时收听这些数据，然后使用浏览器中的 web rtc api

62
00:03:31,920 --> 00:03:36,000
the browser to establish the connection giving us a one-to-one video chat
建立连接，为我们提供一对一的视频聊天

63
00:03:36,000 --> 00:03:39,680
feature and now we're ready to jump into our javascript code i started by
功能，现在我们准备好进入我们的 javascript 代码我首先

64
00:03:39,680 --> 00:03:43,840
creating a vanilla javascript project using a tool called veet which is a very
使用一个名为 veet 的工具创建了一个 vanilla javascript 项目，这是一个

65
00:03:43,840 --> 00:03:46,319
simple build tool developed by the vue.js guy
由 vue.js 开发人员开发的非常简单的构建工具，

66
00:03:46,319 --> 00:03:49,360
we can initialize a new project by running npm init
我们可以通过从命令行运行 npm init vjs app 来初始化一个新项目，

67
00:03:49,360 --> 00:03:54,400
vjs app from the command line basically it gives us a web project where we can
基本上它给了我们一个 web 项目，我们可以在其中

68
00:03:54,400 --> 00:03:57,519
install dependencies without having to worry about things like webpack
安装依赖项，而不必在初始化项目后担心 webpack 之类的事情

69
00:03:57,519 --> 00:04:00,640
after initializing the project we need to install firebase
，我们需要安装 firebase

70
00:04:00,640 --> 00:04:04,319
firebase contains the firestore database which we can use as our backend
firebase 包含 firestore 数据库，我们可以将其用作后端

71
00:04:04,319 --> 00:04:07,040
signaling server firebase is an exceptional choice for a
信令服务器firebase 是信令服务器的特殊选择，

72
00:04:07,040 --> 00:04:10,560
signalling server because it's easy to listen to updates to the database in
因为它很容易

73
00:04:10,560 --> 00:04:12,480
real time if we were working with a traditional
如果我们正在使用传统

74
00:04:12,480 --> 00:04:16,000
database we'd likely have to implement something like websockets to make that
数据库，我们可能必须实现类似 websockets 之类的东西才能实时收听数据库的更新 ke that

75
00:04:16,000 --> 00:04:19,680
possible and this video would be a crazy 20 minutes long or something
possible and this video will be a crazy20 minutes long or something

76
00:04:19,680 --> 00:04:23,360
from the firebase console initialize firestore in test mode
from the firebase console initializefirestore in test mode

77
00:04:23,360 --> 00:04:27,280
then create a web project from the settings panel and grab your project
然后从设置面板创建一个Web项目并获取您的项目

78
00:04:27,280 --> 00:04:30,240
credentials we can then go into the main.js file
凭据，然后我们可以进入main.js文件导入firebase

79
00:04:30,240 --> 00:04:33,360
import firebase and initialize the app with our firebase
并使用我们的 firebase 配置初始化应用程序

80
00:04:33,360 --> 00:04:37,360
config now that we have firebase set up we're going to initialize three pieces
既然我们已经设置了 firebase，我们将初始化三个

81
00:04:37,360 --> 00:04:40,720
of global state these are values you would likely want to share between
全局状态，

82
00:04:40,720 --> 00:04:45,040
multiple components if you're using a ui framework like react or angular
如果您使用像 react 或 angular 这样的 ui 框架，您可能希望在多个组件之间共享这些值

83
00:04:45,040 --> 00:04:49,120
the first and most important value is the rtc peer connection
第一个也是最重要的值是 rtc 对等连接

84
00:04:49,120 --> 00:04:52,639
this object is where all the action happens it emits a bunch of different
这个对象是所有动作发生的地方 它发出一堆不同的

85
00:04:52,639 --> 00:04:56,320
events that we can listen to to update the database and to add media
事件，我们可以监听这些事件来更新数据库并将媒体

86
00:04:56,320 --> 00:04:59,680
streams to the connection itself one very important thing it does is
流添加到连接本身它做的一件非常重要的事情 是

87
00:04:59,680 --> 00:05:03,120
generate the ice candidates but in order to do that it needs to know
生成候选冰，但为了做到这一点，它需要知道

88
00:05:03,120 --> 00:05:06,080
which stun servers to use there are many different options out
要使用哪些眩晕服务器，有很多不同的选项

89
00:05:06,080 --> 00:05:08,880
there but we're just going to use the free ones from google
，但我们只是开始 g 要使用来自 google 的免费的，

90
00:05:08,880 --> 00:05:12,080
from there we have values for local stream and remote stream
我们有本地流和远程流的值，

91
00:05:12,080 --> 00:05:15,520
which are the video streams from the webcams of each user
它们是来自每个用户的网络摄像头的视频流，

92
00:05:15,520 --> 00:05:19,520
now because we're working with vanilla js we need to use imperative dom apis
因为我们正在使用 vanillajs，我们需要使用

93
00:05:19,520 --> 00:05:23,600
we're using document git element by id to grab a bunch of elements from the
我们正在使用的命令式 dom api 通过 id 记录 git 元素以从 html 中获取一堆元素，

94
00:05:23,600 --> 00:05:26,880
html like video elements to show the actual
例如视频元素，以显示实际的

95
00:05:26,880 --> 00:05:28,960
video feeds along with buttons that provide
视频提要以及

96
00:05:28,960 --> 00:05:32,639
different interaction in the ui the first thing the user will do is click a
在 ui 中提供不同交互的按钮 用户要做的第一件事就是单击一个

97
00:05:32,639 --> 00:05:35,520
button to open up their webcam we'll go ahead
按钮来打开他们的网络摄像头 '将

98
00:05:35,520 --> 00:05:39,440
and register an event handler for the click event on the webcam button
继续为网络摄像头按钮上的单击事件注册一个事件处理程序，

99
00:05:39,440 --> 00:05:43,360
obtaining a stream from the user's webcam is very easy we just await
从用户的网络摄像头获取流非常容易，我们只需

100
00:05:43,360 --> 00:05:47,199
the navigator media devices get user media method
等待导航器媒体设备获取用户媒体方法

101
00:05:47,199 --> 00:05:51,680
and we'll set video and audio to true that'll bring up a dialog in the browser
，我们将视频和音频设置为true' 将在浏览器中弹出一个对话框，

102
00:05:51,680 --> 00:05:55,520
asking the user for permission to access the webcam when that's complete
询问用户是否允许访问网络摄像头，完成后

103
00:05:55,520 --> 00:05:59,440
the promise will resolve to a media stream object once we have access to the
，一旦我们可以访问网络摄像头，承诺将解析为媒体流对象，

104
00:05:59,440 --> 00:06:01,759
webcam we can also go ahead and set up the
我们也可以继续进行

105
00:06:01,759 --> 00:06:05,199
remote stream here which itself will just be an empty media
在这里设置远程流，它本身只是一个空的媒体

106
00:06:05,199 --> 00:06:08,319
stream now from here we need to take our two streams
流，现在从这里我们需要获取我们的两个流

107
00:06:08,319 --> 00:06:11,680
and make them available on the peer connection and show them on
，并使它们在对等连接上可用，并

108
00:06:11,680 --> 00:06:15,360
video elements in the dom the local stream is already running here in the
在本地流已经在这里运行的 dom 中的视频元素上显示它们

109
00:06:15,360 --> 00:06:18,080
browser so we can get its tracks and then loop
浏览器，这样我们就可以获取它的轨道，然后

110
00:06:18,080 --> 00:06:22,560
over them and for each track we'll call peer connection ad track with
循环它们，对于每个轨道，我们将使用该轨道和本地流调用对等连接广告轨道，

111
00:06:22,560 --> 00:06:26,319
that track and the local stream now the remote stream is currently empty
现在远程流当前是空的

112
00:06:26,319 --> 00:06:28,960
and it will be updated by the peer connection itself
，它将由对等连接本身更新，

113
00:06:28,960 --> 00:06:33,039
so what we can do is listen to the on track event on the pure connection
所以 我们可以做的是在纯连接上监听 on track 事件，

114
00:06:33,039 --> 00:06:37,440
then get the tracks from the stream loop over them and add them to the remote
然后从流循环中获取轨道，并在它们进入时将它们添加到远程

115
00:06:37,440 --> 00:06:40,240
stream when they come in now the final step for managing our
流中管理我们的流的最后一步

116
00:06:40,240 --> 00:06:44,080
streams is to apply them to video elements in the dom we can do that by
是将它们应用于视频我们可以通过

117
00:06:44,080 --> 00:06:46,800
simply calling the video element source object
简单地调用视频元素源对象

118
00:06:46,800 --> 00:06:51,039
and setting it equal to the stream at this point we have a way to manage a
并将其设置为等于流来做到这一点，此时我们有一种方法可以

119
00:06:51,039 --> 00:06:53,520
local and remote stream through the peer connection
通过对等连接管理本地和远程流，

120
00:06:53,520 --> 00:06:57,199
but in order to make that happen we need to do some signaling with firestore
但是在 为了做到这一点，我们需要用firestore做一些信号 发起

121
00:06:57,199 --> 00:07:01,199
the user who starts a call is the one who makes an offer we have a call button
呼叫的用户是提出要约的人 我们在dom中有一个呼叫按钮

122
00:07:01,199 --> 00:07:03,840
in the dom to handle that functionality inside this
来处理这个

123
00:07:03,840 --> 00:07:07,039
async function here we have a call document which is used to
异步函数中的功能 这里我们有一个呼叫文档，它是 用于

124
00:07:07,039 --> 00:07:10,000
manage the answer and offer from both users
管理来自两个用户的答案和提议

125
00:07:10,000 --> 00:07:14,000
then we have offer candidates and answer candidates which are sub collections
然后我们提供候选人和答案候选人，它们是

126
00:07:14,000 --> 00:07:17,039
under that document that contain all the candidates for each
该文档下的子集合，其中包含每个用户的所有候选人

127
00:07:17,039 --> 00:07:20,000
of those users when we reference a document without an
当我们引用没有 id 的文档时，

128
00:07:20,000 --> 00:07:23,599
id firebase will automatically generate a random id for
firebase 将自动生成一个随机 id 对

129
00:07:23,599 --> 00:07:27,360
us so we'll go ahead and use that to populate an input in the ui
我们来说，所以我们将继续使用它来填充 ui 中的输入，

130
00:07:27,360 --> 00:07:30,960
which can then be used in another browser tab or by another user somewhere
然后可以在另一个浏览器选项卡中使用该输入，或者由世界其他地方的另一个用户使用

131
00:07:30,960 --> 00:07:35,039
else in the world to answer the call now we're ready to create an offer and
来接听电话，现在我们已准备好创建报价和

132
00:07:35,039 --> 00:07:39,080
save it to the database the first thing we'll do is await the
将其保存到数据库中，我们要做的第一件事是等待

133
00:07:39,080 --> 00:07:42,479
peerconnectioncreateoffer method which will return us with an offer
peerconnectioncreateoffer 方法，该方法将返回我们的报价

134
00:07:42,479 --> 00:07:46,400
description we'll then set it as the local description on the peer connection
描述，然后我们将其设置为对等点的本地描述 nnection

135
00:07:46,400 --> 00:07:49,680
most importantly this object contains an sdp value
最重要的是，该对象包含一个sdp 值

136
00:07:49,680 --> 00:07:53,520
which stands for session description protocol that's the value we want to
，它代表会话描述协议，这是我们要

137
00:07:53,520 --> 00:07:56,879
save to the database so we'll go ahead and convert it to a plain
保存到数据库的值，因此我们将继续将其转换为纯

138
00:07:56,879 --> 00:08:00,800
javascript object then write it to the database by calling await
JavaScript 对象，然后通过调用 await

139
00:08:00,800 --> 00:08:04,720
call document set with that data now what's inside the sdp
调用文档将其写入数据库 现在使用该数据设置sdp 对象内部的

140
00:08:04,720 --> 00:08:08,240
object isn't really important but it contains information about the video
内容并不重要，但它包含有关视频

141
00:08:08,240 --> 00:08:10,319
codec along with a bunch of other stuff to
编解码器的信息以及用于协商连接的其他一些内容，

142
00:08:10,319 --> 00:08:13,840
negotiate the connection now one really important thing to point out here
现在需要指出的一个非常重要的事情

143
00:08:13,840 --> 00:08:17,759
is that when we called set local description it automatically started
是，当我们调用 set local描述它自动开始

144
00:08:17,759 --> 00:08:22,000
generating the ice candidates an ice candidate contains a potential ip
生成候选冰候选冰包含一个潜在的IP

145
00:08:22,000 --> 00:08:25,440
address and port pair that can be used to establish the actual
地址和端口对，可用于建立实际

146
00:08:25,440 --> 00:08:28,080
peer-to-peer connection we need to be listening to the ice
的点对点连接我们需要监听

147
00:08:28,080 --> 00:08:31,520
candidates so it's important that we have a listener established before we
候选冰所以重要的是我们有一个监听器 在我们

148
00:08:31,520 --> 00:08:34,560
make that call that listens to the on ice candidate
发出监听 on ice 候选

149
00:08:34,560 --> 00:08:37,360
event when the event is fired we'll make sure that a candidate
事件的调用之前建立，当事件被触发时，我们将确保一个候选

150
00:08:37,360 --> 00:08:41,919
exists then write the data as json to the offer candidates collection
前 然后将数据以 json 格式写入报价候选集合，

151
00:08:41,919 --> 00:08:46,160
so at this point as the caller making the offer we are saving all of our data
因此此时作为提供报价的调用者，我们将所有数据保存

152
00:08:46,160 --> 00:08:49,360
to the database but now we need to also be listening for
到数据库中，但现在我们还需要听取

153
00:08:49,360 --> 00:08:51,760
the answer from the user on the other end
另一端用户的回答

154
00:08:51,760 --> 00:08:55,360
the way we do that is by listening to changes to the called document in
我们这样做的方法是通过监听

155
00:08:55,360 --> 00:08:58,080
firestore the on snapshot method will fire a
firestore 中被

156
00:08:58,080 --> 00:09:01,200
callback anytime the document in the database changes
调用文档的更改，

157
00:09:01,200 --> 00:09:04,240
if our peer connection doesn't have a current remote description
如果我们的对等连接没有当前的远程描述

158
00:09:04,240 --> 00:09:08,000
and the data has an answer then we'll go ahead and set an
并且数据有答案，那么只要数据库中的文档发生更改，on snapshot 方法就会触发回调 我们将继续在本地设置

159
00:09:08,000 --> 00:09:11,519
answer description on our peer connection here locally
对等连接的答案描述，

160
00:09:11,519 --> 00:09:14,880
in other words we're listening to our database for an answer and when that
换句话说，我们正在收听我们的数据库以获取答案，当

161
00:09:14,880 --> 00:09:18,080
answer is received we update it on our peer connection
收到该答案时，我们在协商初始连接的对等连接上更新它，

162
00:09:18,080 --> 00:09:21,680
that negotiates the initial connection but we also need to listen for ice
但我们也 需要

163
00:09:21,680 --> 00:09:24,959
candidates from the answering user we do that by listening to
从回答用户那里收听冰候选我们通过收听

164
00:09:24,959 --> 00:09:28,640
updates to the answer candidates collection firestore has a cool little
候选答案集合的更新来做到这一点 Firestore 有一个很酷的小

165
00:09:28,640 --> 00:09:32,240
feature where you can listen to only the documents that have been added
功能，您只能在其中收听已添加

166
00:09:32,240 --> 00:09:36,160
to the collection which is handled with the doc changes method on the query
到集合中的文档由查询中的 doc changes 方法处理，

167
00:09:36,160 --> 00:09:40,480
so every time we have a new document added we can then create a new ice
因此每次添加新文档时，我们都可以使用文档数据创建一个新的 ice

168
00:09:40,480 --> 00:09:44,800
candidate with the document data and then add that candidate to our peer
候选者，然后将该候选者添加到我们的对等

169
00:09:44,800 --> 00:09:47,360
connection at this point we're listening to updates
连接在这一点上，我们正在收听

170
00:09:47,360 --> 00:09:51,440
from the answer side but we still need to give the answer and user a way to
来自应答端的更新，但我们仍然需要给答案和用户一种

171
00:09:51,440 --> 00:09:55,279
actually answer the call answering a call is very similar to initiating a
实际接听电话的方式 接听电话与发起呼叫非常相似，

172
00:09:55,279 --> 00:09:57,279
call the main difference is that we're going
主要区别在于我们

173
00:09:57,279 --> 00:10:01,279
to listen to a document in firestore with the same document id that was
将 在firestore中收听与调用者创建的具有相同文档ID的文档，

174
00:10:01,279 --> 00:10:04,240
created by the caller we'll make a reference to that document
我们将引用该文档

175
00:10:04,240 --> 00:10:07,920
as well as the answer candidates collection then listen to the ice
以及候选答案集合，然后

176
00:10:07,920 --> 00:10:12,079
candidate event on the peer connection to update the answer candidates
在对等连接上收听ice候选事件以更新候选答案

177
00:10:12,079 --> 00:10:16,560
collection whenever a new candidate is generated from there we can fetch the
集合 每当从那里生成新的候选人时，我们都可以

178
00:10:16,560 --> 00:10:20,480
call document from the database and grab its data it contains the offer
从数据库中获取呼叫文档并获取其数据，其中包含

179
00:10:20,480 --> 00:10:24,560
data which we can use to set a remote description on the peer
我们可以用来设置远程描述的报价数据 n 在对等

180
00:10:24,560 --> 00:10:28,320
connection after that we can then generate an answer locally
连接上之后，我们可以在本地生成一个答案，

181
00:10:28,320 --> 00:10:30,959
then set the local description as the answer
然后将本地描述设置为

182
00:10:30,959 --> 00:10:34,720
now just like we did with the offer in the previous function we'll set it up as
答案，就像我们在前一个函数中对报价所做的那样，我们将其设置为

183
00:10:34,720 --> 00:10:38,320
a plain object and then update it on the call document
一个普通对象，然后在 调用文档，

184
00:10:38,320 --> 00:10:40,880
so that the other user can listen to the answer
以便其他用户可以收听

185
00:10:40,880 --> 00:10:44,560
in addition we'll set up a listener on the offer candidates collection
答案此外，我们将在提议候选集合上设置一个侦听器

186
00:10:44,560 --> 00:10:48,000
and whenever a new ice candidate is added to that collection
，每当向该集合添加新的冰候选时，

187
00:10:48,000 --> 00:10:51,279
then we'll go ahead and create an ice candidate here locally
我们将继续在本地创建一个冰候选

188
00:10:51,279 --> 00:10:55,040
and that's all it takes to build a video chat feature with webrtc
这就是使用 webrtc 构建视频聊天功能所需要的全部

189
00:10:55,040 --> 00:10:59,040
the vast majority of the work is just signaling data between the two users
工作绝大多数工作只是在两个用户之间发送信号数据

190
00:10:59,040 --> 00:11:02,959
webrtc handles all the complicated peer-to-peer networking and media
webrtc 处理所有复杂的点对点网络和媒体

191
00:11:02,959 --> 00:11:05,519
streaming under the hood i'm going to go ahead and wrap things up
流

192
00:11:05,519 --> 00:11:08,079
there if this video helped you please like and subscribe
如果此视频对您有帮助，

193
00:11:08,079 --> 00:11:11,440
and if you want to learn more advanced concepts about the web and firebase
请提前并

194
00:11:11,440 --> 00:11:14,320
consider becoming a pro member at fireshipio


195
00:11:14,320 --> 00:11:20,000
thanks for watching and i will see you in the next one
总结一下 我会在下一个见到你