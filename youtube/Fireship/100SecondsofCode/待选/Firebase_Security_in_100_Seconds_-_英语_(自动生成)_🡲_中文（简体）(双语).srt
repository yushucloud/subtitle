1
00:00:00,399 --> 00:00:03,919
firebase security when you build a firebase app you can perform user
firebase 安全性 当您构建firebase 应用程序时，您可以完全从前端代码执行用户

2
00:00:03,919 --> 00:00:06,640
authentication and work with your database entirely
身份验证并使用您的数据库

3
00:00:06,640 --> 00:00:10,000
from your front-end code but how is this possible if our database
，但是如果我们的

4
00:00:10,000 --> 00:00:13,280
is exposed on the client wouldn't that mean that any hacker could then read or
数据库暴露在客户端上，这怎么可能，这并不意味着任何黑客都可以读取或

5
00:00:13,280 --> 00:00:15,839
write private user data the answer is no because your
编写私人用户数据 答案是否定的，因为您的

6
00:00:15,839 --> 00:00:19,279
infrastructure is protected by a mechanism known as firebase security
基础架构受到称为 firebase 安全规则的机制的保护，

7
00:00:19,279 --> 00:00:21,680
rules which can be applied to real-time database
该机制可应用于实时数据库

8
00:00:21,680 --> 00:00:25,439
cloud storage and firestore in a traditional web application you have a
云存储和传统 Web 应用程序中的 firestore 您在该

9
00:00:25,439 --> 00:00:27,840
server on that server you implement security
服务器上有一个服务器 您实现了安全

10
00:00:27,840 --> 00:00:32,480
logic that uses either tokens or cookies to verify that a user making a request
逻辑 它使用令牌或 cookie来验证发出请求的用户是否

11
00:00:32,480 --> 00:00:36,320
is authorized to do so firebase rules achieve the same thing but without the
被授权这样做，firebase 规则可以实现相同的目的，但

12
00:00:36,320 --> 00:00:39,600
need to write maintain and deploy server-side code
无需编写维护和部署服务器端代码，

13
00:00:39,600 --> 00:00:43,120
instead you create a policy to define who has access to what
而是创建一个策略来定义谁有权访问什么

14
00:00:43,120 --> 00:00:47,039
in your database using a very easy to learn language called common expression


15
00:00:47,039 --> 00:00:49,600
language whenever a user makes a request to read
每当用户请求读取

16
00:00:49,600 --> 00:00:52,879
or write to your database that request is routed through this policy
或写入您的 d 数据库该请求通过此策略路由

17
00:00:52,879 --> 00:00:56,320
every operation is denied by default when a request comes in
，默认情况下，每个操作都被拒绝当请求进入时

18
00:00:56,320 --> 00:01:00,079
it will look for the first rule to allow it once allowed firebase can then
，它将寻找第一个规则以允许它一旦允许 firebase 然后可以

19
00:01:00,079 --> 00:01:03,440
securely read or write to your database you can write rules from the firebase
安全地读取或写入您的数据库您可以从 firebase 控制台编写规则

20
00:01:03,440 --> 00:01:07,600
console or your ide in the console you can time travel back to any previous
或 您在控制台中的 ide您可以时间旅行回到

21
00:01:07,600 --> 00:01:11,520
rules you've used in the past or use the playground to send a mock request to
您过去使用过的任何以前的规则，或者使用操场向您的数据库发送模拟请求

22
00:01:11,520 --> 00:01:14,000
your database and in production you can analyze
，在生产中您可以

23
00:01:14,000 --> 00:01:16,159
exactly how your rules are being executed
准确分析您的规则是如何执行的

24
00:01:16,159 --> 00:01:19,680
to enforce a rule we start by matching a path in the database
以强制执行规则 我们首先匹配数据库中的路径，该路径

25
00:01:19,680 --> 00:01:23,200
which can be as broad as the entire database or as granular as a single
可以与整个数据库一样广泛，也可以与单个

26
00:01:23,200 --> 00:01:25,759
document a single document can be matched with a
文档

27
00:01:25,759 --> 00:01:29,920
collection followed by a document id if we want anybody to read and write to
一样细化

28
00:01:29,920 --> 00:01:32,640
this document we can say allow read and write
我们可以说允许读写，

29
00:01:32,640 --> 00:01:36,640
but that's not very secure let's make sure a user is logged into our app to
但这不是很安全让我们确保用户登录到我们的应用程序以

30
00:01:36,640 --> 00:01:39,280
view the document which we can do by writing conditional
查看文档，我们可以通过编写

31
00:01:39,280 --> 00:01:43,280
logic we allow the operation if the request auth object does not
允许操作的条件逻辑来完成如果在写入时请求身份验证对象不

32
00:01:43,280 --> 00:01:45,759
equal null when it comes to writes we can make sure
等于 null，我们可以

33
00:01:45,759 --> 00:01:49,200
only the user that owns the document can write to it by checking the request
确保只有拥有文档的用户才能通过检查请求

34
00:01:49,200 --> 00:01:53,040
auth user id in most cases though you'll want your rules to apply to an entire
身份验证用户 ID 来写入它，尽管您希望您的规则适用于 整个

35
00:01:53,040 --> 00:01:55,840
collection if we wrap the document id in braces the
集合如果我们将文档 ID 包装在大括号中，则

36
00:01:55,840 --> 00:01:59,439
rule now applies to any document in that collection and we can use the document
规则现在适用于该集合中的任何文档，我们可以

37
00:01:59,439 --> 00:02:01,920
id as a variable in our logic and now we
在逻辑中使用文档 ID 作为变量，现在我们

38
00:02:01,920 --> 00:02:06,079
have a firebase app that's 100 secure without any vulnerabilities whatsoever
有一个 100 安全的 Firebase 应用程序，没有任何漏洞，

39
00:02:06,079 --> 00:02:09,759
but there's a lot more to learn consider becoming a pro member at fireship io to
但是有 还有很多要学习的考虑成为 fireship io 的专业会员，

40
00:02:09,759 --> 00:02:13,200
get access to the new firebase security master course where you'll learn all
以访问新的 firebase 安全大师课程，您将在其中学习

41
00:02:13,200 --> 00:02:16,080
kinds of advanced techniques for real-world applications
各种用于实际应用的高级技术

42
00:02:16,080 --> 00:02:21,680
thanks for watching and i will see you in the next one
感谢观看，我们下期再见