本课程将帮助您了解实现图算法并使用它们

来解决编码挑战所需的知识。  Alvin 的动态编程课程是我们频道上最受欢迎的

课程之一。 现在他又回来教你图算法了。 嘿，程序员，

我是 Structy 的 Alvin。 欢迎来到我们的图表课程。 特别是，这

将是关于你的技术面试的图表。当然，在那些技术面试中，图表是一个非常常见的话题

。特别是，我想在

整个课程中强调的是，

在那些技术面试中一次又一次出现的少数模式。 在大约两个半小时内，我将为

您提供基本涵盖所有图形问题所需的所有工具。我会说大约 80% 的图形问题。

所以我为这门课程准备的东西，嗯，我认为你的数据结构

和算法，尤其是你的图表，取胜的关键是可视化事物，对吧。 所以我们

要做的是追踪很多不同的算法，并确保

在高层次上理解它们。 这意味着在这里要通过不同的动画，我认为图表

作为一个困难的话题有一个相当糟糕的说唱。 因为对于初学者来说，你可以

围绕一个问题有非常非常不同的叙述，并且并不真正理解。 它们都是

基于图的前提。 所以我们会意识到，一堆不同的东西可以

被理解为图表。 因此，当谈到本课程的先决条件时，我

将假设您对图表一无所知。但是你确实知道如何编码，对，所以

我希望你理解一些递归。 因此，当您完成

课程并了解不同的图形模式时，我们将使用这些模式来解决

一些关于图形的非常经典的面试问题，对吧。 我会给你

很多机会在不同的问题中练习这些模式，

只要你在技术面试中遇到它们，我们就会准备好。我喜欢图这个话题的地方在于

使用了一些不同的算法，你可以涵盖大多数图问题，

对吧。 对于我们涉及的每个图形问题，我们将把它分成两部分，第一

部分是关于视频的方法。 因此，我们将回顾

战略和总体理论，并确保勾勒出一幅漂亮而有意义的画面。 我们

还将在方法视频中讨论算法的复杂性。 遵循

每一种方法，我们当然也将实现代码，我将

用 JavaScript 编写我所有的代码，你将能够使用任何你喜欢的语言来跟随。

所以这意味着偶尔我会切换到我的代码编辑器，你当然可以

跟随。 我们还将确保在描述中提供链接以及

在屏幕上提供链接。 这样，您以前就可以阅读每个问题的提示，以及

查看不同的测试用例。 好吧，我想这已经足够介绍了。 现在，

让我们直接进入课程。 好吧，程序员。 所以让我们直接进入

课程，我想首先给你一些关于你的图表的背景，我们

将回顾你在技术面试中开始解决问题所需的图表基础知识

。 那么首先，什么是图表？图实际上只是节点

和边的集合。 因此，对于节点，您可以将它们可视化为通常只是一些

圆圈，其中包含一些数据。 所以我会在这里的节点中放一些字母值。

当我们提到边时，这只是节点之间的任何连接。

例如，如果A 和 C 之间有联系，它看起来像这样，

对吧？ 我可以正式说的是A 和 C 之间有一条边，我可以

在该图中我想要的任何节点之间创建许多边。 在

描述节点时，您可能会在野外听到另一个词，就像您可能听到使用的词顶点一样，

对，它们实际上是同一回事。 在本课程中，我将坚持使用节点一词。 一条

边只是一对节点之间的连接。 这实际上是

一个高层次的图，有趣的是我们如何使用这个图框架来

实际解决问题，对吧。 因此，如果您将这些节点视为事物，而将

边视为关系，那么图形就是描述事物之间关系的网格。 例如，

我们可以说这里的节点是城市，边是连接城市的道路

，类似地，也许我们这里的节点是课程，然后边代表

先决条件。 因此，在未来，我们将使用图表来说明

和构建一些叙述性问题。 让我们谈谈这个图表。 特别是这里，我

真的画了一个有向图。 那是因为我在边缘有一些箭头。 这

将是与无向图的比较。所以在这里，我的结构实际上是相同的，

只是我这里的边缘没有任何箭头。 这意味着它没有

正确的方向性。 如果我查看有向图，假设我在节点

A，那么我可以前往 B 或 C，假设我移动到 C。但是，一旦我在 C，我

就无法前往 a， 我只能前往E，对吧？ 那是因为我必须服从

这里箭头的方向。 看看我的无向图，假设我目前

位于这里的现场，我确实可以选择前往 a 或

E，对吗？ 所以如果我去了a，那很好，我什至可以回到C。所以

把一个无向图想象成一条双向街道。现在我们将继续我们的定向

版本。 让我还介绍一些有用的术语，我们可以在讨论

图中的节点时使用。 如果我当前位于此节点，我可以将 B

和 C 称为邻居节点。 好的，所以邻居节点实际上是可以

通过边缘访问的，当然，服从边缘的方向。 换句话说，如果我当前

位于海节点，那么我只有一个 E 的邻居，对，如果我在海中，

你知道，那么我不会考虑邻居。惊人的。 当你可视化图形算法时，

你真的应该画一张看起来像这样的图片，在这里，将节点

作为圆圈和箭头作为你的边缘。然而，当谈到我们如何

在一些代码中实现这个算法时，我们将不得不以一种更加程序化的方式来表示它。

正确的？ 所以在我的大脑中，我想到了这个节点和它们之间的箭头的图像。 但是，

在我的程序中，我将通常使用邻接表，这可能是我们

表示和绘制信息的首选方式，对吧。因此，根据

我们通常要使用的编程语言的选择，我们将使用一些哈希映射数据结构来

表示邻接列表。 真的，我们期待使用一些常数时间，我会查找

具有键值对映射的数据结构，对吧。 所以如果你在 JavaScript 中，它们将

是一个对象，如果你在 Python 中，它们将是一个字典。 如果您使用

Java 或 C 等语言，您将使用无序映射。看看这个哈希图，我已经绘制了

这个邻接列表，这个邻接列表的键将是我图中的每个节点，

对，所以我只是将所有节点值A 到 F 布置为键。 但是，

如果您查看相应的值，这些值实际上将是一个数组，

对吗？ 因此，如果我查看第一个条目，它表示我有一个节点 a，然后在

填充的数组中，所有邻居都有 a，即 a 有两个邻居有 BNC。

这就是为什么我在我的邻接列表中有这个通信。 这适用

于我的邻接列表中的每个条目。 例如，假设查看 e 的条目。 所以我

去现场并列出关键是 E 的 j c 列表，它只有一个出边。

这就是为什么他的阵列只有在里面。 还要注意的一件事是，即使一个

节点没有邻居，它仍然应该作为我的邻接列表中的键出现。 例如，

如果您查看 D，节点 D 没有出边。 这就是为什么它的邻居数组是空的。

但是，它至少应该仍然作为我的邻接列表中的键出现，对，

这样，您仍然可以知道 D 节点存在。所以在课程开始时，通常

会以邻接表作为信息来表示一个图，对吧。 但是当

我们在白板上画草图时，我们应该使用像这样的漂亮图片来可视化它们

。 惊人的。 所以让我们真正进入我们的第一对算法。 对我来说，必须

知道的图算法实际上是对其进行某种遍历。

我们为什么不从深度优先遍历开始，你

之前可能听说过，对，现在我们将讨论对图进行操作的深度优先遍历算法

。 因此，让我们首先从高层次了解

深度优先遍历会给您带来什么顺序。假设我有一些起始节点，我将

选择 a 作为起始节点，对，所以我将这里用黄色着色。 如果我

遵循深度优先遍历。 现在我已经选择了作为起点，我可以按

B 或 C。接下来，我将承诺使用 B。所以假设我的序列

到目前为止有一个逗号 b。 在这一点上，如果我真的遵循深度优先遍历，

我必须深入到 D 节点。 也就是说，我还没去C节点。 很酷，那

将是真正的深度优先遍历，对吧。 在这一点上，现在我已经在

D 触底，D 是死胡同，对吧？ 我不能从 D 到 F，因为那会

违反箭头。 所以现在我可以移动到C 的另一个邻居。从这里开始，算法

将继续，对，我从 C 到 E，然后从 e 到 B。从技术上讲，我

必须双重遍历一些节点，比如 B 和D在这里。 所以总的来说，在这个黄色着色中，

我已经为深度优先遍历将从

一个通知开始探索的整个区域着色，如果你从 a 开始，就不可能到达 F。

这很正常，对吧？ 这就是为什么我们使用这些遍历算法来告诉您

是否可以在某些节点之间旅行的原因。 我们稍后会看到这个字面问题

。 正确的？ 所以你可能想知道，你知道，我们究竟如何实现这一点，

但现在，我只想专注于我们得到的顺序，对吧。 所以就

我们的深度优先遍历而言，我们记得算法的前三个迭代，我们

击中了 B、D 的序列，对，这表示深度优先遍历。 现在

让我们将其与广度优先的 Marion 进行比较。所以我要绘制相同的精确图，

我们还要在 a 节点处开始遍历，但这次遵循广度优先

顺序。 所以我有一个第一个，假设你知道，当涉及到广度优先遍历时，我选择 B 作为我的下一个节点

。 不管你选择哪个，你知道，最初的邻居

，所以我只会选择 B。但是现在我选择了 B，如果我遵循真正的

广度优先遍历，我接下来必须点击 c，正确的。 这就是同一张图

的深度优先和广度优先反转之间的主要区别，我的深度优先会

从 B、D 开始，而我的广度优先会从a、b、c 开始。 所以你可能想知道，

这种细微差别之间有什么重要性吗？ 我什么时候更喜欢深度优先而不是

广度优先，反之亦然？ 深度优先或广度优先遍历将探索图

中相同的确切节点。 但是，它会以不同的顺序探索它们，

对吧？ 当我们有一个更大的图和更多的边时，这一点就更明显了。

因此，让我们看看他如何再次进行深度优先遍历，但这次是在一个更大的

图表上，让我们来看看这个。 所以我要选择一些随机节点作为

起点，假设我选择了黄色的这个节点，这是进行深度优先遍历，

我要做的是，你知道的，选择一个方向并进入

在切换方向之前尽可能同一个方向。 那么假设我向右移动，此时，

我必须继续向右移动，直到我不能再向右移动

，此时我必须选择一些新的方向，比如说 是向下的。 我会

一直这样做，直到我不能再向下移动。 所以我现在必须向左移动

，现在我将继续朝着非常深的方向追逐这条单一的道路。 所以这

是深度优先遍历的行为，对，你

在切换方向之前尽可能地探索一个方向。 让我们将其与广度优先遍历进行比较。 所以

假设从粉红色的同一个节点开始，如果我遵循广度优先遍历，它

看起来像这样。 从起点开始，我会探索

这个节点的所有直接邻居，有点像这样的圆圈。 现在我只是继续应用这种行为。

因此，当您注意到广度优先遍历时，它是否会倾向于均匀地探索所有方向

，对，而不是一直偏爱一个方向。 这实际上

是深度优先和广度优先遍历之间的唯一区别。 在

课程的稍后部分，我将提出明确的问题，您可能更喜欢其中一个。 好吧，

但是现在，我想做的是给你所有你需要的背景。 所以你实际上可以

构建这个算法，在高层次上讨论一些事情，把它

当作伪代码，然后，当然，我们稍后会用一些 JavaScript 代码来表达它。 因此，

当涉及到在代码中实际实现这两种算法时，关键是要

了解深度优先遍历使用堆栈，而广度优先遍历使用队列，请

记住堆栈是您添加到顶部的东西 也从顶部移除

，或者 Q 是你添加到后面并从前面移除的东西，

它给你两个非常不同的顺序。这实际上是这两种算法之间的唯一区别

。 因此，让我们从跟踪深度优先遍历开始，当然，

使用堆栈，所以我将使用稍微不同的图。 为了可视化我的堆栈，

我将使用这个条来表示堆栈的底部，显然，对我来说，

至少我认为堆栈是一些垂直的数据结构。 凉爽的。 所以假设我只是

随意选择了一个作为我的起始节点来执行我的深度优先遍历，对，

从长远来看，只是想打印出这个图中所有不同的节点值。 所以

我要做的是，我将获取我的起始节点 a，我将立即将

它初始化到我的堆栈中。 所以现在作为我堆栈中唯一的东西，它也在我堆栈的顶部

。 而现在我可以在这里进入主算法的流程了，因为我有一个

栈，我唯一能做的就是移除我的栈顶。 所以这意味着我

从堆栈中弹出 a ，并考虑 a 节点，我正在查看当前节点，对吗？ 此时，

假设我将 a 打印到控制台。从这里开始，我想做的是考虑 A 的

邻居，对。 所以如果我看C节点，我应该做的就是将c推入堆栈，

然后将B也推入堆栈，对吧。你按什么顺序

推动这些邻居并不重要。 如果我想让它先击中B，那么我会第二次推他们，

对吗？ 惊人的。 这将像我对深度优先遍历的第一次迭代一样结束。 凉爽的。

所以此时，我可以查看我的堆栈，我的堆栈上仍然有一些数据。 所以

我应该做的是再次弹出我的堆栈顶部。所以我要弹出并离开我的堆栈。

这成了我现在的样子，我也要把它打印出来。 此时，我查看 B 的

邻居，B 有一个 D 的邻居，所以我将 d 推到堆栈的顶部。 请注意，

因为我有一个堆栈 D 最终位于 C 的顶部，对。 所以现在当我进行另一个

迭代时，当我弹出堆栈的顶部时，我将 D 节点视为我的当前节点，对

，我可以打印出 D。这感觉很好，因为到目前为止，我的打印顺序会 成为

BD，请注意，我有点追随 BD 的单一路径。 但是我必须

查看 DS 邻居，我可以取 f并将 f 推到我的堆栈顶部。 下一次迭代，

我的堆栈仍然是空的。 所以我应该做的是弹出顶部的 F 现在是我当前的，我可以

打印出 F，但 f 没有邻居。 所以F 不会将其他任何东西推到

堆栈的顶部。 正确的？ 在这一点上，我到达了下一个通道，并且我弹出了堆栈的顶部

。 这意味着 C 现在是我的当前值，我可以打印出 CS 值。 然后我可以

看看苏的邻居。 我只是将 e 推到我的堆栈顶部。 在最后一次迭代中，我

弹出了我的堆栈，他现在是我的当前我打印出他，因为他没有邻居，

我没有将其他任何东西推到我的堆栈顶部。 在这一点上，我已经达到

了我的堆栈为空的状态。 这意味着我的算法是正确的，这意味着你

在你的图表中尽可能地探索。请注意，您可能不一定

能够点击图表的每个节点。 这个特殊的例子

是可能的，太棒了。 因此，让我们使用广度优先算法重做该跟踪，

这意味着我们只需稍微调整一下。我们使用队列顺序。 请记住，

队列是先进先出的数据结构，这意味着事物从后面进入，

然后从前面离开。 所以假设我用这个箭头来表示

我的队列的方向性，对吧。对于广度优先遍历，我以同样的方式启动算法。

假设我希望它从节点 A 开始。所以我只是用酷初始化我的队列，所以

我从删除队列的前面开始。所以 a 成为我当前的节点，我也可以打印

出 a 。 现在我考虑 A 的邻居，对。 所以我考虑 B 和 C。如果我想

在 C 之前前往 B，那么我应该先将 B 推到我的队列中，对，所以我将 B 添加到

队列的后面，对。 而且我还应该将 c 添加到队列的后面，对。

这实际上会结束我的第一次迭代。所以现在我看看我的队列上还有一些

东西。 所以我删除了队列的前面，这意味着 B 成为我当前的。 当然，

我打印出 B。现在我考虑 B 的邻居。所以我只看 D 节点，我将 d 推

到队列的后面，因为 D从后面进入并最终在 C 后面，这是

非常重要的行为。 下一次迭代，我删除了队列的前面。 所以我的当前

是see，对，我可以打印出see，然后looks只看到E的邻居，

我把e加到队列的后面，也就是说按照我的队列顺序，他最后在

后面 在我的下一次迭代中，我从队列中删除了 D，并将 F 的编辑

邻居打印到队列的后面。 下一次迭代，我从队列的前面删除了 e

，打印出来。 由于他没有邻居，他不会在队列后面添加任何其他内容

。 当然，最后，f 离开了我的队列的前面，我打印出

F，F 没有邻居，此时我的队列完全是空的。 由于我们的队列

是空的，这将是我们算法的结束。好的，这就是我们的深度

优先和广度优先算法的全部内容，它们将成为我们

用来解决许多不同图形问题的很好的基线代码。我认为这是足够的理论。 现在，

我想做的是切换到我的代码编辑器，在那里你可以在 JavaScript 中实际实现这些

，嘿，程序员，我在我的编辑器中，我现在想做的是向你

展示如何实现这些深度 第一和广度优先算法。 所以我们先从

深度开始。 我的目标实际上只是构建一个函数，它会

根据深度优先遍历在图中打印出我的所有值，对，我们将定义

这个函数深度优先打印，在 JavaScript 中创建一个箭头函数，

它将包含图表，这将作为一个很好的邻接列表给出。 这实际上

是同一张图。 现在我们追踪的最后一个示例，我还需要在这里指定一些

起始节点，我将其称为源节点，我们将开始遍历。

从那个节点开始。 凉爽的。 所以我们知道深度优先遍历所固有的

将是一个堆栈。 因此，我将向您展示如何迭代地实现它，这意味着您需要一个

显式堆栈。 对我来说，使用 JavaScript 就像使用 JavaScript 数组一样简单，

对吧？ 我会在开始时将其设为空。如果我只是

承诺使用操作数组同一端的操作，我可以将此数组用作堆栈。 换句话说，

如果我只使用 push 和 pop，那总是会操纵数组的末尾，对吧？ 删除

并添加到该数组的末尾。我实际上要确保做的是我想

用我的起始节点初始化堆栈，也就是我的源节点。 请记住，

这里的节点实际上只是由某个字符指定的。 凉爽的。 当涉及

到像这里的算法的主循环那样设计时，你想

在堆栈不为空的时候继续运行算法吗？ 换句话说，墙堆栈点长度大于零

，我必须继续运行。 这让人想起我们在白板上表达的内容。 因此，

当首先要执行此深度的单次迭代时，

我想要做的是移除堆栈的顶部。 因此，如果我执行 stack dot pop，这将删除数组的最后

一项，在这种情况下，就像我的堆栈顶部一样，并将其返回给我。 所以

我要把它保存到一个变量中，我称之为我的当前。 因此，这一点

实际上是打印出该电流的绝佳机会。 所以我会控制台点日志

当前，对吧？ 所以看看，你知道，这个例子在这里，因为我初始化了一个堆栈

以只包含 a 的源注释，在第一次迭代时，这个 while 循环，

我当然会弹出 a，然后我会打印它出来，对。 从那时起，我想做的

是考虑 A 的 B 和 C 的邻居。所以如果我想查看与 a 关联的数组

，我可以键入我的图表，对，因为我的图表是一个对象，对 现在。 因此，如果

我说图形，方括号，电流，对，如果电流是 a，这意味着图形，方

括号电流会给我这个数组。我想遍历

该数组中的每个节点或每个邻居。 所以我要在这里嵌套一个循环。 我说让

那个数组的邻居。 因此，如果您熟悉 JavaScript，如果您只使用 for of 循环，它们将

通过数组迭代一个订单。 所以现在我像 B 和邻居看到的那样打了一个邻居。 我

想对这些邻居做的只是将它们推到我的堆栈顶部。 所以这

只会堆积起来，推动并推动这个邻居。 太棒了，我一定会

推动每一个拥有的邻居。 所以有时我会有两个邻居。 其他时候我

会有一个邻居，甚至没有邻居。这就是实现良好的

基线深度优先打印的全部内容。我确实想指出一点，我最喜欢的

实现这个算法的方法是考虑像处理你的节点，当它离开堆栈时，

而不是当它进入堆栈时。 换句话说，我通常像我的打印语句那样写，就

在弹出某些东西之后。 我弹出的东西正是我打印的东西。 正确的。 所以让我们

继续尝试一下，看看我们得到了什么。 看起来在我的终端中，我得到

了 AC e b df 的顺序，你会注意到这与我

在这里的预期略有不同。 然而，这也是一个有效的深度优先遍历，我们必须

记住，你知道吗，取决于同一个邻居数组中值的任意顺序

，你一开始可能会倾向于不同的方向，对吧？ 在首先验证深度时，我寻找的最重要的事情

是确保我知道，

在切换方向之前追逐相同的方向，对。 因此，由于我从 C 开始，所以

我先选择 a，然后再选择 C，下一步将是 E，这

正是我的代码中发生的事情，对吧。 然后一旦我击中E实际上是一个死胡同。 这样

我就可以继续找我的另一个横向邻居，比如B，对。 所以我可以设计出与这里预期的相同的顺序

，如果我把它翻对了。所以我把 c 放在 B 后面。我会给出

这个。 它们都是有效的。 深度优先遍历。看看我们现在得到了什么。 酷，现在我得到

了 A、B、D、F、C 的确切顺序。真的想想为什么会这样，对。 所以假设我刚刚

从我的堆栈中弹出一个。 所以我打印了一个没什么花哨的，对吧。 然后从

那里开始，我开始遍历与权限关联的数组，所以在第

一次迭代时，我遍历 C，对吗？如果我将 C 压入堆栈，假设这是

我的堆栈底部，通过压入堆栈，它就在这里。 然后我将

B 压入堆栈。 现在B在上面。 由于 B在顶部，我知道像下一个顶级迭代，

这个 while 循环，我会删除 B，这将是我访问的下一个注释。 所以

他们确实都是拉塞尔的深度。好的。 所以有两点需要注意，你肯定

会使用堆栈来实现深度反转。您可以通过几种不同的方式使用堆栈

。 正确的？ 所以在这里我使用像一个明确的像数组作为堆栈。 我正在

使用一些迭代代码来实现这一点，对。 所以使用几个循环，对，你还可以

做的是首先递归实现深度，因为我知道任何递归都使用底层调用

堆栈。 因此，让我向您展示如何实现它。 当谈到，你知道，

在你的武器库中拥有所有这些不同的工具时，我肯定会练习迭代

和递归的风格。 我们稍后会在本课程中看到这一点。 所以假设我想

解决同样的问题。 但现在递归地，它实际上将是更少的代码。 因此，我

将使用相同类型的参数，我将拥有

作为邻接列表和源节点的图形，将源节点视为您当前的位置。

所以如果我在某个节点，也许我应该做的第一件事就是打印出自己，对，

打印出这个节点，所以我要做的是控制台点日志，这个源节点。

从一开始就感觉很好，因为当我们实际上对这个递归函数进行顶级调用时，

它们将 a 作为源节点传入。 所以我确实想在我的印刷品中作为第一个音符开始

，然后从那里，我需要看看 AES 邻居。 好吧，如果你想像以前一样

查看邻居，只需键入图形，使用该节点的邻接列表，

对，这会给我一个CNB 数组。 现在我只是遍历那个数组。

所以我会说 for let 那个数组的邻居。在这一点上，我现在

想做的是进行递归，对，所以我对这些邻居中的每一个进行递归调用。 所以对我来说，

这意味着只是称为深度优先打印，你给出相同的图形，对，图形

对象没有改变，但你应该像源节点一样改变。 现在您想

将该邻居作为源节点传入。 你将对该数组中的每个邻居进行递归调用

。 这实际上就是我们所需要的。 让我们继续运行这个

版本。 分频器跑过来。 看起来现在我们得到了 AC E、B、D、F 的顺序。这

真的又是另一种深度优先打印，对，不完全是这个顺序，因为

这次我们先追逐 c，对，我们去了 C， 我想得到这个顺序和

我的递归，然后我必须先输入B，真的是相同的模式。 现在

让我们开始运行。 好 AB de FC。关于这个递归，我首先要提出的一件事

是它没有明确的基本情况，这意味着没有明显的 like, if 语句，

就像你通常在大多数递归中看到的那样返回。 那是因为在这个

问题中，当像他这样的节点是死胡同时，我有一个隐含的基本情况。 好吧，

假设我当前的来源是他，那么当我在这个 for 循环中迭代时，我正在

迭代这个空数组，我的意思是有零次迭代。 如果您的

迭代次数为零，那么您永远不会进行递归调用。 正确的？ 这和有

一个基本案例是一样的，对吧？ 基本案例实际上只是我们没有递归调用的场景

。 所以这就是这段代码仍然有效的方式。好的，现在您知道如何

首先通过两种方式实现深度，对，迭代和递归。 他们都使用

绝对堆栈。 现在让我向您展示如何首先实现您的广度，以及

注释掉其中的一些代码。 现在我们先好好呼吸一下，在这里给自己一些空间。

因此，首先，我们要迭代地解决天鹅问题。 而且它真的只能

迭代，对吧。 所以我知道广度优先遍历需要一个队列，如果您尝试

使用某种递归来实现广度优先遍历，并且在幕后，有

一些堆栈数据结构，这将与您想要的队列顺序作斗争，

对吧？ 因此，对于广度优先遍历，您通常总是要编写一些

迭代代码。 所以有些循环，对吧？ 让我定义一下，我会说广度优先打印，

获取完整的图形、邻接列表以及源节点，我要初始化

我的队列。 再次使用该源注释，这里的队列将只是 JavaScript 中的一个数组

。 所以我会说 const q 等于一个仅以源节点开头的数组。

惊人的。 我将通过

在 JavaScript 中的数组上提交两个特定方法来使用这个队列。 因此，如果我使用数组点移来删除数组的第一个元素

。 如果我做数组点推，它会添加到数组的最后一个位置。 结合使用

这两种方法会给我一个很好的提示，对，添加到一端并

从另一端移除。 所以像以前一样，我们将有一个 while 循环，我们将

在队列不为空时进行迭代。 因此，虽然队列点长度大于零，但很好。

和我们的迭代一样，你知道，一开始，你想从删除

队列的前面开始。 所以我会说 q dotshift，这将删除第一个元素

并将其返回给我。 所以我可以保存在一个变量中，我喜欢称它为 current，

就像白板一样，对吧？ 从那里，也许我会把它打印出来。 所以控制台

点日志，这个当前节点。 从这里开始，想想你的邻居，对吧。 因此，如果

我使用这个当前节点键入我的图表，这给了我一个邻居数组，我

想循环遍历每个邻居。所以我可以说四个会说让

那个数组的邻居。 对于那个邻居，我想将它们添加到我的队列后面。 所以对

我来说，这意味着简单的 q dot push，我将继续推动那个邻居。

惊人的。 所以我从前面删除，然后添加到后面。 所以看起来还不错。

让我们继续前进吧。 实际上，在我这样做之前，我要改变

这个顺序，放入 CNB。 同样，邻居的相对顺序并不重要，

我只想要这个确切的输出，我们将讨论为什么这是正确的。 试一试。

所以我得到了 ACB EDF，就像我期望的 ACBEDF 一样，对。 所以假设你在

这个广度优先打印的第一次迭代中，我知道我会删除 a 因为我

在队列上初始化了 a ，对吗？ 所以我的当前是 a 并且我打印出 a 然后从

那里开始迭代这个数组，对吧。所以在第一次迭代中，我有 C，这

意味着我将 c 放入我的队列中，对吗？然后，我放了B，如果你放C然后

B，这意味着C在队列的前面，这就是为什么在第二次迭代中，我先有

C，对吧？ 因此，这就是您可以潜在地操纵宽度优先打印的横向顺序的方式

。 惊人的。 这就是这个遍历算法的全部内容，我真正

想要强调的是，特别是如果你看一下苹果到苹果的迭代代码，你

首先比较深度或广度，它几乎是相同的代码。 您实际上只是

在更改访问数组中项目的方式，对吗？您要么弹出或推送，要么移动并

更加努力地推动这段代码的整个类似结构是相同的，对吗？ 好的。

这就是我们对图表的深度优先和广度优先的介绍。 在

下一节中，我们将开始解决一个问题，对，这将非常有趣。 我只是

将此代码用作我们的基线工具。然后该部分还承诺

开始对这些算法进行分析。所以让我们回到那个白板。 嘿，

程序员，欢迎回来，对，让我们来看看这个有路径问题的方法。

所以在这个问题中，我们将采用一个邻接表来表示这个

问题的图，实际上所有的图问题，你肯定想用一张图片来可视化这个问题

。 所以我们要做的就是将这个邻接列表的每个键解释为代表

一个不同的节点。 如果我查看任何特定的列表，我可以看到这个 f 节点应该

指向 G 和 I。他们确实在这个问题中告诉我们我有一个有向图。 所以我要

在这些边缘上画箭头。 所以F 指向 G，以及 f 点并列。

我将根据给定图表中的信息创建相似的边。 所以我们最终得到了这样的图像

，直到他们告诉我们这是一个解释箭头的有向图，

但他们也告诉我们这个图是循环的。 所以如果你不熟悉，循环

只是意味着没有循环，这就引出了一个问题，什么是图中的循环。 所以一个

循环将是一条通过节点的路径，我可以在我想要开始的地方结束。

换句话说，如果我从这里的a节点开始，我可以去B，然后从那里，

我可以去C，然后回到a，依此类推。 因此，如果我在 Sigma 图上进行遍历

，我会得到一个无限循环。他们说的是，我们的图形

输入保证是定向的。 所以它有箭头，但也有循环，所以我们这里不必考虑

任何无限循环。 话虽如此，在这个问题中，我们不仅要获取

图信息，还要获取源节点和目标节点，我们要做的是返回

true 或 false 指示我们是否可以从源节点移动到 目的

节点。 换句话说，这两个节点之间是否存在路径？ 对于这个问题，

你可以使用深度优先或广度优先搜索来实际解决这里的问题

，我将在这个方法视频中进行跟踪，只是深度优先搜索。 但

在演练中，我一定会以两种方式对其进行编码。 所以假设从我的源

节点开始，我知道如果我在进行深度优先遍历，我可以选择 IRG，

假设接下来碰巧选择 G。 现在我别无选择，对吧？ 如果我真的要先做一个深度

，我应该更深入到 H。然后我点击这个 H。当我遍历这些

不同的节点时，我需要问自己我当前的节点是否等于我的目的地。

到目前为止，这还不是真的。 在这一点上，我的 h 节点触底，我不能

再深入了。 所以现在我可以横向移动到像我这样的节点，在这一点上，我可以

移动到 K 或 G，假设幸运的是，我恰好去了 G，这实际上会

带我走上一条路径 ' 之前已经探索过，我们可以稍后对其进行优化，但不会

有太大的影响。 最终，如果我在图中继续这种深度优先搜索

，我最终会到达一个与我的目的地匹配的节点，此时我可以返回

true，表示必须有从 F 到 k 的路径，只需进行深度优先搜索 .

当我们进行深度优先搜索时，遵守箭头的方向非常重要

。 所以我永远不应该尝试逆流而上。 所以这是一个

我们能够从目标源找到路径的场景。这就是我们返回 true 的原因。 让我们重置并

说现在，我应该返回 false。 好吧，假设我的源是 J。所以我从

J 开始。我正试图到达我的目的地 F。如果我开始深度优先遍历，

在这里，抱歉，我的 j 节点移动到 AI节点。 此时，我可以击中任何一个

G，好吧，假设我碰巧击中了k，现在这个点是底部。 所以现在我可以移动

到 G。然后从那里移动到 H。在这一点上，实际上

我无处可去，对吧。 因此，如果我完成了对图表的遍历，使用深度优先

或广度优先并且我从未到达目的地，那么我可以返回 false，对吗？ 一定

是没有这样的路径从我的源头到我的目的地。 当谈到在这个图

上实现深度优先和广度优先的反转时，这

将完全是我们习惯的，你可以使用堆栈并递归地解决它。

或者你可以迭代地做。 并使用队列，在这种情况下，您将进行广度优先

遍历。 我们讨论了它的复杂性，假设 n

是我们图的节点数，对于这些图问题，您也可以做的一个常见事情是将

e 定义为此处的边数，边指的是两个之间的连接 节点，基本上

只是箭头。 因此，如果我们使用数字节点和数字边这两个术语，我们将

有边数的 V o 的时间复杂度，因为我们必须

遍历图的每条边。 在这里，空间复杂度将基于

节点的数量，对吧？ 如果我使用某种深度优先堆栈递归地甚至迭代地解决它

，那么最坏的情况是，我必须将每个节点都放在堆栈上，

对吗？ 同样，如果我首先从广度上看到永恒，我会将每个

节点都放在队列中。 所以这只是我们定义用于分析

该图的时间和空间的术语的一种方式。 通常，对于图问题，

分析算法时间和空间的另一种可接受的方法是仅使用单个变量并将

n 定义为节点数。 那是因为如果你说 n 是节点的数量，那么

我们也可以说 n 的平方是边的数量，或者那个大 O。这

是最坏的情况。 所以让我们想象一下最坏情况的图表。 假设我只有这些

ABC 节点。 好吧，如果我想创建尽可能多的边，我将如何只创建

一条边？ 好吧，边缘只是两个节点之间的连接。 因此，您可以真正

为图中的每一对节点绘制一条边，就像这样。 这就是为什么

我们可以说 n 平方是任何特定图的边数。 因此，如果您

只想在这里使用 n 来定义复杂度，那么您可以说您的时间

将是 O of n 的平方，而您的空间复杂度仍然是 O of n。 要知道

，这两种方法都是为非常典型的图问题定义复杂性的两种有效方法。

话虽如此，我认为这很简单。让我们跳进演练视频，同时

我们实际上正在为这些实现深度优先和广度优先解决方案。 我会

在那里见你。 嘿，程序员们，Alvin 在这里，现在。 让我们复习一下啊，JavaScript 解决

方案有路径问题。 因此，我们将直接进入，我们将从

使用深度优先遍历解决这个问题开始，我知道这需要一些底层堆栈数据结构，

我将使用递归来实现它。所以我可以利用调用堆栈来获得我的

订单。 所以我要递归地解决这个问题，我会考虑我的源参数，就像

我在遍历过程中的当前位置一样。所以我可以检查一个基本案例。

好吧，如果我的来源等于我的目的地，那我一定找到了我要找的东西

。 所以只要返回true。 这个基本情况表明我找到了目的地。 所以必须

存在一条路径。 所以我返回 true，总是注意他们希望

我们为这个函数返回的类型。 假设这不是真的，好吧，他们需要继续寻找。

所以我应该做的是考虑我当前的节点，即源节点，考虑它的邻居。

如果我键入我的邻接列表，我知道这将是一个对象。 所以我

使用我的源输入它，这会给我一个包含所有邻居的数组。 例如，

假设它正在盯着这个，如果我当前的来源是 F，我说图形方

括号 F，我会得到一个 gi 数组。所以现在我想看看邻居，

对吧？ 所以我可以看到这里把我们变成了一个循环，对那些邻居中的那个

邻居说，我想遍历他们，这意味着我递归调用。 正确的调用有路径，

保持你的图表相同，但更新你的当前位置。 现在我要住

在邻居家。 目的地保持不变，对，总是有相同的目标

来递归解决这个问题。 所以想想这会返回什么类型

，我知道它会返回布尔值，对，它会告诉我

在我的邻居和目的地之间是否有一些路径，对吧。 所以如果我的邻居和目的地之间有一些

连接点，或者一些连接路径，那么

我知道从我的源到目的地肯定有一些路径，因为你的

源肯定在你的邻居旁边，对吧。所以我们所有人之间都会有一条道路。

所以我要做的是，检查这个递归调用是否返回 true，我会在这里明确说明，

也许很清楚。 因此，如果有一些路径通过我的邻居到达目的地，

那么我可以返回 true，只需向上传递那个 true。 因为一旦我找到了一条路径，您就

可以退出并将那只鞋一直返回到颜色的顶层。 但是

假设这个调用返回 false，这意味着没有通过我的邻居

到目的地的路径。 但不可能有其他邻居真的

会解决问题。 所以我不想做的只是说像 else return false 一样，

你应该能够立即将这样的代码视为可疑代码，因为

没有必要再有一个 for 循环，对吧？如果在任何一种情况下，你总是要

返回，那么你永远不会有这个 for 循环的第二次迭代，对吧？

因此，如果我找不到通过邻居的路径，那么如果此调用返回 false，那就

没关系。 继续下一个迭代，然后搜索你的另一个邻居。

这就引出了一个问题，我们应该在哪里返回false，需要在 for 循环之后？ 所以

只有在我搜索了所有邻居之后，我才找到一条成功的道路？ 如果

我返回 false，那将是我们很好的深度优先遍历。 让我们测试一下。

惊人的。 我们有它。 这里要记住的一件事是，我们正在利用

问题中的假设，对，他们直接告诉我们，将给出的图表

是病态的，所以没有循环。 所以这就是为什么在我们的代码中，我们并不真正担心

陷入无限循环。 在我们即将到来的问题中，我们将有更难的草

来实际处理那个病案。 但就目前而言，这是一个很好的基准解决方案。

当我们在这里的时候，让我们也做一个参考解决方案，你知道，现在应该

迭代，对，没有办法像广度优先那样递归地做。 所以我

需要创建自己的队列。 所以我可以创建一个队列，在紧要关头，我总是只

在 JavaScript 中使用一个数组，我会用我的源代码初始化那个队列。 所以我要

提到源和目的地，它们实际上是节点。 但是在类似我们的问题的上下文中

，它们实际上只是给了我们字符串，但它们代表节点，对吗？ 所以

想想他们所代表的信息。当我的队列不为空时，我将进行迭代。

因此，虽然 q 点长度大于零，但应该是熟悉的代码，与我们的

树算法非常相似。我通过删除队列的前面开始单次引用迭代。

所以我可以说 q dot shift 前面的一些，我可以称之为我正在遍历的当前节点

。 现在有些东西已经离开队列，通常这里是我检查的地方，我

可以检查。 好吧，如果我刚刚访问过的东西，如果那是我的目的地，那么我可以

返回 true，对，我找到了我正在寻找的东西。 所以必须有一条路径

连接我的原始来源和我的目的地。好的。 但是，假设这不是真的。 那么，

我需要考虑它的邻居。 所以像以前一样，看看邻居只是

使用源输入你的图表，就像它是一个图表，方括号源。 这给了

我所有邻居，所有邻居节点的数组。 这就是我想要在这里做的

就是遍历那里的每个邻居。然后我可以将它们添加到我的队列中。

所以 q dot push 那个邻居，一定要先实现你的真实广度。

所以你需要让事情从队列的一端离开，然后添加到另一

端。 所以这个代码看起来不错。 所以你应该首先意识到这与我们以前的

二叉树宽度有多么相似，除了现在我们必须考虑这样一个事实，即我们可以

在这里拥有动态数量的邻居，而不仅仅是左点和右点。 所以我只是

遍历所有添加它们的邻居，我需要等待返回 false。

你猜对了，移动是在你完成整个while循环之后，如果你的立方体变

空了，那么你一定已经尽可能地探索了。 如果你从不返回 true

，现在你可以返回 false，因为必须是

原始源和目标之间没有路径。 所以让我们给这个测试运行将具有非常相似的

时间和空间复杂度。 但这将是我所有迭代粉丝的代码。

所以在这里我遇到了一个小错误。 让我们看看我们在这里做错了什么。 所以看起来

我在这里超时了。 让我们一起看看这个错误，我不得不猜测这意味着我

做错了什么，陷入了无限循环。这个条件看起来没问题，对 q 点长度

大于零。 所以在这里，一定是我没有正确地迭代

这里的邻居，我只是写了 source.相反，我需要说当前，因为现在

我正在迭代地执行此操作，对。 因此，无论节点刚刚离开我的队列，我都认为这些

节点是邻居，并将它们添加到下一个通过我的队列访问的节点。 因此，让我们进行

一次测试。 那里有诚实的错误。 凉爽的。我们的广度优先解决方案

有路径问题。 所以我想让你做的是先练习深度优先和广度

优先，就像你期望的那样，我们会做很多即将出现的图形问题。 并且

取决于您知道问题所要求的内容，有时会更喜欢一种算法而不是另一种算法

。 因此，练习这两种算法非常重要。 现在，所有的问题

都比较容易。 所以练习这个，自己试一试。 我会

在下一个问题中抓住你。 到时候那里见。 嘿，程序员，这里是 Alvin，对。 现在让我们回顾

一下这个无向路径问题的方法。 所以我们将直接进入。在这个问题中，我们

将得到一个无向图的边列表。 因此，如果我熟悉这里的术语

，实际上我们所说的是每一对，这个边列表代表

两个节点之间的连接。 例如，如果我查看第一个边和列表，我看到 i 逗号

j，这意味着i 和 j 之间存在边或连接。 而且由于这是一个无向

图，我不仅可以直接从i 移动到 j，而且我当然可以从 j 移动到

i。 所以它确实代表了两个方向的联系。 所以当我们开始攻击时，

我们想要做的这个问题实际上是将这个 edulis 转换成更有利的

格式，比如邻接表。 这是因为通常，当我们执行遍历算法时，

它们在邻接表形式上效果最好。因此，让我们从这里开始进行转换。

而且我实际上很容易编写代码。所以我想基本上生成一个图，其中

我有节点作为键，我希望它们指向它们的邻居数组。 例如，

如果我想将第一条边转换为邻接表形式，我可以做的是

为 i 和 j 创建键。 现在 I是 J 的邻居，j 也是 I 的邻居，所以我

将分别填充这些邻居。现在只需按照此过程获得另一个优势。

因此，如果我查看边缘 k 逗号 i，我需要为 K 创建一个新键。我

将用 I 填充它，然后对于 I 的现有键，我只需将 k 添加到该集合中。

所以请记住，关于这种转换最重要的是因为我们

知道图形将是无向的，每当您在图形中放置连接时，请

确保您具有反向连接。因此，如果我有从 k 到 AI 的优势，他们也

需要为此提供信息。 好的。这个过程将继续为整个

边缘列表。 在这个转换结束时，我们将得到一个像这样的邻接列表

。 现在我们已经准备好执行我们的主要算法了。 当我们为此进行代码

演练时，我将深入向您展示如何实际创建此邻接列表。 因此，

当我们真正想提出一个遍历算法来解决图形问题时，

如果您真正可视化图形的形状，这真的很有帮助。 所以实际上想要

根据节点和边来可视化这一点。 这意味着它们之间有一堆圆圈和线条。

如果你为这个图表信息画了一张漂亮的图片，你最终会得到一个这样的图表

。 因此，我们将仅参考此图来浏览此方法视频的其余部分

。在这一点上我想提出的重要一点是对于这个图表，

我们必须处理的一个非常常见的情况是如果你的图表有一个循环。

对于您的无向图尤其如此。 因此，仅出于此方法视频的目的，我

将添加一个额外的边缘，以便我们可以讨论一个显式循环。 所以我

要从 k 到 J. Cool 添加一个新的边。原因是现在有一个很好的大循环，

长度为三，现在以红色突出显示。这个循环很重要，需要注意，

因为如果我们不做任何特殊处理，那么我们可能会陷入无限遍历。

所以想象一下我从这个主题演讲开始，然后我移动到 J，然后我会移动到 i，

然后回到 k，然后回到 J，然后是 I，依此类推。 所以现在它给了我一个循环，

我们必须提防它。 所以我可以在这里有一个三个节点的循环，对

，你真的可以有一个基本上几乎任何大小的循环，只要它不止

一个。 例如，如果我往下看，请注意我的图表

实际上包含两个独立的岛屿，但我们会认为它们只是一个巨大的图表，

对吗？ 所以我得到了O和N的小岛，它们实际上形成了一个微不足道的循环，对吧？

如果我开始遍历，在 o。 从那里，我可以移动到 n。 因为我知道

o 和 n 之间的边是双向的，所以我可以写一个无向图，这意味着我可以

回到 O，然后回到 n。 这会给我循环行为。 所以必须注意

这个问题中的所有类型的循环。所以在这个问题的背景下，

我们不仅给出了一个图，我们还将接受两个节点。 因此，让我们通过

一个示例，我想返回真或假，I 和 L 之间是否存在路径。所以

我将在我的图表以色列中标记它们。所以我将从通知开始。 为了

解决这个问题，您可以使用任何类型的遍历。因此，无论是深度优先还是广度优先，我都会

明确地逐步介绍深度优先遍历。正确的。 现在，为了避免任何无限

遍历，我想在遍历节点时将节点标记为已访问。 因此，我

不仅将自己置于 I 的源注释中，而且将其标记为已访问。 您可以

像标记访问模式一样实现这一点。以及几种不同的方式。 当我们稍后编写代码

时，我们可能会使用一个集合来表示我们访问过的内容。

但是现在，我将在我的图表中检查它们。所以在我的图表中，如果你在一个节点旁边看到一个复选标记

，这意味着我已经访问过它。 所以既然我在这个节点

，我想移动到它的邻居，所以我要移动到 J 的邻居。我

也一定要检查它是否已访问。此时，我可以搬到 Jays 的邻居之一，

假设我搬到了 k。 我还将把它标记为已访问。 现在，Matt K，我

可以搬到几个不同的邻居，我可以搬到 I LRM。 假设我偶然

选择了我，一旦我到达这个，我知道，我马上就能看到，

哦，我以前访问过这个节点。 所以我应该做的就是不要再穿越它了。

相反，我应该回到 K，对，因为这个眼节点已经被访问过了。

这就是我真正避免无限循环的地方。 所以相反，我搬到了 Kay 的

其他一些邻居，假设我选择了 L。此时，我会将其标记为已访问。

如果我快速检查一下，我可以看到我在 L 的这张便笺也是我的目标节点。

所以我一定是在我的源头和目的地之间找到了一条路径。 所以此时，

如果我找到我的目的地，我可以返回true，这是我们

在上一个问题中谈到的模式，我们需要的唯一附加标准是将节点标记为已访问。

这样，我们就不会陷入无限循环。只有当

我们的图中有循环时才需要这样做，如果它们没有给我们任何我们应该始终警惕的假设

。 所以让我们看另一个例子。假设我有一个 K 的来源。我的目的地

是哦，只是在图中直观地看，你已经可以看到没有

办法从 k 到 O，因为它们是断开的，对，它们是分开的

无论如何，岛屿都会通过算法，所以我将从 K 开始，将其标记为已访问，我

将访问 Ks 的一些邻居。 所以我可以移动到 i，然后我可以移动到 J。然后

在这一点上，我会回到 K，并确保他们不会探索任何

Ks 访问过的邻居，所以我不会回到 I 对，相反，我应该移动到一个未访问的

邻居，比如访问了 l 个市场，然后我只有另一个节点要访问，这将

是这个 m 节点。 在这一点上，我实际上已经用尽了这个完整的图形区域，对，

我无处可去。 一旦我完成遍历，如果我永远找不到我的目标

节点，那么我可以返回 false，对吗？一定是

不存在从我的源节点到目标节点的路径。 这就是这个算法的全部内容。

让我们谈谈复杂性。 如果我们说 n 是节点的数量，那么我们也可以

定义 he 是边的数量。 就像我们之前所说的，对于我们的图形问题，这通常是可以接受的

。 我知道时间复杂度将大致

与边数有关。 我的空间复杂度将是 n 的 O，即

节点数。 我认为值得一试，你知道这种复杂性实际上意味着什么，

你知道，大 O 指的是最坏的情况。因此，让我们考虑一下我们可以拥有的最坏情况图表

。你可以设计和思考一些不同

的图表，我只给你看一个例子。 所以假设我得到了这样的图表，对吧？

请注意，虽然 z 有点像在它自己的岛上，但所有这些节点都是一个

3 和一个 C 音符。 他们都是同一个图表的成员。 因此，假设我想

弄清楚 A 和 z 之间是否存在路径。 所以如果我从这里开始我的遍历算法，我将从a

开始，然后我移动到B，然后到C，然后到D，然后到E。此时，

我已经覆盖了所有的边缘 图表。请记住，这里的边是箭头

，因为我必须遍历该图的每条边。 这就是为什么我们说

最坏情况下的时间复杂度将是 E 的 o，边数的右 o。

在这里我们可以说空间复杂度是 n 的 O。 因为如果您

使用深度优先堆栈或广度优先队列执行此操作，在最坏的情况下，您将不得不

添加您访问的所有内容，或者将所有节点添加到您的堆栈或队列中。 这就是

为什么我们说对于常规图遍历算法，我们的时间复杂度为 ov，空间

复杂度为 O，为 n。 好吧，我认为我们有这个算法的

方法。 在这一点上，我想加入我的演练视频，在那里我们可以实际

看到如何在一些代码中实现这些访问模式。 我会在那里见你。 嘿，程序员，

艾伦在这里，对。 现在让我们看一下这个无向路径问题的 JavaScript 解决方案。

因此，就像我们在进场视频中所说的那样，我们将直接进入，将

有两个部分。 首先，我们要将边列表转换为邻接列表。

这样，通过它进行经典遍历会更容易。 所以我要假装我在

这里有一个辅助函数。 这给了我一个邻接列表。 我称之为图表。

我将调用这个辅助函数，我们会说构建图。 如果我通过它，只是

我所有的优势，我希望它为我进行转换。 所以让我们现在就来处理那个辅助函数

。 然后我们将跳回到无向路径。 所以我将创建我的构建图函数，

只是要考虑边缘，对吧。 而且我知道我希望我的邻接列表

采用普通的旧 JavaScript 对象的形式。 所以在这里创建那个图形对象。 我会

像这样在最后归还它。我想要做的是用

来自边缘的信息填充这个图表。 所以我要遍历每一个边。 因此，对于让边缘

的边缘，如此迭代，通过每条边缘，我知道一条边缘将是一对。

所以我要从中解构出来，也许只是我的两个节点标识符，我们

将从边缘称它们为 a 和 b。 好的。我现在要做的是将这些节点初始化

为这个图形对象的键。 所以 a 会是这样的，我注意到或者这个 k 节点，

对。 所以我要做的是检查 A 是否在我的图表中，我认为真的清理这段代码，

如果我检查它是否不在图表中，我们会更好。所以如果a节点不在图中，

那么我能做的就是在图中初始化它。因此，将其用作键并将其分配为

空数组。 我也会在这里为 B 做同样的事情。 对，所以如果 A 和 B

不存在，我将在图中初始化它们，一旦我这样做了，我就可以安全地将邻居添加

到它们的边缘，对吗？ 所以我可以说，图方括号a点推B。所以

现在我说对了，B应该是a的邻居，但我知道这是一个无向

图，对吧？ 所以应该是对称的。换句话说，然后确保将 a 推

入 B 的邻居。因此，注意到这是一个无向

图非常重要。 所以你的邻接列表需要以这种方式对称。 所以如果a在B的邻居中，

B也应该是A的邻居。 所以这看起来很不错。 让我们继续

看看这个图表看起来如何，只需在这里进行一点小测试。 所以我可能必须窃取这个

片段，在这里获取完整的片段，我可以手动运行它，以确保我可以

在使用这些小辅助函数之前对其进行测试。 所以我们将试一试，我们应该

在这里看到这些边的邻接表形式。 看看它的样子。 所以看起来还

不错。 所以我看到了，我与 J 和 K 有联系。对吧？

基于这些边缘，这看起来是正确的。 惊人的。我还想确保它是对称的，

对吧。 所以如果 i 和 j 在这里，我也应该在这里有 JNI，对，

它应该是一条双向街道。 好的，现在让我们在这里使用我们真正的算法，这

将是某种遍历。 现在您有了一个不错的邻接列表，您

可以进行广度优先或深度优先遍历。我将实施我认为，深度优先。

通常对我来说，如果我递归地进行推力，它会更容易。 所以我

要假装我有一个名为 has path 的函数，它现在将包含在我的图表中。 还有

一个起始节点和一个结束节点。 所以我想找到从节点 A 到节点 B 的路径，当然，

我会假设这个函数返回一个布尔值。 但是，当然，我必须

为自己编写该函数。 所以在我们的代码中保持井井有条，我们会说有路径。 我

将考虑图表以及节点 A 和节点 B。我认为这些参数的名称更好，

因为我正在递归地执行此操作。 让我们称此为一个源和此一个目的地。

所以随着时间的推移，我们将递归调用并更新这个源节点。 这应该

是解决其他一些问题的熟悉模式。 最近。 所以想想我的基本

情况。 好吧，我知道当我的源节点等于我的目标节点时，我已经成功找到了一条路径

，如果是这种情况，则返回true，因为我刚刚找到了一条路径。 否则，

我必须继续寻找。 所以我应该能够查看我的源节点的邻居

。 所以我可以说图形方括号源，对吗？ 请记住，通过

此递归源的任何点都代表我当前的位置。 如果我说图形，方括号源，

假设源是我，我会访问所有 ies 邻居，对吗？ 所以我想做的是

真正迭代让邻居，或者更确切地说有源图。 因此，如果

第一次迭代邻居上的源 I 是 j，第二次迭代邻居可能是 K。对于我的每个

邻居，我想去他们那里。所以调用有路径，你可以保持你的图形

参数与改变源的需求相同，尽管现在你位于你的邻居，

并且你的目的地是固定的，或者你总是试图到达同一个确切的节点。 我

会考虑返回什么类型我知道这会告诉我布尔值，对吧？

对或错？ 从我的邻居到目的地有什么路吗，我去

查一下。 好吧，如果该调用返回 true，我将在这里明确说明，那么我刚刚找到

了一条路径。 所以只要返回那个真实的，对的，把它一直传回去。

我们在这里形成的一种逻辑是，我知道根据定义，源和邻居肯定是相连的。

所以他们之间肯定有一条路。它们通过直接边缘连接。 因此，如果

我的邻居有到目的地的路径，那么我知道，那么源也有

到目的地的路径。 惊人的。 所以在这个for循环完成运行之后，假设我们

从来没有发现我们的任何邻居做出了一条成功的路径，那么意味着我完成了这个

for循环而没有返回true，这意味着我可以返回false正确必须是这样

的情况 这个源节点没有到达目的地的路径。 所以我认为我们可以

继续测试这段代码。 如果您观看方法视频，您会注意到此代码

中缺少一些重要的东西。 但我们只会运行它并向

您展示如何在这里钓鱼。 所以在这里我得到一个错误边缘没有定义我

做错了什么，34个月前的第34行在这里。所以必须打掉这个电话，不再需要那个

了。 那在我身上。 让我们进行测试。 所以这不是我所期待的错误。

不过，我期待某种无限循环。 完美，我正在超出最大调用

堆栈大小。 所以我真的得到了无限递归。 这会发生，

因为我们没有考虑到我们的图表中有循环的情况，对，我们

需要避免这种情况。 因为如果我的图表中有一个循环，我将永远不会遇到任何这些

基本情况，我只会继续绕着一个圆圈旅行。 如果不清楚，请

务必观看进场视频，对。就像我们说的那样，这里的举措是添加

某种数据，以显示您以前去过的地方。 通常，

我们对图形问题执行此操作的方式是跟踪一些访问集。 因此，当我

对这个房子路径进行顶级调用时，我知道这是执行该遍历的实际函数，

我将在此处传递一个新参数。我将使它成为一个新的 JavaScript 集。 因此，

如果您不熟悉集合和 JavaScript，它们实际上只是项目的集合。

一个系列真正伟大的地方在于，我可以在一次内添加一些东西到

系列中。 而且我还可以检查集合中的某些内容是否会非常非常快地

进行遍历。 我不想使用像数组这样慢的东西，因为要在数组中进行查找

或检查，这实际上是 n 次的 O，或者它是一个集合，它

是一个的 o。 所以我要在这里提出一个新的论点来接收访问的列。 我

想要做的就是检查我的源节点是否已经在访问集中，以便在 JavaScript 中执行此操作，

我可以检查访问过的节点。 所以如果源节点在访问

集中，那么我可以在这里返回false，对，没有理由再穿过这个节点

了。 因为如果它是访问过的，那么我之前一定去过。 这

就是我可以避免无限递归的方法，如果我愿意，也可以将这条线向下移动。

假设我通过了这个if 语句。 所以这意味着好吧，

这个节点源没有被访问过。 但我现在正在访问它。 所以我需要

访问一个点添加源。 所以这个表达式检查源是否在访问中，并且这个表达式

将源添加到访问集中。 我想在这里更改一些其他细节。

确保通过此处的所有递归调用传递相同的访问集。 因为

您希望这个访问集对于整个遍历权来说都是全局的，所以我需要

确切地知道我过去去过哪里。 一旦我们有了它，这应该是

我们需要的一切，以防止任何任何循环在这里给我们无限递归。 让我们

试一试。 惊人的。我们的无向路径问题有一个解决方案。 如此重要的

事情要在这里带走考虑这个问题，一个两方，对吧？ 第一阶段

非常简单，只是将边缘列表转换为邻接列表，这

实际上是一个重要的练习技能。 因为当谈到，你知道，

你会在野外面临的一些问题，它们基本上都是图问题。 但有时

他们会给你图表并喜欢不同的格式，你总是可以转换成

你喜欢的格式。 从那里开始，我们有了一个真正的核心模式，

即遍历一个图，同时防止无限循环，对吧。

为此，我们只需使用某种已访问集。 嘿，程序员，欢迎回来，

现在想复习一下这个连接组件计数问题的方法。 所以在

这个问题中，我们要做的是取一个表示无向图的邻接表。 与

往常一样，对于任何图形问题，您都希望从可视化实际图形开始。

所以如果你把这些信息拍下来，它最终会看起来像一个具有

这种结构的图表。关于这个可视化图表，我们首先应该注意的是 a 有

多个连接的组件。 例如，我可以查看

仅跨越一个和两个节点的粉红色组件，我可以查看跨越四个或 5678 个

节点的另一个组件。 最后，第三个组件仅覆盖三个节点。 这就是为什么我们

说你的函数的结果应该是三个，对吧？ 因为存在

三个不同的连通分量。 所以让我们想出一个我们可以用来计算组件的算法

，我们知道一个通用的计数算法将使用一些变量，我们

将这个计数变量初始化为零。 这里的技巧是

结合使用一些标准的图遍历代码，可能是深度优先以及一些迭代

代码。 所以我会在左边列出我所有的不同节点。

我要做的是从迭代开始，遍历这个列表的每个节点。 我

要做的是，当我当前在这个迭代列表的某个注释处时，我将

在那个节点处开始遍历。 所以现在从一个节点开始，假设是深度

优先遍历，你可以使用深度优先或

广度优先来真正实现这个模式。 所以假设我从这里的一个节点开始。 我现在应该做的就是

尽可能地继续这个遍历，这才是这里取胜的关键。 所以从

这个节点，我可以移动到两个邻居。当然，当我穿过这些节点时，

我想确保将事物标记为已访问，这样我就可以避免循环。 并且将

事物标记为已访问也将确保我们不会在这里重复计算任何组件。 一旦

我注意到这一点，我实际上已经完成了这个完整的组件，我无处

可探索。 所以在这一点上，我应该将我的计数加一。 因此，每当我

在图表的某个区域完成新的遍历时，我都需要增加计数。 此时，

我现在回到左侧的迭代代码，并迭代

下一个节点。 所以我现在看看第二个节点。如果我看一下节点二，我

发现我已经将它标记为已访问。所以这意味着我不需要

在那个节点开始遍历。 所以有效地跳过这两个并保持计数相同。 下一次迭代

我有一个三个，三个现在未访问。所以我应该

从这三个节点开始新的遍历，这意味着我只是将它标记为已访问。 而且由于这三个是单例

节点，对，它没有连接到任何人，我实际上会完成他们的遍历，

就在三个节点上。 至此，我已经完成了一次遍历。 所以我将计数

加一。 所以现在我总共有两个，我回退到我的迭代代码。 所以我

从三节点搬到了四节点。我看到这四个节点未被访问，这

再次意味着我必须从这四个节点开始遍历。 我将扩展这个

遍历。 尽可能从四开始，在我回到我的迭代代码之前，对，

所以我要探索六，探索这五个，探索七，最后探索

这八。 至此，我已经完成了一次遍历。 所以我可以将我的计数

增加到三。 然后我必须继续并退回到我的迭代代码。 于是

查看五节点，我看到五注已经标记为已访问，所以不开始

遍历。 而且我看到这六个节点，同样的事情不需要开始遍历

已经访问过的七个节点，已经访问过的八个节点。 至此，我将

完成整个算法。 这是我最后数到的三。 所以这里有一些有趣的机制

，对，你肯定需要实现一些代码或一些函数

，尽可能遍历某个组件，然后你还需要一些迭代

代码，以便潜在地开始遍历每个 单一的起点。 您

要做的是确保在遍历节点时将节点标记为已访问，因为只有当您

将新节点标记为已访问并完成遍历时，您才应该增加计数。

你可能想知道我们如何在一些代码中实现它的确切细节，

但别担心，你会意识到这实际上只是我们在演练视频中之前的图形算法的衍生

，但现在，我们看到 那 n 是许多节点，他

像往常一样有许多边，我们知道这实际上只是遍历

整个图。 所以我们可以说时间复杂度只是 ov，空间复杂度

是 n 的 O，对，这取决于你是先做广度还是先做深度，你

将使用那个空间，然后根据你的堆栈或 立方体。

如果您使用集合将您的节点标记为已访问，我们也可以考虑使用我们集合中的空间，但总的来说，它仍然

会导致线性时间和线性空间解决方案。 好吧，我想我已经准备好编写

这个代码了。 我会在演练视频中见到你。 嘿，程序员们，这里是 Alvin，对，

现在让我们来看看这个连接组件计数问题的 JavaScript 解决方案。

因此，我们将完全实施我们在进场视频中谈到的策略。 所以请

确保您首先观看，我们知道这将需要两种不同的

机制，需要我们的交互式代码才能跳到不同的连接组件。

而且我们还需要一些遍历代码来尽可能地探索一些单个组件。

所以我在这里要做的是让我从迭代代码开始。 所以我需要

在每个潜在节点开始遍历。 所以我可以说让我的图表的节点真的在我的图表中

说，因为对于这个问题，我们给出的看起来像 JavaScript 对象。 所以如果我说

for let node in graph 这会给我每个键，比如 015，等等。 所以

对于图中的每个节点，我想做的是开始遍历。 所以我们

假设我在这里有一个函数，我称之为探索。 当然，我会传入

图表以及那个节点。 我希望这个函数做的是，我们会说

，深度优先遍历，尽可能从那个节点开始，对，所以

可能需要在这个主函数中添加更多逻辑。但就目前而言，我认为是时候真正

充实探索了。 所以我会选择递归地做这个探索方法。 所以我们将定义

探索，它会包含一个图表，以及我当前的节点，我就称它为

当前的，对吧。 然后从那里，我想解决这个问题，首先使用深度。 所以

递归很好。 而且这里没什么可做的，但是真的要通过我的邻居来

遍历这个节点的每个邻居。所以我可以说就像当前图的邻居一样，

我记得图将是一个邻接表。 因此，如果将电流分散开来。 因此，

如果 current 是一个像 8 这样的节点，那么在第一次迭代时邻居将为零，

下一次迭代邻居将是 5。 所以在这里，我只是遍历

当前节点的所有邻居，我只需要不遍历它们。 所以我可以调用 explore，

传递相同的图表，这不会改变。 但是现在我的新当前节点将是那个邻居，

就像那样，这将执行深度优先遍历的基线。

但是我们还需要将事物标记为已访问，就像我们在方法视频中所说的那样，这

是解决方案中非常重要的一部分。我希望这个喜欢访问的集合在

我的整个遍历中都是全局的。 所以我将不得不创建它，也许我的主要功能在

这里。 所以我可以创建我的常量访问，使其成为一个 JavaScript 集，因为 JavaScript

为我设置了一个查找和一个添加，我可以将这个访问集传递给

我的引用，直到所有这些调用都在这里。 所以我知道我现在会

在这里接受访问。 现在我想真正开始使用visited。 所以有几点需要注意，对了，

我肯定是想用visited来防止循环的吧？ 这是

我们一直访问图遍历的主要原因之一。所以这里有一些熟悉的代码。 如果我已经

访问过这个节点，所以如果访问过，有这个当前节点，那么这里没什么可做的，

也许只是返回 false。 稍后，我们会看到。我们在这里使用的非常酷的技巧是返回

false，对，实际上有两个目的。返回 false 因为这可能是一个循环。

然后我需要确保我也通过了这里的访问集。 好的。

假设我们有一个未访问的当前节点。 所以这个说法是

错误的。 那么，看来我们现在正在访问这个节点。 所以现在我们应该

将它添加到访问集中。 好的。除此之外，我们还需要确保我们的

explorer 函数的类型是一致的，对吧？ 所以我要让我的资源管理器函数

做的是，只要它像一个新节点返回 true 一样进行探索，它就会返回 true。 所以如果

你看一下这段代码，如果我的函数在第 17 行返回 true，

那么它肯定已经完成了对所有邻居的探索，对，因为我

知道这个 for 循环可以完成这项工作 探索所有的邻居，对吧？ 因此，只有在

所有这些邻居呼叫都返回之后。我会回归真实吗？ 这一定意味着我已经

尽可能地探索了这个组件。正确的？ 这似乎很好。

我现在能做的是在我的 main 函数中，当我调用 explore 它时，现在它会给

我布尔数据，对吧？ 如果它正在探索一个新的岛屿或一个新的组件，它将

返回 true。 所以我可以检查。 好吧，如果 explorer 返回 true，那么这是一个新

组件。 所以我可能可以在这里增加一些计数，我应该已经创建了。 所以我会

说 11，计数等于 0，我将增加该计数，当我找到一个新组件并且

到最后加上等于 1 时，我当然应该返回该计数。 你会

注意到，对于我们的场景，比如说迭代到我们已经探索过的节点，当

我进行这个调用时，我知道那个调用将返回 false，因为如果

已经探索过某些东西，它会 已添加到访问。 所以这就是我

为这个递归函数使用一些布尔返回值的原因。所以这段代码看起来很不错。 我想

在这一点上，我们可能已经准备好测试这个了，让我们在这里试一试。 所以一些非常

棘手的代码，不是很长。 这是一个真正的核心模式。 看起来我

遇到了错误，我们这里有问题。 所以看起来答案应该是两个，

但我给了七个。 所以我算得太高了。 所以我会做些什么来调试

这个真的只是可能打印出我访问过的。所以这是 JavaScript 想要引入的一个很常见的错误

，我想这个例子，我可以手动测试一下。 我要

确保做的可能是在每次迭代中，比如说这个 for 循环，我每次都

使用访问的关联访问更改来控制台点日志。 我将

通过点击运行手动运行它。 让我们看看我们在这里得到了什么。 所以有几点需要注意，看起来

我们的一些键，或者我们集合中的一些项目是字符串，或者零是一个字符串。

有时它们实际上是数字，请注意它们缺少引号，这

与你知道的只是 JavaScript对象有关，从技术上讲，JavaScript

对象的键将始终转换为字符串，尽管 这些数组中的数据

将是数字。 集合实际上可以存储这两种类型。 因此，如果

你有两种不同的类型，它就无法弄清楚它们真的

代表同一个节点。 比如这里看这个visited set，我

喜欢数字一，还有一串，不好。 因此，让我们将它们

全部转换为字符串。 所以我会检查visited是否有我当前节点的字符串版本

。 所以我会为我做转换。同样，我想

在此处添加当前节点的字符串版本。 这样，我就有了非常一致的类型。 所以让我们

再次手动运行它，现在应该只看到我们所有的字符串。 惊人的。 而且我认为我们可以运行

所有的测试用例。 所以这是在 JavaScript 中需要注意的非常重要的事情。

JavaScript 在这方面非常独特。它只是自动将所有

键转换为字符串。 惊人的。 好吧，程序员，这就是连接组件

计数问题的全部内容，你要做的就是真正练习这个问题。 这实际上是一个非常

非常常见的面试问题。我们将在未来解决这个问题的许多变体

。 嘿，程序员，Alvin 在这里，对吧？ 现在我想介绍

一种我们可以用来解决这个最大的组件问题的方法。 所以在这个问题中，我们将

使用一个图表，就像我们最近一直在做的那样。 您

可能应该做的第一件事就是将此图表视为图片。所以希望你把它画出来。 所以你可以

真正理解这是在问什么。 我们的图信息已经作为邻接

列表给出。 所以很容易画出来。 因此，既然我有这样的图表，

我首先应该注意的是它可能包含多个组件，对吧。 所以在这里，

我看到了两个独立的岛屿，两个独立的组件。 我想考虑

每个组件的大小。 因此，如果我查看我的第一个组件，跨越节点

015 和 8，我知道它们的大小为 4，它们是 4 表示

该组件中的节点数。 所以我真正感兴趣的是有多少节点有一个分量，

不一定是边的数量。 如果我查看跨越节点的另一个组件，即

两个、三个和四个，它肯定有一个三个节点组。 这个问题

真的很关心最大的组件，所以我应该只返回四个，因为它

是最大的组件大小。 因此，当涉及到这个问题要问什么时，如果您一直按顺序关注这些问题，那么您确实有

一些熟悉的模式，当然，我总是

建议您按顺序解决这些问题。那么我们该如何解决这个问题呢？ 好吧，

我知道我需要某种迭代代码，这样我就可以旅行并跳到不同的

组件或不同的岛，我可能可以做一些深度优先遍历变化，

也可以找到连接组件的大小。因此，让我们逐步了解该算法的

运行方式。 在一边。 我将列出我的节点以表示我将如何进行

迭代以在每个节点的遍历中作为我的起点，所以我将从

节点零开始。 由于节点 0 未被访问，现在，我将开始一个全新的

遍历，从节点 0 开始。我将标记我的节点为访问过的，

因为像往常一样我们的无向图，你想注意并防止

你可能陷入的任何循环。而且我知道这种深度优先遍历正在发生 尽可能探索

这个完整的区域。 并且通过递归的力量，很

容易实现一些模式，可以在我们遍历它时计算每个节点。 当然，我

将把这些节点中的每一个都视为一个音符。 最终，

这些将返回到我的顶级呼叫，在这种情况下，我可以将它们全部加起来，

总共得到四个。 如果这感觉非常混乱，并且您

想知道我们将如何编写该模式，请不要担心，这实际上是

我们以前见过的模式。 因此，我将在代码中详细介绍这一点。 现在只知道

，获得节点的数量实际上并不是什么大问题，对吧。 所以现在我知道

这个组件的大小是 4，我应该做的就是将它存储为

我目前看到的最大的岛或组件，因为它是我考虑的第一个组件

。 在这一点上，我应该回到我的直观代码。 所以我看了一下

节点一，我应该注意到这个节点一已经被勾选了，它已经被访问过了。

所以没有理由从这个节点开始另一个遍历，因为如果它被访问过，那

意味着我已经探索了节点一所属的组件，所以我基本上可以

跳过它，在我的迭代中继续到节点二，因为 节点二未访问，我应该

开始新的遍历。 在这里，我知道这种深度优先遍历将尽可能地探索

该组件，它将继续并将所有这些节点计为

一个。 最终，其中一些计数在一起，让我数到三。 所以下一个

组件的大小为 3，我需要将这三个与我当前最大的四个进行比较，

显然，四个更大，所以四个保持最大。 当我

回到我的迭代代码时，我注意到我已经访问过三个三，所以没有理由

重新开始。 遍历，四已经被访问过，所以什么都不做，五已经被访问过。

当然，也访问了八个。至此，我们已经完成

了对图中每个节点的查看，并且我们必须已经探索了每个单独的组件，因此我们可以返回

我们存储在那个最大变量中的最终值。 惊人的。 当谈到

该算法的复杂性时，它非常简单。 它基本上是

我们目前看到的所有算法，我们看到 n 是节点数，e

是边数，我们知道时间复杂度将大约是边数的 o

浏览整个图，我们还可以看到空间复杂

度也将是线性的，实际上只是n 的 O。 因为通过所有这些，

我们可能会将所有节点存储在一组权限中以跟踪访问。

根据您实现遍历算法的方式，无论您是使用深度优先还是广度优先，

您还将通过堆栈或队列使用线性空间量。 所以

总的来说，我们正在寻找一个非常有效的线性解决方案。 因此，我想

我已经准备好编写这个代码了。不过，我希望你做的，首先可能

是在你自己的第一个集群上试一试，实际上只是利用我们过去见过的一些代码

。 因此，请自行尝试。 如果您遇到困难，可以在演练

视频中找到我。 我会在那里见你。 嘿，程序员们，这里是 Alvin，现在让我们来看看

这个最大的组件问题的 JavaScript 解决方案。所以这个问题实际上只是

我们上一个问题的衍生。 所以我们会直接跳进去。 和往常一样，请务必

先观看进场视频。 我们将从构建我们的代码开始，这将帮助

我们在这里开始在不连贯的岛屿上进行遍历，对吧？ 我们应该说这是连接组件

。 因此，我将开始遍历图形的每个节点，这意味着

我只是在这里遍历输入对象的键。 因为请记住，我们

已经将此图作为邻接列表。 所以我可以说 for let node in the graph。 所以我

会给我像015这样的节点，等等。我要做的是在这里开始遍历

，对吧？ 所以我们要假装我有一个函数，我称之为探索大小。

如果我给它图形信息，以及我想要遍历的节点，

希望它实际上遍历整个连接的组件，对。

我要假设的是，让我假设这个函数实际上返回

了整个组件的大小。 所以这将是一个正确的数字，代表

该组件中的节点数。 因此，如果我有它应该在这里接收，称之为尺寸。

而且我知道对于整个 for 循环，我需要一些类似最大值的逻辑。 所以我要

创建最长的，将它初始化为零。然后从那里，我可以检查。 好吧，如果

我刚刚找到的组件的大小，如果它大于最长的，那么我可以

替换最长的简单地最长等于大小，在for循环之后，我会读

转最长的课程我需要写这个 探索尺寸函数。 因此，我将首先将其作为

一种深度来实现。 所以我要让它递归，至于大小，取图，

以及我们当前的节点。 还有一些我应该注意的事情，它们告诉

我们我们有一个无向图。 因此，我们需要确保避免任何循环。

所以我们在这里也设置了一些经典的结构，我将使用一个访问集，

我们将使用一个集合，因为它给了我一次查找的 O 和一次插入的 O。

所以现在我有了我的访问集，我可以在开始遍历时传递它。 现在

让我们处理一个基本案例，以及检查我是否已经访问过这个节点。

所以如果访问集已经有这个我需要返回的当前节点，基本上

避免递归调用。 但是我在这里也想要一个一致的类型，对，所以我假设这个

函数返回一个数字，代表我遍历中某个点的大小。 如果

我到达一个已经被访问过的节点，那意味着我已经数过了。 所以我

现在把它当作零，因为我不想重复计算我的节点，否则

在这里会不准确。 现在除此之外，我能做的也许是在这里创建一个变量，

我称之为大小，我将把它设置为等于 1 来表示我现在所在的当前节点

，对吧？ 如果这个条件不成立，那么我是第一次看到

这个节点，所以我需要数一下。 而且我们还确保将其添加到访问中，

这样我以后就不会进入节点的循环。 好的。 在这一点上，我需要

对这个节点的邻居进行递归调用。 所以就像我们通常做的那样，可以

说让节点图的邻居。 所以在这里记住你的数据形状。 因此，如果节点

是一个键，比如 5，当我说图节点的邻居时，它会

遍历邻居一个 5、0、然后是 8，依此类推。 所以在这里，我进行递归

调用，我将调用同一个函数 explore叹息，传递同一个图表。 但是现在

你位于你的邻居，你可以提供相同的访问集。 这

就是我的信念递归飞跃的地方，对，我将假设这个探索大小

函数正在工作。 因此，如果它正在工作，它会回馈什么，它会给

我一个代表该图大小的数字，从我的邻居开始。 所以

无论我回到这里的数字是多少，我只想增加我的大小，对吧。 这

将基本上积累这个完全连接的组件中所有节点的计数。

在我探索完邻居之后，我会充分探索整个组件

。 所以我可以返回我的最终答案，这就是这里的尺寸，

你需要做的真正重要的事情是确保如果你遵循这种策略，你开始

你的尺寸等于一，然后你添加到它 时间，因为这个代表

我所在的当前节点，所以我知道每个调用都会计算自己的节点。 所以随着

时间的推移，这实际上会积累我需要的一切。 所以感觉很好，有我们很好的

访问逻辑。 我们已经在这里编写了我们的 main函数。 请注意我们是如何在这里将

这段代码拆分为一个不错的小辅助函数，我认为这是表达

这一点的最佳方式，它与我们之前完成的一些问题非常相似。 对，我想在这一点上

，让我们继续尝试一下。 看，我们得到的，应该可以

通过几个不同的测试用例。 好的。 在那里，我们有最大的问题。

所以有几件事，我想让你记住，对于你的图形问题，或者

你有断开连接的组件，你不仅需要遍历代码，还需要

一些迭代机制，通常只是一个循环来确保 你可以跳到不同的

组件，对吧？ 因为如果您只有常规的遍历函数，根据定义，

单独的组件之间就没有边缘。因此，您将永远无法探索

完整的图表。 否则，好吧，程序员练习，我会在下

一个中抓住你。 嘿，程序员，这里是 Alvin，对。现在让我们讨论一种可以

用于最短路径问题的方法。 所以这里我们有另一个图形问题，您的图形

将作为边列表给出。 所以我们应该做的第一件事当然是

可视化这个图表。 在您的代码上下文中，最好

将其转换为邻接列表。 因为我们在最近的一些问题中已经多次看到这种模式

。 我会把那部分留给你。 但我们最终会得到一个看起来像这样的图表

。 在这个问题中，我们也会在这里得到两个节点，

比如说 W 和 z，我想要做的是返回这两个节点之间的最小路径。

在这里，我有两条明显的路径，对吧？我可以从 W 到 z 的一种方法是通过

x 和 y。 在那里我可以看到路径长度为三。 请注意，我们

将路径链接视为路径中的边数。 所以不是

节点的数量，对吧？ 所以这意味着我如何在这里计算三个？ 实际上只有三条线，

对，三条边。 这是从 WC 获得的一种方法，从 W 到 z 的另一种明显

方法是通过 VI，在这种情况下，我只需要使用两条边。 所以那条

路径线当然是两条。 而这个问题，我想做的是返回尽可能小的

路径长度。 所以我应该在这里返回两个的最终答案。 所以我们知道这个

问题需要我们做一个图寻路算法。 问题是，我们应该采取哪一个

，我们可以选择，当然，深度优先遍历，或者广度优先

遍历，我这里就切入正题。他们两个实际上都会给你一个有效的策略

，这意味着你可以用深度优先或广度优先策略来解决这个问题。

但也许其中一种算法会比另一种更好。 所以让我们考虑一下

可能性。 所以假设我有一些大图，现在抽象地思考一下。 所以

有点只是看一个抽象的例子。假设我正在经历一些

深度优先遍历。 假设我的起始节点是黄色的，我的

目标节点是蓝色的。 所以我要做的是，再次，弄清楚

这两个节点之间的最小路径距离是多少，显然，你知道，从长远来看，你应该

在这里得到一个像两个这样的答案，对，因为两个绝对是最短的

这两个节点之间的路径。 如果我们进行深度优先遍历，我知道深度优先会迫使我

尽可能地朝一个方向看，直到我不得不切换方向，对吧。

所以对于我从黄色开始，假设我们向右移动，那将是一个边缘，然后

再次向右移动，两个边缘向右移动，再次，三个边缘。 在这一点上，

我不能再向右移动了。 所以假设你向下移动，所以在 456 处必须再次切换方向

，七，八。 在这一点上，我们已经看到这

最终可能会到达蓝色目标节点。 但这不会是最短的路径。

不幸的是，虽然我的星形和节点非常靠近

，但深度优先遍历可能是不幸的，因为它可能会在完全错误的方向上搜索，

并一直蜿蜒穿过图形，直到最终找到我的目标节点，在

点我绝对没有最短路径。 所以我认为广度优先遍历

在这里会更有用。 所以让我们说从我的绿色节点开始，仍然是我的同一

起点。 如果我进行了广度优先遍历，我知道广度优先意味着

我将非常均匀地探索所有方向。 所以它看起来像这样。 所以我会

探索离我的起点一个边缘的所有节点。 然后从那里，我将

开始探索距离我的起点两个边缘的所有节点。 在某个时候，我会

到达我的目标节点。 如果这是我第一次看到我的目标节点，那么根据定义，

我一定是找到了最短路径，对，最短路径应该是两条。

所以这就是我为什么广度优先搜索会更有用的高级论点，

在我看来，对于这个问题，让我们在算法上逐步完成这个过程。

所以假设我有我的原始图表。如果我要进行广度优先遍历，

我知道我必须正确使用队列，无论队列是什么给你的

广度优先顺序。 我要做的是查看队列中的项目，我不仅要存储

节点，还要存储与起点的距离，这意味着我将

在队列中初始化我的起始注释距离为零。 这

代表了一个事实，好吧，那个W 的音符离起点零边缘

，因为它本身就是起点。因此，在任何时间点，我的队列中的项目

总是成对的，在节点逗号距离的右边。 所以现在我们将开始

我们的通用算法，我将继续迭代。虽然我的队列不是空的，但一次一次

的气喘吁吁的迭代会删除我队列的前端，我会将它标记为我的当前

节点。 此时，我应该检查一下 好吧，我当前的 W 节点是我正在寻找的东西

吗？ 不是，所以我需要探索 W 的邻居。所以我可以看看 x 节点。 而且我知道我

需要将它添加到我的队列中。 但是当我将它添加到我的队列中时，我想确保我

用距离标记它。 所以如果我当前的节点有这个零，我知道这个节点的邻居

会有距离一，所以我只是将当前距离增加一。 所以在我的队列上，

我放了一个项目，上面写着 x 逗号一个。对于这个 V 节点，我也有类似的情况。 它

也是 W 的邻居。所以我也将 v逗号放在我的队列中。 此时，

我可以进行下一次迭代，或者移动队列的前面。 所以我看了一下x。 然后

我看看 X 的邻居确实记住，因为我在这里有一个无向图，所以 x

确实有两个邻居，对，它有 w作为邻居，还有 y。 因此，

您应该已经知道我需要跟踪访问过的内容。 换句话说，当 x 要

考虑它的邻居时，它应该只关心 Y，对，我不希望 X

将 w 放回队列中，因为那样我会得到一个无限循环。 所以我只想

看看这里的Y。 我要把它添加到我的队列中。 因为我知道我当前的

X 音符的距离为 1，y 的距离必须为 2，始终只是将距离

增加 1。 凉爽的。 然后我继续这个算法。 我现在删除了队列的前面

，这将是 V 音符。 在这一点上，我可以考虑 V 的邻居，我

确实看到它的一个邻居实际上是 Xena，这是唯一未访问的邻居，

我将确保将 z 添加到我的队列中并用距离标记它 两个，对，

因为如果我的 v 距离为 1，则它的邻居的距离为 1。 在这

一点上，你已经可以看到这个算法是如何工作的。 最终，这个 z 节点

将离开队列，这实际上是我的目标节点。 因此，由于我已将一个节点添加

到与我的目标匹配的队列中，我知道我有我的最终答案。 这里的两个确实

代表了我们在该逻辑路径中采用的边数。 当然，我也会将其

退回。 所以在大多数情况下，这个算法听起来就像一个经典的广度

优先遍历。 在图上使用队列，唯一有趣的一点是现在我们

还将跟踪当前距离。 您知道，在计算路径长度时

，您需要一些计数机制。因此，如果您从

距离为零的起始节点开始队列，则每次离开立方体并添加其邻居时，它

应该将该距离增加一。就像你已经猜到的那样，这个算法

非常有效，因为我们不必遍历图形不止一个。

所以我们会看到这具有线性复杂性。好吧，我想我已经拥有

了编写这个代码所需的一切，我相信你想知道这些实现细节。 所以

你想要做的可能是你自己给这个实现一个机会。 如果您需要帮助，

可以在这些演练视频中找到我。到时候那里见。 嘿，程序员，艾伦在这里，

对。 现在让我们看一下最短路径问题的 JavaScript 解决方案。 因此，我们将

直接进入，希望您观看进场视频。 因此，我们首先将

边列表输入转换为对遍历更有用的东西，例如邻接列表，

我们将编写一个非常经典的函数。当我称它为构建图时，就像您期望的那样，

它包含边缘。 我希望它返回一个邻接列表。 对我来说，这意味着一个 JavaScript

对象，我将其称为图形，在此函数结束时，这将有助于我

返回图形和一些通用代码，我将遍历每一对，对 ，

基本上每个边缘，我会说，对于边缘的左边缘。 当我遍历每条

边时，我想做的是将边解压缩到其组件节点中，我将其称为 a 和

b。 现在我可以开始格式化我的邻接列表了。 所以我知道我希望这个图的

键显然是节点，我希望值是该节点的邻居的数组。

所以我要做的是，这是第一次遇到节点，我会检查。 好吧，如果这是一个节点，

如果它还没有在图中作为键，那么我应该第一次创建它。 因此，

将其用作键并将其值初始化为一个空数组，基本上，一开始

将没有邻居。  B 也是如此。然后，在这一点上，我知道 A 和

B 现在肯定作为图中的键存在。 所以我只想添加那些邻居。

所以如果我有一条边，比如 w 逗号 x，我知道x 是 w 的邻居，而 w 是 x 的邻居

。 所以简单地说，画一个点推B，然后正好

相反。 凉爽的。 所以这应该给我们我们的图表。 让我们继续在

我们的 main 函数中使用它。 所以我们只会说图等于在边上构建图。

我们现在要做的实际上是在我们的广度优先逻辑中工作，就像我们在

方法视频中所说的那样。 所以我要做的几件事，我肯定会设置我的队列，

我们说过这里胜利的关键是不仅将节点存储在队列中，而且对于

队列中的每个类似帧 还存储它与节点 A 的距离。所以我会

像一对东西一样使用。 所以我队列中的元素总是成对的。

我将抛出初始节点 A以及数字零，因为在开始时，

正确的，这个节点 A 与自身相距零边缘。 所以这很好。 随着时间的推移，

我会增加。 这个数字，看起来不错。 所以让我们继续

在这里。 好吧，一个while循环，经典条件就可以了，当你的

队列不为空时，我会从队列中删除一些东西。 因此，

如果您想遵循真正的广度优先顺序，请始终从前面移除。 所以我可以做点移位。

这将给我一个数组或在这里给我这些子数组之一。 我知道

它总是一对，所以我可以打开包装。 我会说好吧，抓住

当前节点以及距离。 好的。我将在这里检查刚刚

从队列中删除的节点。 如果那个节点是节点B，那我一定是刚刚找到了一条路径并且

我知道该路径中的距离，我可以返回它。 但如果这个条件不成立，

那么我需要继续搜索我的图表。因为这意味着我需要将此节点

邻居添加到队列的后面。 所以我要迭代记住我们一直都有邻接

列表。 所以我要说，比方说，节点图的邻居。

所以得到这个节点的所有邻居。我要做的就是将这些邻居添加到

我的队列中。 所以 q dot push，neighbor，试着记住我们的图的形式在

这里。 也许作为一个快速的小抽查，确保在同一页面上，让我只是控制台

点日志，邻接列表，假设我们手动拿了这个例子，把它贴

在下面。 我只是给它一些很好的手动运行，我还没有运行测试用例

。 所以我们把这个边缘列表转换成这个邻接列表，对。 当

我们对 W 之类的东西说不时，当我们说图形，方括号，不，这会给

我们这个数组，共同创作的排序器，迭代，遍历这个节点的所有邻居

并将它们添加到队列中，我们的一件事 应该注意的是，当我们将事物推

回队列时，我们希望保持相同的格式。 所以我实际上仍然想保持

对。 所以我会做对的第一个元素，第二个元素上的相邻节点

需要是距离。 而且因为是邻居，所以这里的距离会加一

。 所以这就是我成长和计算距离的方式。 所以让我们来测试一下。

不过，我们仍然需要做一些事情。 但是我们将传递其中的一些

示例，至少在我们对特定示例超时之前。 这段代码缺少的一件事是

任何循环预防，对吧？ 我知道这将是一个非常常见的场景，因为

我有一个无向图，对吧。 所以我肯定会做的是维护一个访问过的

集合，一种你习惯的模式，我们现在要实现我们的迭代，

喘不过气来。 所以从一组开始。 当您反复执行此操作时，

将确保如果将某些内容添加到队列中，也应将其标记

为已访问。 所以如果我用节点 A 初始化我的队列，那么我也想用节点 A 初始化我的

访问集，就像这样。 所以如果你不熟悉 JavaScript 中的 set 构造函数

，如果你想用一些值来初始化它，你实际上必须

传入一个包含这些值的数组。 所以我访问集的值

只是节点写入节点 ID。 凉爽的。然后我想将该逻辑应用到我的 while

循环中。 所以每当我要向队列中添加一些东西时，也就是说，我要向

队列中添加一个邻居，首先检查那个邻居是否还没有被访问过，所以只有

当没有访问过时才有邻居。 对，所以只有当这个邻居还没有被访问过时

，我才应该把它添加到我的队列中。 如果我要将它添加到队列中，就像我们刚才

所说的任何感兴趣的东西一样，应该立即将队列标记为已访问。 所以在这里

我会说visited, add，邻居网络应该避免将任何特定节点多次添加

到队列中，避免任何循环。惊人的。 所以感觉还不错。

让我们测试一下。 现在。 我们希望至少不要超时，所有同样的例子，我们

实际上在我们期望负数的地方返回未定义。 因此，如果您查看实际

提示，他们会告诉我们，好吧，如果您找不到 A 和 B 之间的路径，那么您

应该返回负数。 让我们看一个例子或测试 04。然后你把

它画出来，你会看到没有连接 B 到 G 的路径。

我们现在返回 undefined 的原因是我们要完成遍历 意思是，这意味着我们的

队列将被清空。 然后我们将结束这个函数。

如果我在 JavaScript 中默认没有点击返回行，我会得到未定义的。

所以我们知道如果我们完成了while循环，并且我们从未找到节点B，那么我们可以返回

负一，这一定意味着没有这样的路径将a连接到b。 所以让我们来

测试一下。 现在。 这应该是我们最短路径算法的最终版本。

惊人的。 因此，请务必在继续之前练习此算法。 并且请确保

您首先了解广度的选择，而不是深度的选择，因为大多数基本的

仅图形问题都需要您计算最短路径路径，这意味着仅意味着

边的数量。 通常，您会发现广度优先最简单的方法来计算嘿程序员，

这里是 Alvin，现在让我们来看看这个岛屿计数问题的方法。 所以

在这个问题中，我们将得到一个表示陆地和水域网格的二维数组，

这里有 l 个字符表示陆地，W 个字符表示水。 让我们

试着想象一下。 在这个问题中，我们要做的是返回一个

表示网格上岛屿数量的数字。 我们将把岛屿视为垂直或水平

连接的陆地区域。 所以在这个特定的例子中，我们应该返回四个。 因为

有四个不同的岛屿，我们可以这样标记它们，这对我们来说将是任何类型的

问题。 我们真的应该把它当作一个图表来考虑，我

将把这些样式问题称为网格图。因此，尽管我们没有给出任何明确的

节点和边，但我仍然可以将此图的位置视为节点。 例如，让我们

考虑这里的索引。 所以我在左侧有我的行索引，在顶部有我的列

索引。 我可以使用一对行和列来指定这个网格的任何位置

。 例如，如果我查看位置 3 逗号 4，那就是

这里的位置。 而我应该做的是将一个位置想象

成一个节点。 如果我遇到了一些节点，我确实有一些潜在的邻居。 给定

传播的任何位置，我在上下左右方向上最多有四个邻居。

给定网格的任何位置，很容易确定我们的潜在邻居

是什么，实际上只是从行或列中添加或减去一个

。 让我们概括一下这个公式。 所以假设我在某个位置，我们

称之为我们的看到，如果我想让它向上，那就意味着你递减，一行一行，

保持列不变。 如果你往下走，那将意味着将行增加一，

如果你往右走，那将意味着将列增加一。 如果你想向左走，

那么你应该把列减一，记住

我们网格的左上角是00。这就是我们有这种算术规则的原因。

所以现在我们开始构架这个网格问题，就好像它是一个图一样，我们可以使用一些

常见的模式，我知道这个问题真的是要求我计算这个网格上的

连通分量的数量或者岛屿的数量. 所以我需要一些迭代

代码，可能需要一些嵌套循环来迭代每个潜在的岛屿并

在那个岛上开始一些遍历。 因此，当涉及到我们的迭代代码时，我们只希望嵌套

循环遍历每一行列。这意味着迭代应该看起来

像这样，只是从左向右移动。 直到我们完成了哪种情况，我们可以进入

下一行。 让我们真正解决我们算法中需要的主要逻辑。 所以

假设我们从一开始就开始或嵌套循环，我要做的是检查我的当前位置，

我想做的是检查我当前的位置是否是陆地，现在是水，所以我可以

继续。 在下一次迭代中，我确实有一些土地位置。 既然我在

一块土地上，现在，我想做的就是尽可能地探索这个陆地区域，可能

使用一些深度优先遍历。 请记住，就像我们的大多数无向图

问题一样，我们需要确保将事物标记为已访问，这样我们就不会

陷入任何无限循环。 例如，如果我开始遍历，在这个位置，我

可以向下走。 但我也可以从这里往上走。 而且我可以在上下两者之间反弹

，给我一个无限循环。 所以我们知道如何使用我们所有的图机制来解决这个问题

，对，只需使用访问集。 因此，如果我进行深度优先遍历，

从这个位置开始，我知道我会将所有这些陆地块标记为已访问。

我还想做的是确保我增加账户，代表

我刚刚完全探索了一些新岛屿的事实。所以现在，我的计数为零，因为我刚刚

完成了一些探索，现在我的计数是一。 在这一点上，我可以回

退到我的迭代代码来扫描另一个岛。所以我向右移动，是水。 所以继续，

水继续。 现在我有了另一个岛。再一次，我只是先做一些深度

遍历。 当然，我会增加计数。这种模式会遵循吗？ 最终，

当我击中新行时，我可能处于陆地位置。 但我也应该确保

这个土地位置是未开发的，对吧。 所以由于我在位置一，逗号零，并且

这片土地已经被探索过，我不需要开始深度优先遍历。 而且

我也不需要在这里开始遍历。这继续，避免开始遍历。

无论我在哪里参观过一块土地，我们最终都知道，我们会去到一个像这样的新

岛屿，在那里我有一块未被参观过的土地。 所以到那时，

这就是我开始新的深度优先遍历的标准，我探索这个区域，增加

我的计数，并像往常一样继续工作，直到我到达最后一个未被访问的岛屿。

所以我访问它并增加我的计数。在我的迭代结束时，

我的最终数应该是四。 所以这个逻辑实际上非常简单，只是

我们经典连接组件的一种变体，计数逻辑，除了现在我们正在调整

我们用于查看邻居的标准，对，我们的邻居实际上

只是要么高于向下我们当前位置的左侧或右侧。 我们

谈到了这个算法的复杂性，我们应该考虑输入的大小和

它有两个维度的事实，对吧？因此，如果我说 R 是多行，

C 是多列，那么迭代代码非常简单，我知道

这将给我 r 次 C 迭代。如果我还考虑任何潜在的深度

第一次遍历，我会从一些土地开始。在最坏的情况下，我可以拥有一个巨人

岛，这也将是我们参观的时间。 所以整体复杂度，这

只是我们的时间看，空间复杂度非常相似的原因是我们的时间看，因为

假设我们将所有这些位置标记为已访问，这可能意味着我们

必须将它们添加到一些 放。 对，所以我们有时间看到不同的立场。

最后，我可以将它们中的每一个都添加到我的集合中，这是我们这个时代的空间复杂性。

See 还包括任何与遍历相关的数据结构，如堆栈或队列，具体

取决于您如何实现这一点。 所以总的来说，这将是解决这个问题的一个非常有效的解决方案

，你应该做的可能是先自己试一试，如果你遇到

困难，你可以在演练视频中找到我。 我会在那里见你。 嘿，程序员们，

Alvin 在这里，现在，让我们回顾一下这个岛屿计数问题的 JavaScript 演练。

因此，请务必先观看进场视频。 我们将直接进入。所以我们

知道这实际上只是我们这种图连接组件问题的衍生，

除了现在我们有一个网格图，对吧？ 我仍然可以把这个网格想象

成一个图表，因为如果我考虑这个网格的任何特定位置，我知道我

有一些我可以主要通过的相邻位置，我的四个邻居上、

下、左和右 对我来说，让我开始编写一些迭代代码，这些代码可以

在这个网格的每个节点或每个位置开始遍历。 这样，我就可以开始考虑

不同的岛屿了，对吧。 因此，我将为此只使用一个 for 循环，我将

遍历每个位置的每个可能的行列组合。 所以我会说 R

等于 0，迭代到网格的长度，所以网格点长度到我们的加号等于

1，并且对嵌套在里面的列做一些非常相似的事情，对吧？ 不过要注意

这里的一些细节，看看这些例子，我们实际上不能假设我们总是

得到一个方形的方格，意思就像行

数和列数一样，因为有时我 '偶尔会有一个不对称的网格，

对吧？ 如果我看第一个，这里的宽度看起来是五，

但高度是六。 因此，对于列，我想在这里引用列线

。 所以我们要说网格，零长度。好的。 所以在这一点上，我有一些行

组合，我想开始遍历，比如说在那个位置进行深度优先遍历

。 所以在这里我调用了一些类似的辅助函数，这将使它

有点，我称之为探索。当然，接下来要做的是获取网格信息，

以及我想要遍历的行列。 在这一点上，我认为我们

实际上会构建这个辅助函数，然后我们可能需要

在我们的主驱动函数中填写更多逻辑。 所以让我们烘焙这个探索辅助函数。

所以拿网格和你的行列来说，我还应该考虑的是因为

我知道这确实是一种图形问题，对吧？ 我想防止无限

循环，对吗？ 所以考虑一下，假设我正在穿越的某个地方，

假设我在这片土地上，我知道这片土地将

穿过它的右邻。可能是这块土地现在从

它的左邻中移动，所以我先左后右再左后右。 现在它给了我一个

无限循环，对吧。 因此，每当您有类似无向图或无向

连接的概念时，请始终使用已访问集进行保护。 我们以前见过这种模式。 所以也许

在全球范围内，对于整个遍历，我将创建一个访问集。 所以在 JavaScript 中，

只是一个新的集合，你可能想知道，你知道，我要如何创建

这个集合的成员？ 好吧，我需要指定职位，对吗？ 把它想象成位置

就像这个图表中这个网格中的节点，对吧。 所以我要做的是传递这个

访问集，所以我可以在这里接受它作为一个组织。 在使用访问

集时，您要做的是确保将行和列组合在一起，因为

它们一起指定了您的实际位置。 与其他编程语言相比，我认为这实际上更值得一读

，更像是 JavaScript中的一种语言。 这么

快就在这里，让我自己多一些空间可能需要一段时间。 因为如果你

不熟悉套装，而且你不知道它们的细微差别，以后可能真的会打击你

。 所以假设我有一个集合，所以我将创建一个偏移量。 那么你可以设置

并假设我添加了我不知道，比如包含行列位置的数组。 所以

我要说的是，好吧，也许我有位置，我不知道，一个逗号三。 我把

它添加到我的集合中。 所以我确实添加了那个位置。这实际上是 JavaScript 中的一个常见问题。

如果您将任何类似的引用类型（如数组或对象）放入您的集合中，

那么当您稍后检查是否存在时，它实际上会检查引用是否相等

。 换句话说，现在我不能真正做到控制台点日志的点有一个三，因为

这个数组字面量在技术上是内存中的一个不同的数组。 所以我希望我能

在这种情况下恢复真实，但我不会得到真实的。 所以我们将手动运行它，

看看我们得到了什么。 所以就像，我们说，我们会在这里得到一个假的，这不是很好。

因此，您的解决方法是将其实际转换为一些字符串数据。 所以相反，也许

写得好像你有一个逗号三，因为字符串是原始类型，我实际上

可以存储那个字符串。 所以每当我说字符串文字时，这实际上

会给我一个匹配，所以我应该在这里得到一个很好的true。 惊人的。 所以我们要利用这种

模式来发挥我们的优势。 所以也许我会从创建一些位置变量开始，

这就像 FIDE 的字符串一样，是我们位置的一个版本。 所以就拿我的

行，也许加一个逗号，然后把列放在这里。 好的。 我想用逗号分开的原因

是，我的行和列需要有不同的界限。 换句话说，

假设我有一排比方说 12。我有一列四。 如果我把它变成一个键

或一个位置，这会给我一个看起来像 12 的位置，另一个场景是逗号，

假设我有第一行，然后是第 24 列，这会给我一个这样的位置吗？

一个逗号 24. 对，用逗号分隔行

和列位置非常重要，因为想象一下，我没有放逗号，那么这里就会发生冲突

，我有两个完全不同的位置，对吧？  12、4 和 124。如果我不

加逗号，它们看起来就像具有相同的位置键。 所以这就是为什么我需要用逗号

分隔它们。 常见的问题。 但是现在我有了这个位置，我可以

在这个被访问的集合中利用它来发挥我的优势。 所以如果我已经访问过这个位置，那么如果我访问过的

有这个位置，那么我应该退出，对，我需要返回一些东西。 我希望这个

explorer 函数做一些类似的事情，就像我们在旧组件问题中所做的那样，

我希望它返回一个布尔值，指示这是否是我正在探索的新岛屿。

所以如果它已经被访问过，那绝对不是新的，对吧。 所以只需返回 false，这意味着

它不是一个新岛。 如果我通过了这个if 语句，换句话说，如果

位置没有被访问，我需要现在将它标记为已访问，第二，做访问，

添加这个位置。 所以现在我有了我的核心，比如循环预防逻辑。 除此之外，我

还有其他一些场景，我们知道在遍历过程中，我们将看到我们不同的

相似邻居。 所以我想做的是确保我在这个范围内。 所以我

要检查一下，比如把它分解成变量，我会说，一个，一个

叫做边界行的布尔变量。 我要做的只是检查零是否小于或等于该

行。 而且那行严格小于我的网格长度。 所以我只是检查

我的反对是否在这里，我做一个快速检查，我需要

包含零，因为零是一个完全有效的索引，对吗？ 我需要排他

的长度，因为想象我有一个长度为 5 的网格，它的最后一个有效索引是 4。

所以我需要严格低于这里。我会为我的列写一个类似

的变量，就像这样。 在这一点上，我可以写一个很好的语义 if 语句检查，

好吧，如果你的行不在边界内，或者你的列不在边界内，那么退出，对吗？

所以在我可以返回 false 之前返回，对吧？ 因为我不应该

将无效位置和平衡位置视为孤岛，对吗？ 所以看起来不错。

我需要的最后一个基本情况是，如果我当前的位置是水怎么办，对吧？

我只想穿越陆地。因此，我将为此添加另一个声明。 所以

在这里，我可以检查。 好吧，如果我的网格在行列，如果它等于水，那么

也返回 false。 没有理由计算它，

在索引到网格之前将其放入边界检查非常重要，对吧？ 因为想象你的行和

列超出了界限。 如果你像这样写第 15 行，你马上就会得到

一个越界错误。 因此，如果您愿意，请从您的警卫开始检查您是否在界限内

，因为大多数这些条件它们都返回 false 具有相同的后果。

你可能或他们在一起。 通常我喜欢把它们分开。 这样我总是

记得写它们通常是为了像你的网格图问题。 这是非常规范的

代码。 好吧，所以如果我通过了所有这些基本情况，并且我有递归

情况，那么我必须在一块未访问的土地上。 而当我想做的是做我的深度

优先遍历，对吧。 所以这里是我探索邻居的地方，我有四个邻居。

如果我想超过这个值，我将逐行递减，保持列不变，

传递相同的访问，因为请记住，我们在这里有数组索引。 所以这

是第 0 行，这是第 1 行。 所以我们将较低的行号表示向上，以同样的方式，

较低的列号表示向左。 所以这是向上的，这是向下的，在这里只需减去

一，即在左侧，然后在列上加一将在

右侧。 很酷，而且我可以保持这段代码非常平坦，因为当你编写递归时，我非常支持它

，在大多数情况下，我总是试图确保

在我跳跃之前我不看。 换句话说，仅从这个逻辑来看，

行减一不可能超出界限。 但没关系。 因为如果它越界，当

我评估这个调用时，它会立即被这个基本情况捕获，对吧。 如果

我这样表达我的逻辑，如果我不看，在我离开之前，如果我只是跳跃然后抓住

基本情况，你就不必编写重复的代码。 换句话说，

有些人编写这样的代码，就像，好吧，如果行减去一个入站

类型使用伪代码。 在这里，他们必须写行加一个入站。 而且您

必须在每个递归调用周围编写一个保护 if 语句，而不是只编写

一个基本情况。 你可以捕捉到所有这些不同的界限，对吧。 所以这就是

为什么我更喜欢这种方式。 所以我知道，当我从这些递归

调用中返回时，我又回到了我的代码的这一部分。我能做的就是返回 true，因为我

必须完成该遍历。 而我返回true的原因是true象征

着我刚刚探索完一个全新的岛屿，所以我需要数一数。 好的。 它

也与数据类型一致，我为这个探索功能设置了布尔值。 所以

在大多数情况下，这看起来真的只是我们之前的类似图、深度

优先代码的衍生。 现在我想在我的主要功能中使用该布尔数据。 所以这里是

我可以实际计算我的岛屿的地方。 所以我想我真的需要一些逻辑来说明初始化

一些计数为零。 每当您找到一个新岛屿时，就增加该计数。 因此，

如果我刚刚找到了一个新岛屿，我们将从这个电话中恢复过来，对吧？

因为请记住，我正在开始遍历，从该行列位置开始。 因此，如果

它让我返回 true，那么我可以完全将我的计数加一。 请注意，每当

我开始遍历我之前见过的位置时，它都会被添加到

之前访问过的位置。 所以我会通过第 21 行的这个 if 语句返回，我返回 false。 如果我返回 false，

那么我不会重复计算那个岛。 所以我确实需要结合使用这两种迭代

代码来潜在地跳转到不同的岛屿。但我可以使用已访问集来防止

自己重复计算任何特定的岛屿。所以这看起来很不错。

当然，我们不要忘记最后返回我们的计数。 让我们试一试。 这

可能是一系列类似网格图问题中的第一个。 真正尝试

理解我们如何将网格视为图形，对吗？ 我们只是有不同的

规则来看待我们的邻居。 正确的？现在，一个节点实际上是一个位置，它的邻居

是它的四个邻居上、下、左和右。 好的程序员，我希望你们

练习这个模式，因为我们将在接下来的几个问题中看到它。 我

留给你看下一篇。 嘿，程序员们跑到这里了，现在让我们来看看

这个最小岛问题的方法。 所以我们将在这里得到一个包含内陆水域的网格，

实际上只是我们网格内的一些字符。 所以当然，像往常一样，让我们

一下。 在这个问题中我想要做的是返回一个代表

最小岛屿大小的数字，我们将考虑一个岛屿，一个垂直

或水平连接的土地块的连接区域。所以对于这个特定的输入，我们的答案应该

是查看我们的网格，我有三个独立的岛屿。 而且它们都有不同的尺寸，

对吧？ 大小，四，二和五，我只选择最小的岛屿。 那

就是这里的两个人。 那么我如何才能真正想出一个策略呢，你

应该已经知道这只是我们之前的网格图问题的一个衍生，

而不是只计算岛屿的数量，现在我想 找出

岛屿的大小。 我知道要实际查看不同的岛屿，我需要一些

嵌套代码，但我还需要一些深度优先遍历代码来探索单个

岛屿。 所以总的来说，这对我们来说应该是一个非常经典的策略。 所以假设我们开始

攻击这个我们知道我们将在左上角开始我们的嵌套循环

如果我们当前的位置是水，那么我们实际上不需要做任何事情。 下一次迭代，

我有一些土地。 在这一点上，我可以开始我的深度优先遍历。 而且我知道

我应该将事物标记为已访问以避免任何无限循环，对。 因此，

当遍历完成时，我将把所有这些人都标记为已访问。 但我也

想确定整个岛屿区域的大小。 所以每次我得到一个位置

是土地，我应该把它当作一个。 然后当谈到我如何实现遍历时，

我可以把这些收集起来，对，把它们都加起来。 所以看起来

像这样。 对于我对遍历的顶级调用，我应该得到一个大小为 4 的岛

。 因此，如果这种遍历算法，尤其是我们如何计算岛的大小

，是相当复杂的，不用担心当我们真正进行代码遍历时，

这只是一些递归的问题，而一些递归我们 '

在过去的课程问题中实际上已经看到过。 但无论如何，现在我有了这个大小为四个的岛，

它实际上是我见过的第一个岛。因此，到目前为止，我将其视为中等大小

。 但我需要继续寻找以防万一。 所以向右移动。

所以如果是水，我什么都不做，再水，什么也不做。 现在我有另一个岛屿，我

开始我的遍历市场这些访问。当我找到这个岛的大小时，

当然，它会给我两个，我将它与我目前的中号比较，两个更小，

所以到目前为止我存储了两个作为中号。我们只是照常营业。 请注意，

当我们到达一块土地时，我们真的想确保它是土地，但也是

一块未被访问的土地。 所以现在就在那块土地上，但它被访问过，所以我

不应该穿我不需要从这里开始遍历。 同样，对于这个职位。 最终，

我要去一些新的未被访问过的土地，在这种情况下，我应该开始我的

穿越探险家，这个地区，我想计算所有这些土地。 而且我应该

意识到这个岛的最终大小将是五，我可以将这个五与

我目前的最小值进行比较，五更大，所以两个的大小可以保留。 我可以

在这个算法结束时返回最小大小，基本上代表这个

大小为 2 的岛，这个算法的复杂性很简单，我们应该说

我们输入的大小是 r 乘以 C，因为我们有 我们的行和 C 列，在这种情况下

，时间复杂度就是我们的时间 C，对，我们必须遍历

网格中的每一行列。 甚至当我们开始遍历时，在最坏的情况下，我们可能会有

一个跨越整个网格的岛，在这种情况下，它也是我们的 C.Right。 所以总的来说，

我们的全部复杂性是时间 c 空间复杂性也是时间 C。 并且确实知道这

在技术上是网格大小的线性解决方案，因为网格本身

正好是 r 乘以 C 个位置。 因此，我认为我们已经准备好编写这个代码并

首先自己尝试一下。 如果你遇到困难，我会在演练视频中抓住你。

到时候那里见。 嘿，程序员，这里是 Alvin，现在让我们来看看

这个最小岛问题的 JavaScript 演练。 所以我们会直接进入，确保你观看进场

视频。 与往常一样，这只是我们经典跳岛逻辑的一个很好的衍生。 但是

对于网格图，对。 因此，让我们从可以帮助我们开始遍历的迭代代码开始

。 从我们网格的每个不同位置开始，这仅意味着一些嵌套

循环。 因此，首先遍历所有行和列。 所以 r 等于 0，

直到 r 小于网格的长度，也为我的列做我们的 plus 等于 1 和非常相似的

循环。 但是请确保您参考了您的内列线，因为

您可能在这里有一个矩形网格。 我现在要做的是

从每一行列开始遍历。所以我假设我

在这里有一个辅助函数来进行遍历，我将把它称为探索大小。 那是因为从

长远来看，我对那个岛的大小很感兴趣，对，就像一个代表

这个岛有多大或有多少位置的数字。 所以我将传递网格

信息以及位置。 而且我知道当涉及到所有这些无向

图时，遍历可能应该防止你的循环。 我在这里有一些远见。

所以我将传递一个很好的访问集，我可以在

整个遍历过程中全局维护它，因为只有一个很好的理由来探索一个正确的位置。 所以

我将创建 const visitor 将其作为我的neighs JavaScript 集。 以及一些

原因。 好吧，对于一个 JavaScript 集，给我一次查找的 O，但也给我一次插入的 O。

所以这将是一个非常快速的数据结构。 从那里开始，我们可能必须

在此处添加更多逻辑才能实际对大小做一些事情，但现在，我

想我要换个角度，实际看看构建这个辅助函数，

对吧。 所以我认为构建这种遍历的最好方法是使用一个聋钱包，通常

只是我去解决这样的问题，它会接受我知道网格，

列中的行并且也访问过，我需要一些基本情况是非常经典的基本情况，我

将首先检查此行列位置是否为入站。 所以我最喜欢的

模式是拆分一些变量，这样更容易阅读和调试。 所以

我要说的是我的行入站，只是让它像一个布尔变量。 所以我会

检查，比如说，零是否小于或等于行，我需要说对，

并且该行应该严格小于网格长度。 所以这个布尔值

只有在界限内才是真的，对吧？ 与我的列边界非常相似的东西应该

在零和网格零长度之间。像这样很好，我相信。 然后我可以

使用这两个子句编写一个不错的 if 语句。 所以我可以说，好吧，如果假设你的

行不平衡，或者你的列不平衡，那么你肯定是有界限的。

所以你可能应该在这里使用一些基本情况，对吧？ 所以我们这里都选择返回

为零，因为我想保持一致的数字，对一致的返回类型。

也就是说，我知道这个函数的目标是返回探索

岛屿的大小一个数字。 所以即使在我的基本情况下，我也需要确保我返回某种类型

的数字，返回零来表示，嘿，如果这超出范围，它不会

对大小的计数做出任何贡献，对， 很好去。 我需要一些

其他的基本情况。 如果我的位置是入站怎么办。 但如果它真的是水呢，

我也不想计算它。 我只想数岛屿。 所以正确着陆。 所以快速

修复，我要做的是添加一个新的基本情况，我可以检查我的网格是否在行列，如果它

等于水字符。 所以大写的W 也可以返回零。 如果您愿意，

您也可以将它们合并成一个 if 语句，只需编写一堆

ORS，我有点喜欢将它们分开，因为我很容易记住

它们每个人都写了什么最后的条件有没关系，如果我通过了这

两个基本情况，可能是这个位置是土地，但它是我

已经访问过的土地。 所以这就是我在访问逻辑中工作的原因，我将表示一个位置，

就像我们在上一集中所说的那样，实际上只是一个字符串。 所以我可以把它作为

我访问集的成员。 所以我要说位置必须是行加逗号加

列。 所以只是代表位置，那是因为我不能像数组一样添加

到访问集中，然后再查找它。因此，如果visited 具有该位置，那么它

就是我探索过的重复位置。 所以归零。 否则，它还没有被访问过

。 所以我现在一定要去参观。 所以我可以添加它。 好的。 所以我已经制定了我的基本案例

。 现在我需要我的实际递归代码。 所以我会探索我的四个邻居。

到目前为止，您应该熟悉这种模式。所以往上走，一行减去一列就传递

给同一个访问者。 所以我将分别探索我的上下左右邻居。

我做我的递归自助餐理论，对。那么我希望从这些电话中得到什么类型的电话，

他们会给我一个数字，代表我的邻居所在的岛屿的大小

。 但如果我的邻居是某个更大岛屿的一部分，那么我也是，因为

我们与邻居直接相连。 所以我想创建所有这些

返回值的总和。 所以我要创建一些大小变量，比如说让大小，我

要在这里将它初始化为一，它将是一而不是零，因为一代表

我当前的位置，我的行列。 无论这些调用返回什么，无论是什么数字，我

都会将我的大小增加那个数字，就像这样。 最后，我可以在这里返回我们的总

大小。 所以这将做我的深度优先遍历，因为它是递归的，但我们

也会计算这个岛区域的大小。凉爽的。 所以现在我有了一个有效的探索

尺寸助手，让我们在这里的主要功能中使用它。 所以我要从这个电话中取回一个号码

。 我会称它为我各自的大小。这个逻辑的好处是，如果我

有一个岛或位置，我以前已经见过，并且我在这个

for 循环中再次遇到它，那么我会提前返回，因为我会遇到这个基本情况，对吧？ 如果某个东西

已经被访问过，就自动返回零，因为我已经考虑过

了，没有理由再考虑它。 但是现在我需要我的最小化逻辑，对，我想要

最小岛的大小。 他们在问题中告诉我们，我们完全可以

假设您的网格至少包含一个岛。 所以我认为这里的一个很好的默认值

是使用正无穷大，所以我可以设置一些会说最小尺寸变量要成为正

无穷大，JavaScript，如果我将其设为正无穷大，我知道当我遇到任何类似的

有效岛大小时，它会继续 小于无穷大。 它应该取代它。 所以现在

我可以在这里做一些最小逻辑并检查。好吧，如果这个岛的大小

小于我目前看到的最小大小，那么只需用那个岛替换那个最小大小

。 然后在我完成所有这些遍历潜在逆转之后，我将返回

我的中号。 所以这里有一些经典的模式。有一个细微差别是我们没有考虑

如何运行代码，我们可以一起调试它。所以看起来我们失败的例子。  00.

所以我们期望回答的第一个例子，我们不小心给了零。 如果你

看第一个例子，很明显，是的，最小尺寸是两个，代表

这里的这个岛。 我们返回零的原因是根据我们的代码。 让我们

看看我们就像第一次迭代一样，我要回应它，我知道

行将为零，列将为零，这意味着我的位置将是这里的 w

。 当我进行递归调用并传递位置 00 时，我知道

它将立即返回零，因为该位置是水。 我要检查

一下，是不是零，小于无穷大，所以我要用零替换最小尺寸

。 但如果我仔细想想，零甚至不代表一个真正的岛屿。 如果一个

岛的大小为零，那么它根本就不是一个岛，它是一片水，对吧？

所以我想在这里添加一些额外的逻辑，只实际查看非零数量。

因此，仅当该大小也有效时才进行比较。 所以大小当然应该大于

零。 我们想把这些加在一起。 所以让我们再试一次。

只是我们需要的一些小细节。惊人的。 对于这个最小岛问题，我们有一个解决方案

。 所以我们现在已经多次看到这种模式，正确或经典的

跳岛逻辑。 因此，当您将岛屿视为图的连接组件时

，这应该是您的第一种算法。 好的程序员。

这样我们的图表课程就结束了。 我希望你在课程中学到了很多东西。

一定要去 Shrutidotnet，在那里你可以继续练习

更多的图形问题，以及探索任何其他数据结构算法主题。 我会

在那里见你。